{
  "author": {
    "name": "Jack Carrick Xiang Cheng",
    "email": "chengxianga2008@yahoo.com",
    "url": "inovlab.com"
  },
  "name": "node-cryptojs-aes",
  "description": "Standalone cryptographic library. A minimalist port of cryptojs javascript library to node.js, that supports AES symmetric key cryptography. node-cryptojs-aes works great on frontend data masking and unmasking.",
  "version": "0.4.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/chengxianga2008/node-cryptojs-aes.git"
  },
  "main": "cryptojs.js",
  "dependencies": {},
  "devDependencies": {},
  "keywords": [
    "cryptojs",
    "aes",
    "data masking",
    "cryptography",
    "frontend",
    "encryption"
  ],
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "homepage": "https://github.com/chengxianga2008/node-cryptojs-aes",
  "license": "MIT",
  "readme": "node-cryptojs-aes\n=================\n\n**node-cryptojs-aes** is a minimalist port of cryptojs javascript library to node.js, that supports AES symmetric key cryptography.\n\nUnlike node.js native crypto library, **node-cryptojs-aes** removes openssl dependency.\n\nIt is built upon award winning browser side javascript library CryptoJS. currently, it has been updated to be compatible with CryptoJS version 3.1. \n\n**node-cryptojs-aes** doesn't make any modification to original cryptojs library, the syntax remains the same in accordance with [CryptoJS documentation](http://code.google.com/p/crypto-js/). \n\n**node-cryptojs-aes** doesn't rely on any external library, such as native openssl libary or any external node.js modules. As a node.js module, it can simply be installed through npm package management system. There is no configuration needed also.\n\n**node-cryptojs-aes** maximises node.js design spirit. Browser side and server side are running identical javascript cryptography codebase. It allows coder to migrate any browser side logic to server or vice versa without any modification. The message passing between server side and client side has been drastically simplified. The encrypted JSON data is passed between client side and server side without any additional parsing or encoding effort made on both side.\n\n**node-cryptojs-aes** works great on **frontend data masking and unmasking**. Client will do the heavy lifting to decipher and reveal the masked data, reduce server load and processing time.\n\n## Features\n\n  * **Self Contained** It doesn't rely on any external dependency.\n  * **Server Side Cryptography** It is the only up and running server side javascript cryptography library so far. \n  * **Cross Platform** It is working across all node.js supported platform.\n  * **Code Base** Browser and Server share same codebase.\n  * **AES symmetric key cryptography** It supports AES-128, AES-192 and AES-256 Encryption.\n  * **Encoding** It supports Base64 encoding, Hexadecimal, Utf-8 and binary.\n  * **Cipher Input** The key or iv(initialization vector) can be passed in as parameter of encryption function, or single passphrase can be passed in as parameter.\n\n## Sample Usage\n\nThis is a complete example where server encrypts data, browser requests encrypted data and passphrase, then processes decipher subsequently.\n\nTo best demostrate the library structure, and separate client side and server side, the server is going to be hosted on `localhost:3000`, whereas client can be run on any\nstandard `http server`. Communication is carried out through [JSONP](http://api.jquery.com/jquery.getjson/). I real world, however, application can be integrated into Express sinatra pattern.\n\nBrowser side is powered by [Bootstrap](http://getbootstrap.com/) Cover Template.\n\n### Server Side\n---\nThis part of code snippets are located in examples/server/server.js. Test out in command line:\n```\nnode server.js\n```\n#### Encryption logic\nThe logic on node.js server encryption logic consists of two parts.\n\n##### Part 1\nRight off the bat, it generates random passphrase using the native `node.js crypto` library method.\n\n```javascript\n//import crypto module to generate random binary data\nvar crypto = require('crypto');\n\n// generate random passphrase binary data\nvar r_pass = crypto.randomBytes(128);\n\n// convert passphrase to base64 format\nvar r_pass_base64 = r_pass.toString(\"base64\");\n\nconsole.log(\"passphrase base64 format: \");\nconsole.log(r_pass_base64);\n```\n##### Part 2\nThen, it performs data encryption\n\n```javascript\n// import node-cryptojs-aes modules to encrypt or decrypt data\nvar node_cryptojs = require('node-cryptojs-aes');\n\n// node-cryptojs-aes main object;\nvar CryptoJS = node_cryptojs.CryptoJS;\n\n// custom json serialization format\nvar JsonFormatter = node_cryptojs.JsonFormatter;\n\n// message to cipher\nvar message = \"I love maccas!\";\n\n// encrypt plain text with passphrase and custom json serialization format, return CipherParams object\n// r_pass_base64 is the passphrase generated from first stage\n// message is the original plain text  \n\nvar encrypted = CryptoJS.AES.encrypt(message, r_pass_base64, { format: JsonFormatter });\n\n// convert CipherParams object to json string for transmission\nvar encrypted_json_str = encrypted.toString();\n\nconsole.log(\"serialized CipherParams object: \");\nconsole.log(encrypted_json_str);\n```\n\nJsonFormatter is a custom json serialization implementation, you might create your prefered json serialization to fit into your own structure. According to [CryptoJS documentation](http://code.google.com/p/crypto-js/), the code snippets of JsonFormatter shipped with **node-cryptojs-aes** is as follows.\n\n```javascript\n//create custom json serialization format\nvar JsonFormatter = {\n\tstringify: function (cipherParams) {\n\t\t// create json object with ciphertext\n\t\tvar jsonObj = {\n\t\t\tct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)\n\t\t};\n\t\t\n\t\t// optionally add iv and salt\n\t\tif (cipherParams.iv) {\n\t\t\tjsonObj.iv = cipherParams.iv.toString();\n\t\t}\n\t\t\n\t\tif (cipherParams.salt) {\n\t\t\tjsonObj.s = cipherParams.salt.toString();\n\t\t}\n\n\t\t// stringify json object\n\t\treturn JSON.stringify(jsonObj)\n\t},\n\n\tparse: function (jsonStr) {\n\t\t// parse json string\n\t\tvar jsonObj = JSON.parse(jsonStr);\n\t\t\n\t\t// extract ciphertext from json object, and create cipher params object\n\t\tvar cipherParams = CryptoJS.lib.CipherParams.create({\n\t\t\tciphertext: CryptoJS.enc.Base64.parse(jsonObj.ct)\n\t\t});\n\t\t\n\t\t// optionally extract iv and salt\n\t\tif (jsonObj.iv) {\n\t\t\tcipherParams.iv = CryptoJS.enc.Hex.parse(jsonObj.iv);\n\t\t}\n            \n\t\tif (jsonObj.s) {\n\t\t\tcipherParams.salt = CryptoJS.enc.Hex.parse(jsonObj.s);\n\t\t}\n\t\t\n\t\treturn cipherParams;\n\t}\n};\n```\nThe serialized cipherParams object defaults OPENSSL-compatible format. It contains 3 properties, a IV, a salt and a cipher text encrypted by AES.\n```javascript\n{\n  \"ct\":\"gpiVs3D4dqUI/G8F+8Elgg==\",  //result of encryption performed on plaintext\n  \"iv\":\"008fffd119971f34dbd29e80a823cef2\", //IV\n  \"s\":\"43e2badf9eb689fd\"  //salt\n}\n```\n\n#### Express3 integration\nIf running express to serve http request on node.js, the response can be\n\n```javascript\n// encryption logic here\n\n//express 3 application\nvar express = require('express');\nvar app = express();\n\n// browser request serialized cipherParams object in path /crypto/encrypted, with JSONP support\napp.get('/crypto/encrypted', function(request, response) {\n\n\t//JSONP allow cross domain AJAX\n    response.jsonp({\n        encrypted : encrypted_json_str\n    });\n\n});\n\n// browser request passphrase in path /crypto/passphrase, with JSONP support\napp.get('/crypto/passphrase', function(request, response) {\n\n\t//JSONP allow cross domain AJAX\n    response.jsonp({\n        passphrase : r_pass_base64\n    });\n\n});\n\napp.listen(3000);\n```\n\n### Browser Side(Frontend Data Masking)\n---\nThis part of code snippets are located in examples/browser.\n\nOn browser side, The encrypted JSON string(masked data) should be embedded in a hidden tag when first time construct the page.\n\nFor demostration and simplicity, in our example, the encrypted JSON string is added to a hidden tag through AJAX.  \n\n```javascript\n// retrieve encrypted json string when loading page\n// define server cipherParams JSONP path\nvar encrypted_url = \"http://localhost:3000/crypto/encrypted?callback=?\";\n\t\n// JSONP AJAX call to node.js server running on localhost:3000\n$.getJSON(encrypted_url, function(data){\n\n\t// retrieve encrypted json string \n\tvar encrypted_json_str = data.encrypted;\n\n\tconsole.log(\"encrypted json string: \");\n\tconsole.log(encrypted_json_str);\n\t    \n\t// store masked data into a div tag\n\t$(\"#data_store\").text(encrypted_json_str);\n\n});\n```\n[Data Masking](http://en.wikipedia.org/wiki/Data_masking)\n> The main reason for applying masking to a data field is to protect data that is classified as personal identifiable data, personal sensitive data or commercially sensitive data. \n\nHacker and expert won't be able to access real messages through frontend code inspecting approach, such as `Firebug` or `Chrome developer tools`.\nData masking applied here protects sensitive data(such as credit card number) from being viewed by frontend code analysis without authorization.\n\nIt is worth noting that this approach comes into handy if there are requirements **large amount** of sensitive data need to be processed and stored in the client side at page construction time.\nOnce passphrase is passed from server, client will do the heavy lifting to decipher and reveal the masked data, **reduce server load and processing time**.\n\nOn the other hand, AJAX request will consume bandwidth when passing large amount sensitive data in real time, impose heavy workload on server at `spike time`, also browsing is delayed if network is lagging.\n\nLast but not least, `node-cryptojs-aes` frontend data masking is aimed at preventing frontend data hacker malicious behaviour, it can't stop MITM attack.\n\n#### Decryption logic\n\nThe logic of browser decryption also can be divided into two parts.\n\n##### Part 1\nRetrieve passphrase with a AJAX call\n```javascript\n// define server passphrase JSONP path\nvar passphrase_url = \"http://localhost:3000/crypto/passphrase?callback=?\";\n\t\t\n// JSONP AJAX call to node.js server running on localhost:3000\n$.getJSON(passphrase_url, function(data){\n\n\t// retrieve passphrase string\n    var r_pass_base64 = data.passphrase;\n\n    console.log(\"passphrase: \");\n    console.log(r_pass_base64);\n\t\t    \n\t// decipher part\n\n});\n```\n##### Part 2\nLast step, data is unmasked by calling browser AES script, take passphrase and JsonFormatter as parameter\n```javascript\n// take out masked data from div tag \nvar encrypted_json_str = $(\"#data_store\").text();\n\t\t    \n// decrypt data with encrypted json string, passphrase string and custom JsonFormatter\nvar decrypted = CryptoJS.AES.decrypt(encrypted_json_str, r_pass_base64, { format: JsonFormatter });\n\n// convert to Utf8 format unmasked data\nvar decrypted_str = CryptoJS.enc.Utf8.stringify(decrypted);\n\nconsole.log(\"decrypted string: \" + decrypted_str);\n\t\t    \n// convert into unmasked data and store in the div tag\n$(\"#data_store\").text(decrypted_str);\t\t    \n```\nLast thing, don't forget to add browser AES script and JsonFormatter to your index.html file.\nYou can load it straight away via github CDN network\n\n```html\n<script type=\"text/javascript\" src=\"http://chengxianga2008.github.com/node-cryptojs-aes/client/aes.js\"></script>\n<script type=\"text/javascript\" src=\"http://chengxianga2008.github.com/node-cryptojs-aes/client/jsonformatter.js\"></script>\n```\nOr you can find your own copy at client/ folder\n\n## Installation\n\nInstall through npm\n\n```\nnpm install node-cryptojs-aes\n```\n\n## Changelog\n\n**node-cryptojs-aes** Version 0.3.8 - 23/02/2014\n  \n  * Upgrade to cryptojs v3.1\n  * Test compatibility with nodes.js v0.10.26\n  * Add express 3 use case\n  * Refine the Readme document\n\n**node-cryptojs-aes** Version 0.3.7 - 01/08/2012\n  \n  * Add browser side support\n\n**node-cryptojs-aes** Version 0.3.4 - 21/07/2012\n\n  * Update to cryptojs v3.0.2\n\n## Donation\n\nTo support the developer's development and contribute to open source community and node.js community, you might donate money to help out your fellowmen, no matter how large or small, it all counts. With your effort, we can make a better world, Thank you.\n\n[![Donate to developer](https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=QPDFGUA4XRX5E)\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chengxianga2008/node-cryptojs-aes/issues"
  },
  "_id": "node-cryptojs-aes@0.4.0",
  "_from": "node-cryptojs-aes@=0.4.0"
}

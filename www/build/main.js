webpackJsonp([0],{

/***/ 1000:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_home_integrations_home_integrations__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_shapeshift_shapeshift__ = __webpack_require__(174);





// Providers






let ShapeshiftSettingsPage = class ShapeshiftSettingsPage {
    constructor(navCtrl, popupProvider, platform, statusBar, logger, shapeshiftProvider, configProvider, homeIntegrationsProvider, externalLinkProvider) {
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.platform = platform;
        this.statusBar = statusBar;
        this.logger = logger;
        this.shapeshiftProvider = shapeshiftProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.serviceName = 'shapeshift';
        this.service = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showInHome = !!this.service[0].show;
        this.headerColor = '#0d172c';
    }
    ionViewWillEnter() {
        if (this.platform.is('cordova')) {
            this.statusBar.styleBlackOpaque();
        }
    }
    ionViewWillLeave() {
        if (this.platform.is('cordova')) {
            this.statusBar.styleDefault();
        }
    }
    ionViewDidLoad() {
        this.loading = true;
        this.shapeshiftProvider.init((err, data) => {
            if (!err && !data) {
                this.loading = false;
                return;
            }
            if (err) {
                this.logger.error(err);
                this.loading = false;
                this.unverifiedAccount = err == 'unverified_account' ? true : false;
                return;
            }
            this.accessToken = data.accessToken;
            this.shapeshiftProvider.getAccount(this.accessToken, (err, account) => {
                this.loading = false;
                if (err)
                    this.logger.error(err);
                this.shapeshiftUser = account.data;
            });
        });
    }
    showInHomeSwitch() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showInHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showInHome);
        this.configProvider.set(opts);
    }
    revokeToken() {
        this.popupProvider
            .ionicConfirm('ShapeShift', 'Are you sure you would like to log out of your ShapeShift account?')
            .then(res => {
            if (res) {
                this.shapeshiftProvider.getStoredToken(accessToken => {
                    this.shapeshiftProvider.logout(accessToken);
                    this.navCtrl.popToRoot();
                });
            }
        });
    }
    openAuthenticateWindow() {
        let url = 'https://portal.shapeshift.io/me/fox/dashboard';
        this.externalLinkProvider.open(url);
    }
};
ShapeshiftSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-shapeshift-settings',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/shapeshift/shapeshift-settings/shapeshift-settings.html"*/'<ion-header class="wide-header">\n  <ion-navbar [navbar-bg]="headerColor">\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        <img width="140" src="assets/img/shapeshift/logo-white-shapeshift.svg" alt="ShapeShift">\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea [fixed-scroll-bg-color]="headerColor" [ion-content-background-color]="headerColor">\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar [navbar-bg]="headerColor" class="wide-header__title">\n        <expandable-header-primary>\n          <img margin-left width="155" src="assets/img/shapeshift/logo-white-shapeshift.svg" alt="ShapeShift">\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <ion-list class="bp-list">\n      <ion-item [ngClass]="{\'with-label\': unverifiedAccount}">\n        <ion-label>{{\'Show in Home\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="showInHome" (ionChange)="showInHomeSwitch()"></ion-toggle>\n      </ion-item>\n      <label-tip *ngIf="unverifiedAccount" type="warn">\n        <span label-tip-title translate>Unverified Account</span>\n        <div label-tip-body translate>\n          Please complete your account verification on ShapeShift website.\n          <br>\n          <a class="label-tip-link" (click)="openAuthenticateWindow()" translate>Verify Account</a>\n        </div>\n      </label-tip>\n    </ion-list>\n    <ion-spinner *ngIf="loading"></ion-spinner>\n\n    <ion-list *ngIf="shapeshiftUser">\n      <ion-item-divider>User Information</ion-item-divider>\n      <ion-item *ngIf="shapeshiftUser.username">\n        <span>Username</span>\n        <ion-note item-end>\n          {{shapeshiftUser.username}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>ID</span>\n        <ion-note item-end>\n          {{shapeshiftUser.id}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Email</span>\n        <ion-note item-end>\n          {{shapeshiftUser.email}}\n        </ion-note>\n      </ion-item>\n    </ion-list>\n\n    <div padding-bottom padding-top>\n      <button *ngIf="shapeshiftUser || unverifiedAccount" ion-button class="button-standard" color="danger" (click)="revokeToken()">\n        {{\'Log out\' | translate}}\n      </button>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/shapeshift/shapeshift-settings/shapeshift-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], ShapeshiftSettingsPage);

//# sourceMappingURL=shapeshift-settings.js.map

/***/ }),

/***/ 1001:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AboutPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__feedback_send_feedback_send_feedback__ = __webpack_require__(470);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__session_log_session_log__ = __webpack_require__(1002);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers__ = __webpack_require__(35);




// pages


// providers

let AboutPage = class AboutPage {
    constructor(navCtrl, appProvider, logger, externalLinkProvider, replaceParametersProvider, translate, persistenceProvider) {
        this.navCtrl = navCtrl;
        this.appProvider = appProvider;
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.persistenceProvider = persistenceProvider;
        this.versionItemTapped = 0;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AboutPage');
        this.commitHash = this.appProvider.info.commitHash;
        this.version = this.appProvider.info.version;
        this.title = this.replaceParametersProvider.replace(this.translate.instant('About {{appName}}'), { appName: this.appProvider.info.nameCase });
    }
    openExternalLink() {
        const url = 'https://github.com/bitpay/' +
            this.appProvider.info.gitHubRepoName +
            '/tree/' +
            this.appProvider.info.commitHash +
            '';
        const optIn = true;
        const title = this.translate.instant('Open GitHub Project');
        const message = this.translate.instant('You can see the latest developments and contribute to this open source app by visiting our project on GitHub.');
        const okText = this.translate.instant('Open GitHub');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openTermsOfUse() {
        const url = 'https://bitpay.com/about/terms#wallet';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('View Wallet Terms of Use');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openPrivacyPolicy() {
        const url = 'https://bitpay.com/about/privacy';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('View Privacy Policy');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openSessionLog() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__session_log_session_log__["a" /* SessionLogPage */]);
    }
    openSendFeedbackPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__feedback_send_feedback_send_feedback__["a" /* SendFeedbackPage */]);
    }
    itemTapped() {
        this.versionItemTapped++;
        if (this.versionItemTapped >= 5) {
            this.versionItemTapped = 0;
            this.persistenceProvider.getHiddenFeaturesFlag().then(res => {
                res === 'enabled'
                    ? this.persistenceProvider.removeHiddenFeaturesFlag()
                    : this.persistenceProvider.setHiddenFeaturesFlag('enabled');
                this.navCtrl.popToRoot();
            });
        }
    }
};
AboutPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-about',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/about/about.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{title}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list class="settings-list bp-list">\n    <ion-item-divider>{{\'Release information\'| translate}}</ion-item-divider>\n    <ion-item class="pointer" (tap)="itemTapped()">\n      <ion-icon class="custom-icon" name="ios-download-outline" item-start></ion-icon>\n      {{\'Version\' | translate}}\n      <ion-note item-end>\n        v{{version}}\n      </ion-note>\n    </ion-item>\n    <ion-item class="pointer" (click)="openExternalLink()">\n      <ion-icon class="custom-icon" name="logo-github" item-start></ion-icon>\n      Commit hash\n      <ion-note item-end>\n        #{{commitHash}}\n      </ion-note>\n    </ion-item>\n    <ion-item-divider class="item-without-title"></ion-item-divider>\n    <button ion-item (click)="openSendFeedbackPage()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-send-feedback.svg" width="22">\n      </ion-icon>\n      <span translate>Send feedback</span>\n    </button>\n    <ion-item-divider class="item-without-title"></ion-item-divider>\n    <button ion-item (click)="openPrivacyPolicy()">\n      <ion-icon class="custom-icon" name="ios-lock-outline" item-start></ion-icon>\n      {{\'Privacy Policy\' | translate }}\n    </button>\n    <button ion-item (click)="openTermsOfUse()">\n      <ion-icon class="custom-icon" name="ios-list-box-outline" item-start></ion-icon>\n      {{\'Terms of Use\' | translate }}\n    </button>\n    <ion-item-divider class="item-without-title"></ion-item-divider>\n    <button ion-item (click)="openSessionLog()">\n      <ion-icon class="custom-icon" name="ios-copy-outline" item-start></ion-icon>\n      {{ \'Session log\' | translate }}\n    </button>\n  </ion-list>\n\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/about/about.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["g" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["N" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["y" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["Y" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["Q" /* PersistenceProvider */]])
], AboutPage);

//# sourceMappingURL=about.js.map

/***/ }),

/***/ 1002:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SessionLogPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_download_download__ = __webpack_require__(462);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_lodash__);




// native

// providers







let SessionLogPage = class SessionLogPage {
    constructor(configProvider, logger, socialSharing, actionSheetCtrl, platformProvider, translate, actionSheetProvider, downloadProvider, appProvider) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.socialSharing = socialSharing;
        this.actionSheetCtrl = actionSheetCtrl;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.actionSheetProvider = actionSheetProvider;
        this.downloadProvider = downloadProvider;
        this.appProvider = appProvider;
        this.config = this.configProvider.get();
        this.isCordova = this.platformProvider.isCordova;
        const logLevels = this.logger.getLevels();
        this.logOptions = __WEBPACK_IMPORTED_MODULE_11_lodash__["keyBy"](logLevels, 'weight');
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SessionLogPage');
    }
    ionViewWillEnter() {
        const selectedLevel = __WEBPACK_IMPORTED_MODULE_11_lodash__["has"](this.config, 'log.weight')
            ? this.logger.getWeight(this.config.log.weight)
            : this.logger.getDefaultWeight();
        this.filterValue = selectedLevel.weight;
        this.setOptionSelected(selectedLevel.weight);
        this.filterLogs(selectedLevel.weight);
    }
    filterLogs(weight) {
        this.filteredLogs = __WEBPACK_IMPORTED_MODULE_11_lodash__["sortBy"](this.logger.get(weight), 'timestamp');
    }
    setOptionSelected(weight) {
        this.filterLogs(weight);
        const opts = {
            log: {
                weight
            }
        };
        this.configProvider.set(opts);
    }
    prepareSessionLogs() {
        let log = 'Session Logs.\nBe careful, this could contain sensitive private data\n\n';
        log += '\n\n';
        const weight = 4; // share complete logs
        const logs = __WEBPACK_IMPORTED_MODULE_11_lodash__["sortBy"](this.logger.get(weight), 'timestamp');
        Object.keys(logs).forEach(key => {
            log +=
                '[' +
                    logs[key].timestamp +
                    '][' +
                    logs[key].level +
                    ']' +
                    logs[key].msg +
                    '\n';
        });
        return log;
    }
    sendLogs() {
        const logs = this.prepareSessionLogs();
        const now = new Date().toISOString();
        const subject = this.appProvider.info.nameCase + '-logs ' + now;
        const message = this.translate.instant('Session Logs. Be careful, this could contain sensitive private data');
        const blob = new Blob([logs], { type: 'text/txt' });
        const reader = new FileReader();
        reader.onload = event => {
            const attachment = event.target.result; // <-- data url
            if (this.platformProvider.isAndroid) {
                this.shareAndroid(message, subject, attachment);
            }
            else {
                this.shareIOS(message, subject, attachment);
            }
        };
        reader.readAsDataURL(blob);
    }
    shareAndroid(message, subject, attachment) {
        // share via email with attachment is not working correctly in some android versions
        // so instead of shareViaEmail() -> share()
        this.socialSharing.share(message, subject, attachment).catch(err => {
            this.logger.error('socialSharing Error: ', err);
        });
    }
    shareIOS(message, subject, attachment) {
        // Check if sharing via email is supported
        this.socialSharing
            .canShareViaEmail()
            .then(() => {
            this.logger.info('sharing via email is possible');
            this.socialSharing
                .shareViaEmail(message, subject, null, // TO: must be null or an array
            null, // CC: must be null or an array
            null, // BCC: must be null or an array
            attachment // FILES: can be null, a string, or an array
            )
                .then(data => {
                this.logger.info('Email created successfully: ', data);
            })
                .catch(err => {
                this.logger.error('socialSharing Error: ', err);
            });
        })
            .catch(() => {
            this.logger.warn('sharing via email is not possible');
            this.socialSharing
                .share(message, subject, attachment // FILES: can be null, a string, or an array
            )
                .catch(err => {
                this.logger.error('socialSharing Error: ', err);
            });
        });
    }
    showOptionsMenu() {
        const downloadText = this.translate.instant('Download logs');
        const shareText = this.translate.instant('Share logs');
        const button = [];
        button.push({
            text: this.isCordova ? shareText : downloadText,
            handler: () => {
                this.showWarningModal();
            }
        });
        const actionSheet = this.actionSheetCtrl.create({
            title: '',
            buttons: button
        });
        actionSheet.present();
    }
    showWarningModal() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('sensitive-info');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option)
                this.isCordova ? this.sendLogs() : this.download();
        });
    }
    download() {
        const logs = this.prepareSessionLogs();
        const now = new Date().toISOString();
        const filename = this.appProvider.info.nameCase + '-logs ' + now + '.txt';
        this.downloadProvider.download(logs, filename);
    }
};
SessionLogPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-session-log',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/about/session-log/session-log.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Session Log\' | translate}}</ion-title>\n    <ion-buttons right>\n      <button (click)="showOptionsMenu()" ion-button icon-only>\n        <ion-icon name="more"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div *ngIf="filteredLogs && filteredLogs.length == 0" class="no-entries-message">\n    <span translate>No entries for this log level</span>.\n  </div>\n  <ion-list>\n    <ion-item class="log-entry">\n      <div *ngIf="filteredLogs && filteredLogs.length > 0">\n        <div *ngFor="let l of filteredLogs">\n          <span [ngClass]="{\'energized\': l.level==\'warn\', \'royal\': l.level==\'debug\', \'info-color\': l.level==\'info\', \'assertive\': l.level==\'error\'}">\n            <span class="log-timestamp">[{{l.timestamp}}]</span>\n            <span class="log-level">[{{l.level}}]</span> {{l.msg}}\n          </span>\n        </div>\n      </div>\n    </ion-item>\n  </ion-list>\n</ion-content>\n<ion-footer>\n  <ion-toolbar>\n    <div class="filter-container">\n      <div class="labels">\n        <div *ngFor="let option of logOptions | keys" [ngClass]="{\'info-label\': option.value.weight==3}">{{option.value.label}}</div>\n      </div>\n      <ion-range min="1" max="4" step="1" snaps="true" color="secondary" [(ngModel)]="filterValue" (ionChange)="setOptionSelected(filterValue)"></ion-range>\n    </div>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/about/session-log/session-log.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["a" /* ActionSheetController */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_download_download__["a" /* DownloadProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */]])
], SessionLogPage);

//# sourceMappingURL=session-log.js.map

/***/ }),

/***/ 1003:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressbookPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__add_add__ = __webpack_require__(333);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__view_view__ = __webpack_require__(1004);








let AddressbookPage = class AddressbookPage {
    constructor(navCtrl, navParams, alertCtrl, logger, addressbookProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.alertCtrl = alertCtrl;
        this.logger = logger;
        this.addressbookProvider = addressbookProvider;
        this.cache = false;
        this.addressbook = [];
        this.filteredAddressbook = [];
        this.initAddressbook();
    }
    ionViewDidEnter() {
        if (this.cache)
            this.initAddressbook();
        this.cache = true;
    }
    initAddressbook() {
        this.addressbookProvider
            .list()
            .then(addressBook => {
            this.isEmptyList = __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](addressBook);
            let contacts = [];
            __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](addressBook, (contact, k) => {
                contacts.push({
                    name: __WEBPACK_IMPORTED_MODULE_3_lodash__["isObject"](contact) ? contact.name : contact,
                    address: k,
                    email: __WEBPACK_IMPORTED_MODULE_3_lodash__["isObject"](contact) ? contact.email : null
                });
            });
            this.addressbook = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](contacts);
            this.filteredAddressbook = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](this.addressbook);
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    addEntry() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__add_add__["a" /* AddressbookAddPage */]);
    }
    viewEntry(contact) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__view_view__["a" /* AddressbookViewPage */], { contact });
    }
    getItems(event) {
        // set val to the value of the searchbar
        let val = event.target.value;
        // if the value is an empty string don't filter the items
        if (val && val.trim() != '') {
            let result = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.addressbook, item => {
                let name = item['name'];
                return __WEBPACK_IMPORTED_MODULE_3_lodash__["includes"](name.toLowerCase(), val.toLowerCase());
            });
            this.filteredAddressbook = result;
        }
        else {
            // Reset items back to all of the items
            this.initAddressbook();
        }
    }
};
AddressbookPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-addressbook',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/addressbook/addressbook.html"*/'<ion-header class="wide-header">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{ \'Address Book\' | translate }}\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n<ion-content #scrollArea>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary>\n          {{ \'Address Book\' | translate }}\n        </expandable-header-primary>\n        <ion-buttons *ngIf="!isEmptyList" end>\n          <button class="add-button" clear (click)="addEntry()">\n            {{\'Add\' | translate}}\n            <ion-icon name="arrow-forward"></ion-icon>\n          </button>\n        </ion-buttons>\n      </ion-toolbar>\n    </expandable-header>\n\n    <search-bar *ngIf="!isEmptyList" [scrollArea]="wideHeaderPage?.scrollArea" (search)="getItems($event)"\n      placeholder="{{\'Search a contact\' | translate}}"></search-bar>\n\n    <div class="zero-state" *ngIf="isEmptyList">\n      <ion-icon class="zero-state-icon">\n        <img class="svg" src="assets/img/address-book-add.svg" />\n      </ion-icon>\n      <div class="zero-state-heading" translate>No contacts yet</div>\n      <div class="zero-state-description" translate>Get started by adding your first one.</div>\n      <button ion-button class="button-standard" (click)="addEntry()">\n        {{\'Add Contact\' | translate}}\n      </button>\n    </div>\n\n    <div *ngIf="!isEmptyList">\n      <ion-list class="settings-list bp-list">\n        <button ion-item *ngFor="let entry of filteredAddressbook | orderBy : [\'name\']" (click)="viewEntry(entry)">\n          <ion-icon item-start>\n            <gravatar [name]="entry.name" [height]="26" [width]="26" [email]="entry.email"></gravatar>\n          </ion-icon>\n          <div class="item-title">{{ entry.name }}</div>\n          <div class="item-subtitle">{{ entry.address }}</div>\n        </button>\n      </ion-list>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/addressbook/addressbook.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["b" /* AlertController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__["a" /* AddressBookProvider */]])
], AddressbookPage);

//# sourceMappingURL=addressbook.js.map

/***/ }),

/***/ 1004:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressbookViewPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pages_send_amount_amount__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_address_book_address_book__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_address_address__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(18);




// Pages

// Providers



let AddressbookViewPage = class AddressbookViewPage {
    constructor(addressBookProvider, addressProvider, navCtrl, navParams, popupProvider, translate) {
        this.addressBookProvider = addressBookProvider;
        this.addressProvider = addressProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.translate = translate;
        this.address = this.navParams.data.contact.address;
        const addrData = this.addressProvider.getCoinAndNetwork(this.address);
        this.coin = addrData.coin;
        this.network = addrData.network;
        this.name = this.navParams.data.contact.name;
        this.email = this.navParams.data.contact.email;
    }
    ionViewDidLoad() { }
    sendTo() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__pages_send_amount_amount__["a" /* AmountPage */], {
            toAddress: this.address,
            name: this.name,
            email: this.email,
            coin: this.coin,
            recipientType: 'contact',
            network: this.network
        });
    }
    remove(addr) {
        const title = this.translate.instant('Warning!');
        const message = this.translate.instant('Are you sure you want to delete this contact?');
        this.popupProvider.ionicConfirm(title, message, null, null).then(res => {
            if (!res)
                return;
            this.addressBookProvider
                .remove(addr)
                .then(() => {
                this.navCtrl.pop();
            })
                .catch(err => {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                return;
            });
        });
    }
};
AddressbookViewPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-addressbook-view',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/addressbook/view/view.html"*/'<ion-header no-border>\n  <ion-navbar>\n    <ion-title>{{ name }}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="contact-view-header">\n    <gravatar [name]="name" [height]="80" [width]="80" [email]="email"></gravatar>\n  </div>\n  <ion-list class="bp-list">\n    <ion-item>\n      {{\'Name\' | translate}}\n      <ion-note item-end>\n        {{ name }}\n      </ion-note>\n    </ion-item>\n    <ion-item *ngIf="email">\n      {{\'Email\' | translate}}\n      <ion-note item-end>\n        {{ email }}\n      </ion-note>\n    </ion-item>\n    <ion-item copy-to-clipboard="{{ address }}">\n      {{\'Address\' | translate}}\n      <div class="comment ellipsis">\n        {{ address }}\n      </div>\n    </ion-item>\n    <ion-item>\n      {{\'Coin\' | translate}}\n      <ion-note item-end>\n        {{ coin | uppercase }}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      {{\'Network\' | translate}}\n      <ion-note item-end>\n        {{ network }}\n      </ion-note>\n    </ion-item>\n    <button ion-item class="btn-send" (click)="sendTo()">\n      {{\'Send Money\' | translate}}\n    </button>\n    <button ion-item class="btn-remove" (click)="remove(address)">\n      {{\'Remove\' | translate}}\n    </button>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/addressbook/view/view.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], AddressbookViewPage);

//# sourceMappingURL=view.js.map

/***/ }),

/***/ 1005:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AdvancedPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__wallet_recover_page_wallet_recover_page__ = __webpack_require__(1006);




// providers


let AdvancedPage = class AdvancedPage {
    constructor(configProvider, profileProvider, navCtrl, logger, appProvider) {
        this.configProvider = configProvider;
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.appProvider = appProvider;
        this.isCopay = this.appProvider.info.name === 'copay';
        this.profileProvider
            .getProfileLegacy()
            .then(oldProfile => {
            this.oldProfileAvailable = oldProfile ? true : false;
            if (!this.oldProfileAvailable)
                return;
            this.wallets = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](oldProfile.credentials, value => {
                return value && (value.mnemonic || value.mnemonicEncrypted);
            });
        })
            .catch(err => {
            this.oldProfileAvailable = false;
            this.logger.info('Error retrieving old profile, ', err);
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AdvancedPage');
    }
    ionViewWillEnter() {
        let config = this.configProvider.get();
        this.spendUnconfirmed = config.wallet.spendUnconfirmed;
    }
    spendUnconfirmedChange() {
        let opts = {
            wallet: {
                spendUnconfirmed: this.spendUnconfirmed
            }
        };
        this.configProvider.set(opts);
    }
    openWalletRecoveryPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__wallet_recover_page_wallet_recover_page__["a" /* WalletRecoverPage */]);
    }
};
AdvancedPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-advanced',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/advanced/advanced.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{ \'Advanced\' | translate }}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list class="settings-list bp-list">\n    <ion-item class="with-label no-border">\n      <ion-label>{{ \'Use Unconfirmed Funds\' | translate }}</ion-label>\n      <ion-toggle [(ngModel)]="spendUnconfirmed" (ionChange)="spendUnconfirmedChange()"></ion-toggle>\n    </ion-item>\n    <label-tip type="info" header="no-header">\n      <div label-tip-body>\n        <div translate>\n          If enabled, wallets will also try to spend unconfirmed funds.\n        </div>\n        <div *ngIf="!isCopay" translate>\n          However, unconfirmed funds are not allowed for spending with merchants, BitPay Card loads, or BitPay in-app gift card purchases.\n        </div>\n      </div>\n    </label-tip>\n  </ion-list>\n  <ion-list class="settings-list bp-list">\n    <button ion-item *ngIf="oldProfileAvailable && wallets && wallets[0]" class="with-label no-border" (click)="openWalletRecoveryPage()" translate>\n      Recover old wallets\n    </button>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/advanced/advanced.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers__["q" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["U" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["N" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["g" /* AppProvider */]])
], AdvancedPage);

//# sourceMappingURL=advanced.js.map

/***/ }),

/***/ 1006:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletRecoverPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__wallet_mnemonic_recover_page_wallet_mnemonic_recover_page__ = __webpack_require__(1007);







let WalletRecoverPage = class WalletRecoverPage {
    constructor(profileProvider, navCtrl, logger) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.logger = logger;
    }
    ionViewWillEnter() {
        this.profileProvider.getProfileLegacy().then(oldProfile => {
            if (!oldProfile)
                return;
            this.logger.debug(`Legacy profile exist. Typeof: ${typeof oldProfile}`);
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](oldProfile)) {
                oldProfile = JSON.parse(oldProfile);
            }
            this.wallets = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](oldProfile.credentials, value => {
                return value && (value.mnemonic || value.mnemonicEncrypted);
            });
            this.logger.debug(`${this.wallets.length} wallets with mnemonics found in legacy profile`);
        });
    }
    openWalletMnemonicRecoverPage(name, credential) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__wallet_mnemonic_recover_page_wallet_mnemonic_recover_page__["a" /* WalletMnemonicRecoverPage */], { name, credential });
    }
};
WalletRecoverPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'wallet-recover-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/advanced/wallet-recover-page/wallet-recover-page.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Old Wallet Recovery Tool</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list class="settings-list bp-list">\n    <button ion-item *ngFor="let wallet of wallets" (click)="openWalletMnemonicRecoverPage(wallet.walletName, wallet)">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/currencies/{{wallet.coin}}.svg" [ngClass]="{ testnet: wallet.network === \'testnet\' }" class="icon-wallet" />\n      </ion-icon>\n      <ion-label>\n        {{wallet.walletName}}\n      </ion-label>\n    </button>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/advanced/wallet-recover-page/wallet-recover-page.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */]])
], WalletRecoverPage);

//# sourceMappingURL=wallet-recover-page.js.map

/***/ }),

/***/ 1007:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletMnemonicRecoverPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(18);









let WalletMnemonicRecoverPage = class WalletMnemonicRecoverPage {
    constructor(logger, navParams, form, popupProvider, translate, bwcProvider, actionSheetProvider) {
        this.logger = logger;
        this.navParams = navParams;
        this.form = form;
        this.popupProvider = popupProvider;
        this.translate = translate;
        this.bwcProvider = bwcProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.mnemonicPhrase = '';
        this.mnemonicEncrypted =
            this.navParams.data.credential.mnemonic === undefined;
        if (!this.mnemonicEncrypted) {
            this.mnemonicPhrase = this.navParams.data.credential.mnemonic;
        }
        this.title = this.navParams.data.name;
        this.passwordForm = this.form.group({
            encryptPassword: [null]
        });
    }
    decryptMnemonic() {
        if (!this.passwordForm.valid) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('There is an error in the form');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        else {
            this._decryptMnemonic(this.passwordForm.value.encryptPassword, this.navParams.data.credential);
        }
    }
    _decryptMnemonic(password, credential) {
        let mnemonic = '';
        if (!credential.xPrivKeyEncrypted)
            throw new Error('Private key is not encrypted');
        try {
            if (credential.mnemonicEncrypted) {
                mnemonic = this.bwcProvider
                    .getSJCL()
                    .decrypt(password, credential.mnemonicEncrypted);
                this.mnemonicPhrase = mnemonic;
                this.mnemonicEncrypted = false;
            }
        }
        catch (ex) {
            this.showErrorInfoSheet('Could Not Decrypt', 'Error');
        }
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.error('Could not get keys:', err);
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: err, title: infoSheetTitle });
        errorInfoSheet.present();
    }
};
WalletMnemonicRecoverPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'wallet-mnemonic-recover-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/advanced/wallet-recover-page/wallet-mnemonic-recover-page/wallet-mnemonic-recover-page.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{ title }}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="container">\n    <label-tip class="no-arrowhead" type="warn" margin-top>\n      <span label-tip-title>Mnemonic Recovery Warning</span>\n      <div label-tip-body>\n        <span>\n          It\'s recommended that you write down your recovery phrase and store it\n          securely so that your wallet can be recovered in the case your device\n          was lost or stolen.</span>\n      </div>\n    </label-tip>\n\n    <form class="form-container" [formGroup]="passwordForm" *ngIf="mnemonicEncrypted">\n      <ion-item>\n        <ion-label floating>Password</ion-label>\n        <ion-input type="password" formControlName="encryptPassword">\n          Enter Encrypt Password\n        </ion-input>\n      </ion-item>\n      <button class="decrypt-button" (click)="decryptMnemonic()">Enter</button>\n    </form>\n\n    <div class="mnemonic-phrase-container" *ngIf="!mnemonicEncrypted">\n      <div class="mnemonic-word-container">{{ mnemonicPhrase }}</div>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/advanced/wallet-recover-page/wallet-mnemonic-recover-page/wallet-mnemonic-recover-page.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */]])
], WalletMnemonicRecoverPage);

//# sourceMappingURL=wallet-mnemonic-recover-page.js.map

/***/ }),

/***/ 1008:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AltCurrencyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_rate_rate__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash__);




// Providers






let AltCurrencyPage = class AltCurrencyPage {
    constructor(configProvider, logger, navCtrl, rate, profileProvider, persistenceProvider, walletProvider) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.rate = rate;
        this.profileProvider = profileProvider;
        this.persistenceProvider = persistenceProvider;
        this.walletProvider = walletProvider;
        this.PAGE_COUNTER = 3;
        this.SHOW_LIMIT = 10;
        this.completeAlternativeList = [];
        this.altCurrencyList = [];
        this.unusedCurrencyList = [
            {
                isoCode: 'LTL'
            },
            {
                isoCode: 'BTC'
            }
        ];
    }
    ionViewWillEnter() {
        this.rate
            .whenRatesAvailable('btc')
            .then(() => {
            this.completeAlternativeList = this.rate.listAlternatives(true);
            let idx = __WEBPACK_IMPORTED_MODULE_9_lodash__["keyBy"](this.unusedCurrencyList, 'isoCode');
            let idx2 = __WEBPACK_IMPORTED_MODULE_9_lodash__["keyBy"](this.lastUsedAltCurrencyList, 'isoCode');
            this.completeAlternativeList = __WEBPACK_IMPORTED_MODULE_9_lodash__["reject"](this.completeAlternativeList, c => {
                return idx[c.isoCode] || idx2[c.isoCode];
            });
            this.altCurrencyList = this.completeAlternativeList.slice(0, 20);
        })
            .catch(err => {
            this.logger.error(err);
        });
        let config = this.configProvider.get();
        this.currentCurrency = config.wallet.settings.alternativeIsoCode;
        this.persistenceProvider
            .getLastCurrencyUsed()
            .then(lastUsedAltCurrency => {
            this.lastUsedAltCurrencyList = lastUsedAltCurrency
                ? lastUsedAltCurrency
                : [];
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    loadAltCurrencies(loading) {
        if (this.altCurrencyList.length === this.completeAlternativeList.length) {
            loading.complete();
            return;
        }
        setTimeout(() => {
            this.altCurrencyList = this.completeAlternativeList.slice(0, this.PAGE_COUNTER * this.SHOW_LIMIT);
            this.PAGE_COUNTER++;
            loading.complete();
        }, 300);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AltCurrencyPage');
    }
    save(newAltCurrency) {
        var opts = {
            wallet: {
                settings: {
                    alternativeName: newAltCurrency.name,
                    alternativeIsoCode: newAltCurrency.isoCode
                }
            }
        };
        this.configProvider.set(opts);
        this.saveLastUsed(newAltCurrency);
        const opts2 = {
            showHidden: true
        };
        this.walletProvider.updateRemotePreferences(this.profileProvider.getWallets(opts2));
        this.navCtrl.pop();
    }
    saveLastUsed(newAltCurrency) {
        this.lastUsedAltCurrencyList.unshift(newAltCurrency);
        this.lastUsedAltCurrencyList = __WEBPACK_IMPORTED_MODULE_9_lodash__["uniqBy"](this.lastUsedAltCurrencyList, 'isoCode');
        this.lastUsedAltCurrencyList = this.lastUsedAltCurrencyList.slice(0, 3);
        this.persistenceProvider
            .setLastCurrencyUsed(JSON.stringify(this.lastUsedAltCurrencyList))
            .then(() => { });
    }
    findCurrency(searchedAltCurrency) {
        this.altCurrencyList = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](this.completeAlternativeList, item => {
            var val = item.name;
            var val2 = item.isoCode;
            return (__WEBPACK_IMPORTED_MODULE_9_lodash__["includes"](val.toLowerCase(), searchedAltCurrency.toLowerCase()) ||
                __WEBPACK_IMPORTED_MODULE_9_lodash__["includes"](val2.toLowerCase(), searchedAltCurrency.toLowerCase()));
        });
    }
};
AltCurrencyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-alt-currency',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/alt-currency/alt-currency.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Alternative currency\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-searchbar placeholder="{{\'Search your currency\' | translate}}" [(ngModel)]="searchedAltCurrency" (ngModelChange)="findCurrency(searchedAltCurrency)"></ion-searchbar>\n  <ion-list class="settings-list bp-list">\n    <ion-item *ngFor="let lastUsedAltCurrency of lastUsedAltCurrencyList" (click)="save(lastUsedAltCurrency)">\n      {{ lastUsedAltCurrency.name }}\n      <span item-end>{{lastUsedAltCurrency.isoCode}}</span>\n    </ion-item>\n  </ion-list>\n  <div *ngIf="altCurrencyList[0] && lastUsedAltCurrencyList[0]" padding></div>\n  <ion-list class="settings-list bp-list">\n    <ion-item *ngFor="let alt of altCurrencyList" (click)="save(alt)">\n      {{ alt.name }}\n      <ion-note item-end>{{alt.isoCode}}</ion-note>\n    </ion-item>\n  </ion-list>\n\n  <ion-spinner class="loading" *ngIf="!altCurrencyList[0]" name="crescent"></ion-spinner>\n\n  <ion-infinite-scroll (ionInfinite)="loadAltCurrencies($event)">\n    <ion-infinite-scroll-content></ion-infinite-scroll-content>\n  </ion-infinite-scroll>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/alt-currency/alt-currency.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_wallet_wallet__["a" /* WalletProvider */]])
], AltCurrencyPage);

//# sourceMappingURL=alt-currency.js.map

/***/ }),

/***/ 1009:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeePolicyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_fee_fee__ = __webpack_require__(114);




// Providers


const COIN = 'btc';
const NETWORK = 'livenet';
let FeePolicyPage = class FeePolicyPage {
    constructor(logger, feeProvider, configProvider) {
        this.logger = logger;
        this.feeProvider = feeProvider;
        this.configProvider = configProvider;
        this.feeOpts = this.feeProvider.getFeeOpts();
        delete this.feeOpts['custom']; // Remove custom level
        this.currentFeeLevel = this.feeProvider.getCurrentFeeLevel();
    }
    ionViewDidEnter() {
        this.error = null;
        return this.feeProvider
            .getFeeLevels(COIN)
            .then(data => {
            this.feeLevels = data['levels'];
            this.updateCurrentValues();
        })
            .catch(err => {
            this.logger.error(err);
            this.error = err;
        });
    }
    save() {
        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.currentFeeLevel) ||
            this.currentFeeLevel == this.feeProvider.getCurrentFeeLevel())
            return;
        this.logger.debug('New fee level: ' + this.currentFeeLevel);
        this.updateCurrentValues();
        this.setFee();
    }
    updateCurrentValues() {
        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.feeLevels) || __WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.currentFeeLevel))
            return;
        let value = __WEBPACK_IMPORTED_MODULE_2_lodash__["find"](this.feeLevels[NETWORK], {
            level: this.currentFeeLevel
        });
        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](value))
            return;
        this.feePerSatByte = (value['feePerKb'] / 1000).toFixed();
        this.avgConfirmationTime = value['nbBlocks'] * 10;
    }
    setFee() {
        let opts = {
            wallet: {
                settings: {
                    feeLevel: this.currentFeeLevel
                }
            }
        };
        this.configProvider.set(opts);
    }
};
FeePolicyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-fee-policy',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/fee-policy/fee-policy.html"*/'<ion-header>\n\n  <ion-navbar>\n    <ion-title>\n      {{\'Bitcoin Network Fee Policy\'|translate}}\n    </ion-title>\n  </ion-navbar>\n\n</ion-header>\n\n\n<ion-content>\n\n  <div class="explanation" padding>\n    <div class="heading" translate>Bitcoin transactions include a fee collected by miners on the network.</div>\n    <div class="description" translate>The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.</div>\n    <div class="estimates">\n      <div>\n        <span translate>Average confirmation time</span>:\n        <span class="fee-minutes" *ngIf="avgConfirmationTime">{{avgConfirmationTime | amDuration: \'minute\'}}</span>\n        <span class="fee-minutes" *ngIf="!avgConfirmationTime && !error">...</span>\n        <span class="fee-minutes error" *ngIf="!avgConfirmationTime && error" translate>Error</span>\n      </div>\n      <div>\n        <span translate>Current fee rate for this policy</span>:\n        <span class="fee-rate" *ngIf="feePerSatByte">{{feePerSatByte}} satoshis/byte</span>\n        <span class="fee-rate" *ngIf="!feePerSatByte && !error">...</span>\n        <span class="fee-rate error" *ngIf="!feePerSatByte && error" translate>Error</span>\n      </div>\n    </div>\n  </div>\n\n  <ion-list radio-group [(ngModel)]="currentFeeLevel" (ionChange)="save()" class="settings-list bp-list">\n    <ion-item *ngFor="let data of feeOpts | keys">\n      <ion-label>{{data.value}}</ion-label>\n      <ion-radio [value]="data.key"></ion-radio>\n    </ion-item>\n  </ion-list>\n\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/fee-policy/fee-policy.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */]])
], FeePolicyPage);

//# sourceMappingURL=fee-policy.js.map

/***/ }),

/***/ 101:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReplaceParametersProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/*
 * Example of use:
 * let message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountBelowFeeStr}} {{coin}} were excluded. These funds come from UTXOs smaller than the network fee provided.'), { amountBelowFeeStr: amountBelowFeeStr, coin: this.tx.coin.toUpperCase() });
 */



let ReplaceParametersProvider = class ReplaceParametersProvider {
    constructor() { }
    replace(stringToReplace, params) {
        let processedParams = [];
        for (let key in params) {
            processedParams.push({ key, value: params[key] });
        }
        processedParams.forEach(param => {
            stringToReplace = __WEBPACK_IMPORTED_MODULE_2_lodash__["replace"](stringToReplace, new RegExp('{{' + param.key + '}}', 'g'), param.value);
            stringToReplace = __WEBPACK_IMPORTED_MODULE_2_lodash__["replace"](stringToReplace, new RegExp('{{ ' + param.key + ' }}', 'g'), param.value);
        });
        return stringToReplace;
    }
};
ReplaceParametersProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [])
], ReplaceParametersProvider);

//# sourceMappingURL=replace-parameters.js.map

/***/ }),

/***/ 1010:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LanguagePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_language_language__ = __webpack_require__(244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_wallet_wallet__ = __webpack_require__(32);




// providers




let LanguagePage = class LanguagePage {
    constructor(navCtrl, languageProvider, externalLinkProvider, profileProvider, walletProvider, translate) {
        this.navCtrl = navCtrl;
        this.languageProvider = languageProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.currentLanguage = this.languageProvider.getCurrent();
        this.languages = this.languageProvider.getAvailables();
    }
    openExternalLink() {
        let url = 'https://crowdin.com/project/copay';
        let optIn = true;
        let title = this.translate.instant('Open Translation Community');
        let message = this.translate.instant('You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!');
        let okText = this.translate.instant('Open Crowdin');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    save(newLang) {
        this.languageProvider.set(newLang);
        this.navCtrl.pop();
        setTimeout(() => {
            const opts = {
                showHidden: true
            };
            let wallets = this.profileProvider.getWallets(opts);
            this.walletProvider.updateRemotePreferences(wallets);
        }, 1000);
    }
};
LanguagePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-language',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/language/language.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Language\'|translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list radio-group [(ngModel)]="currentLanguage" class="settings-list bp-list">\n    <ion-item *ngFor="let language of languages">\n      <ion-label>\n        {{ language.name }}\n      </ion-label>\n      <ion-radio (click)="save(language.isoCode)" [value]="language.isoCode"></ion-radio>\n    </ion-item>\n    <div class="explanation">\n      <div translate>\n        We are always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.\n      </div>\n      <div translate>\n        Don\'t see your language on Crowdin? Contact the Owner on Crowdin! We\'d love to support your language.\n      </div>\n    </div>\n  </ion-list>\n\n  <button ion-button class="button-standard" (click)="openExternalLink()">\n    {{\'Contribute translations\' | translate}}\n  </button>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/language/language.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], LanguagePage);

//# sourceMappingURL=language.js.map

/***/ }),

/***/ 1011:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LockPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pin_pin_modal_pin_modal__ = __webpack_require__(332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_touchid_touchid__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash__);




// pages

// providers




let LockPage = class LockPage {
    constructor(configProvider, modalCtrl, touchIdProvider, profileProvider, translate) {
        this.configProvider = configProvider;
        this.modalCtrl = modalCtrl;
        this.touchIdProvider = touchIdProvider;
        this.profileProvider = profileProvider;
        this.translate = translate;
        this.options = [];
        this.checkLockOptions();
    }
    checkLockOptions() {
        this.lockOptions = this.configProvider.get().lock;
        this.touchIdProvider.isAvailable().then((isAvailable) => {
            let needsBackup = this.needsBackup();
            this.options = [
                {
                    label: this.translate.instant('Disabled'),
                    method: 'disabled',
                    enabled: !this.lockOptions.method ||
                        (this.lockOptions.method &&
                            this.lockOptions.method.toLowerCase() == 'disabled'
                            ? true
                            : false),
                    disabled: false
                },
                {
                    label: this.translate.instant('PIN'),
                    method: 'pin',
                    enabled: this.lockOptions.method &&
                        this.lockOptions.method.toLowerCase() == 'pin'
                        ? true
                        : false,
                    disabled: needsBackup
                },
                {
                    label: this.translate.instant('Biometric'),
                    method: 'fingerprint',
                    enabled: this.lockOptions.method &&
                        this.lockOptions.method.toLowerCase() == 'fingerprint'
                        ? true
                        : false,
                    disabled: !isAvailable || needsBackup
                }
            ];
        });
    }
    select(method) {
        switch (method) {
            case 'disabled':
                this.removeLockMethod();
                break;
            case 'pin':
                this.openPinModal('pinSetUp');
                break;
            case 'fingerprint':
                this.lockByFingerprint();
                break;
        }
    }
    removeLockMethod() {
        let lock = { method: 'disabled', value: null, bannedUntil: null };
        this.configProvider.set({ lock });
        this.checkLockOptions();
    }
    openPinModal(action) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_4__pin_pin_modal_pin_modal__["a" /* PinModalPage */], { action }, { cssClass: 'fullscreen-modal' });
        modal.present();
        modal.onDidDismiss(() => {
            this.checkLockOptions();
        });
    }
    lockByFingerprint() {
        let lock = { method: 'fingerprint', value: null, bannedUntil: null };
        this.configProvider.set({ lock });
        this.checkLockOptions();
    }
    needsBackup() {
        let wallets = this.profileProvider.getWallets();
        let singleLivenetWallet = wallets.length == 1 &&
            wallets[0].network == 'livenet' &&
            wallets[0].needsBackup;
        let atLeastOneLivenetWallet = __WEBPACK_IMPORTED_MODULE_8_lodash__["find"](wallets, w => {
            return w.network == 'livenet' && w.needsBackup;
        });
        if (singleLivenetWallet) {
            this.needsBackupMsg = this.translate.instant('Back up your wallet before using this function');
            return true;
        }
        else if (atLeastOneLivenetWallet) {
            this.needsBackupMsg = this.translate.instant('Back up all your wallets before using this function');
            return true;
        }
        else {
            this.needsBackupMsg = null;
            return false;
        }
    }
};
LockPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-lock',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/lock/lock.html"*/'<ion-header>\n\n  <ion-navbar>\n    <ion-title>{{\'Lock\'|translate}}</ion-title>\n  </ion-navbar>\n\n</ion-header>\n\n<ion-content>\n  <ion-list radio-group>\n    <ion-item *ngFor="let opt of options">\n      <ion-label>{{opt.label}}</ion-label>\n      <ion-radio (click)="select(opt.method)" value="{{opt.method}}" checked="{{opt.enabled}}" disabled="{{opt.disabled}}"></ion-radio>\n    </ion-item>\n  </ion-list>\n\n  <div *ngIf="needsBackupMsg" class="msg-container" text-wrap>\n    <span class="assertive">{{needsBackupMsg}}</span>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/lock/lock.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_touchid_touchid__["a" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], LockPage);

//# sourceMappingURL=lock.js.map

/***/ }),

/***/ 1012:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NotificationsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_email_notifications_email_notifications__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_push_notifications_push_notifications__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__validators_email__ = __webpack_require__(1988);






// providers







// validators

let NotificationsPage = class NotificationsPage {
    constructor(navCtrl, formBuilder, configProvider, appProvider, platformProvider, pushProvider, emailProvider, externalLinkProvider, logger, persistenceProvider, translate) {
        this.navCtrl = navCtrl;
        this.formBuilder = formBuilder;
        this.configProvider = configProvider;
        this.appProvider = appProvider;
        this.platformProvider = platformProvider;
        this.pushProvider = pushProvider;
        this.emailProvider = emailProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.emailForm = this.formBuilder.group({
            email: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].compose([
                    __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required,
                    new __WEBPACK_IMPORTED_MODULE_13__validators_email__["a" /* EmailValidator */](configProvider, emailProvider).isValid
                ])
            ]
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: NotificationsPage');
        this.updateConfig();
    }
    updateConfig() {
        const config = this.configProvider.get();
        this.appName = this.appProvider.info.nameCase;
        this.usePushNotifications = this.platformProvider.isCordova;
        this.isIOSApp =
            this.platformProvider.isIOS && this.platformProvider.isCordova;
        this.isElectron = this.platformProvider.isElectron;
        this.pushNotifications = config.pushNotificationsEnabled;
        this.desktopNotifications = config.desktopNotificationsEnabled;
        this.confirmedTxsNotifications = config.confirmedTxsNotifications
            ? config.confirmedTxsNotifications.enabled
            : false;
        this.productsUpdates = config.productsUpdates
            ? config.productsUpdates.enabled
            : false;
        this.offersAndPromotions = config.offersAndPromotions
            ? config.offersAndPromotions.enabled
            : false;
        this.emailForm.setValue({
            email: this.emailProvider.getEmailIfEnabled(config) || ''
        });
        this.emailNotifications = config.emailNotifications
            ? config.emailNotifications.enabled
            : false;
    }
    pushNotificationsChange() {
        const opts = {
            pushNotificationsEnabled: this.pushNotifications
        };
        this.configProvider.set(opts);
        if (opts.pushNotificationsEnabled)
            this.pushProvider.init();
        else
            this.pushProvider.disable();
    }
    desktopNotificationChange() {
        const opts = {
            desktopNotificationsEnabled: this.desktopNotifications
        };
        this.configProvider.set(opts);
    }
    confirmedTxsNotificationsChange() {
        const opts = {
            confirmedTxsNotifications: {
                enabled: this.confirmedTxsNotifications
            }
        };
        this.configProvider.set(opts);
    }
    productsUpdatesChange() {
        const opts = {
            productsUpdates: {
                enabled: this.productsUpdates
            }
        };
        this.configProvider.set(opts);
        this.updateTopic(this.productsUpdates, 'productsupdates');
    }
    offersAndPromotionsChange() {
        const opts = {
            offersAndPromotions: {
                enabled: this.offersAndPromotions
            }
        };
        this.configProvider.set(opts);
        this.updateTopic(this.offersAndPromotions, 'offersandpromotions');
    }
    updateTopic(enabled, topic) {
        if (enabled)
            this.pushProvider.subscribeToTopic(topic);
        else
            this.pushProvider.unsubscribeFromTopic(topic);
    }
    emailNotificationsChange() {
        const opts = {
            enabled: this.emailNotifications,
            email: this.emailForm.value.email
        };
        this.emailProvider.updateEmail(opts);
    }
    saveEmail() {
        this.persistenceProvider.setEmailLawCompliance('accepted');
        this.emailProvider.updateEmail({
            enabled: this.emailNotifications,
            email: this.emailForm.value.email
        });
        this.navCtrl.pop();
    }
    openPrivacyPolicy() {
        const url = 'https://bitpay.com/about/privacy';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('View Privacy Policy');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
NotificationsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-notifications',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/notifications/notifications.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Notifications\' | translate}}</ion-title>\n  </ion-navbar>\n\n</ion-header>\n\n\n<ion-content>\n  <ion-list class="settings-list bp-list">\n    <div *ngIf="usePushNotifications">\n      <ion-item>\n        <ion-label>{{ \'Enable push notifications\' | translate }}</ion-label>\n        <ion-toggle [(ngModel)]="pushNotifications" (ionChange)="pushNotificationsChange()"></ion-toggle>\n      </ion-item>\n    </div>\n\n    <ion-item-divider *ngIf="!usePushNotifications && isIOSApp">\n      <span translate>\n        Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.\n      </span>\n    </ion-item-divider>\n\n\n    <div *ngIf="isElectron">\n      <ion-item>\n        <ion-label>{{ \'Enable desktop notifications\' | translate }}</ion-label>\n        <ion-toggle [(ngModel)]="desktopNotifications" (ionChange)="desktopNotificationChange()"></ion-toggle>\n      </ion-item>\n    </div>\n\n    <ion-item [ngClass]="{\'with-label\': emailNotifications}" class="no-border">\n      <ion-label>{{ \'Enable email notifications\' | translate }}</ion-label>\n      <ion-toggle [(ngModel)]="emailNotifications" (ionChange)="emailNotificationsChange()"></ion-toggle>\n    </ion-item>\n\n    <label-tip *ngIf="emailNotifications" type="info" header="no-header">\n      <div label-tip-body translate>\n        By providing your email address, you give explicit consent to BitPay to use your email address to send you email notifications about payments.\n        <br>\n        <a (click)="openPrivacyPolicy()" translate>View Privacy Policy</a>\n      </div>\n    </label-tip>\n\n    <form *ngIf="emailNotifications" [formGroup]="emailForm">\n      <ion-item>\n        <ion-label stacked>{{ \'Email\' | translate }}</ion-label>\n        <ion-input formControlName="email" type="email"></ion-input>\n      </ion-item>\n      <div text-center>\n        <button ion-button class="button-standard" (click)="saveEmail()" [disabled]="emailForm.invalid">\n          {{\'Save\' | translate}}\n        </button>\n      </div>\n    </form>\n\n    <ion-item-divider *ngIf="usePushNotifications && pushNotifications">\n      {{\'Notifications Preferences\' | translate}}\n    </ion-item-divider>\n\n    <div *ngIf="usePushNotifications && pushNotifications">\n      <ion-item>\n        <ion-label>{{ \'Confirmed transactions\' | translate }}</ion-label>\n        <ion-toggle [(ngModel)]="confirmedTxsNotifications" (ionChange)="confirmedTxsNotificationsChange()"></ion-toggle>\n      </ion-item>\n      <ion-item>\n        <ion-label>{{ \'Product updates\' | translate }}</ion-label>\n        <ion-toggle [(ngModel)]="productsUpdates" (ionChange)="productsUpdatesChange()"></ion-toggle>\n      </ion-item>\n      <ion-item>\n        <ion-label>{{ \'Offers & promotions\' | translate }}</ion-label>\n        <ion-toggle [(ngModel)]="offersAndPromotions" (ionChange)="offersAndPromotionsChange()"></ion-toggle>\n      </ion-item>\n    </div>\n\n  </ion-list>\n\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/notifications/notifications.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], NotificationsPage);

//# sourceMappingURL=notifications.js.map

/***/ }),

/***/ 1013:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SharePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_analytics_analytics__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_replace_parameters_replace_parameters__ = __webpack_require__(101);




// native

// providers





let SharePage = class SharePage {
    constructor(logger, socialSharing, appProvider, configProvider, replaceParametersProvider, translate, popupProvider, analyticsProvider) {
        this.logger = logger;
        this.socialSharing = socialSharing;
        this.appProvider = appProvider;
        this.configProvider = configProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.popupProvider = popupProvider;
        this.analyticsProvider = analyticsProvider;
        this.title = this.replaceParametersProvider.replace(this.translate.instant('Share {{appName}}'), { appName: this.appProvider.info.nameCase });
        let defaults = this.configProvider.getDefaults();
        this.downloadUrl =
            this.appProvider.info.name == 'copay'
                ? defaults.download.copay.url
                : defaults.download.bitpay.url;
    }
    ionViewWillEnter() {
        this.socialSharing
            .canShareVia('com.apple.social.facebook', 'msg', null, null, null)
            .then(() => {
            this.shareFacebookVia = 'com.apple.social.facebook';
            this.facebook = true;
        })
            .catch(() => {
            this.socialSharing
                .canShareVia('com.facebook.katana', 'msg', null, null, null)
                .then(() => {
                this.shareFacebookVia = 'com.facebook.katana';
                this.facebook = true;
            })
                .catch(e => {
                this.logger.error('facebook error: ' + e);
                this.facebook = false;
            });
        });
        this.socialSharing
            .canShareVia('com.apple.social.twitter', 'msg', null, null, null)
            .then(() => {
            this.shareTwitterVia = 'com.apple.social.twitter';
            this.twitter = true;
        })
            .catch(() => {
            this.socialSharing
                .canShareVia('com.twitter.android', 'msg', null, null, null)
                .then(() => {
                this.shareTwitterVia = 'com.twitter.android';
                this.twitter = true;
            })
                .catch(e => {
                this.logger.error('twitter error: ' + e);
                this.twitter = false;
            });
        });
        this.socialSharing
            .canShareVia('whatsapp', 'msg', null, null, null)
            .then(() => {
            this.whatsapp = true;
        })
            .catch(e => {
            this.logger.error('whatsapp error: ' + e);
            this.whatsapp = false;
        });
    }
    shareFacebook() {
        this.analyticsProvider.logEvent('share', { method: 'Facebook' });
        if (!this.facebook) {
            this.showError();
            return;
        }
        this.socialSharing.shareVia(this.shareFacebookVia, null, null, null, this.downloadUrl);
    }
    shareTwitter() {
        this.analyticsProvider.logEvent('share', { method: 'Twitter' });
        if (!this.twitter) {
            this.showError();
            return;
        }
        this.socialSharing.shareVia(this.shareTwitterVia, null, null, null, this.downloadUrl);
    }
    shareWhatsapp() {
        this.analyticsProvider.logEvent('share', { method: 'Whatsapp' });
        if (!this.whatsapp) {
            this.showError();
            return;
        }
        this.socialSharing.shareViaWhatsApp(this.downloadUrl);
    }
    showError() {
        let msg = this.translate.instant('This app is not available for your device.');
        this.popupProvider.ionicAlert(this.translate.instant('Error'), msg);
    }
};
SharePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-share',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/share/share.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{title}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <div class="share-image-container">\n    <div>\n      <div class="share-the-love">\n        <img src="assets/img/ico-positive-feedback.svg" class="share-the-love-illustration" />\n      </div>\n      <div class="subtitle" translate>Share the love by inviting your friends.</div>\n    </div>\n  </div>\n  <div class="share-buttons">\n    <div class="share-buttons__action" (click)="shareFacebook()">\n      <ion-icon>\n        <img src="assets/img/social-icons/ico-social-facebook.svg" />\n      </ion-icon>\n      <div class="name">Facebook</div>\n    </div>\n    <div class="share-buttons__action" (click)="shareTwitter()">\n      <ion-icon>\n        <img src="assets/img/social-icons/ico-social-twitter.svg" />\n      </ion-icon>\n      <div class="name">Twitter</div>\n    </div>\n    <div class="share-buttons__action" (click)="shareWhatsapp()">\n      <ion-icon>\n        <img src="assets/img/social-icons/ico-social-whatsapp.svg" />\n      </ion-icon>\n      <div class="name">Whatsapp</div>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/share/share.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_analytics_analytics__["a" /* AnalyticsProvider */]])
], SharePage);

//# sourceMappingURL=share.js.map

/***/ }),

/***/ 1014:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletGroupSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__add_add__ = __webpack_require__(324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__backup_backup_key_backup_key__ = __webpack_require__(334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__wallet_group_settings_wallet_group_name_wallet_group_name__ = __webpack_require__(1016);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__wallet_group_settings_wallet_group_onboarding_wallet_group_onboarding__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wallet_settings_wallet_settings__ = __webpack_require__(471);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__wallet_settings_wallet_settings_advanced_wallet_export_wallet_export__ = __webpack_require__(473);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__wallet_group_delete_wallet_group_delete__ = __webpack_require__(1024);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__wallet_group_extended_private_key_wallet_group_extended_private_key__ = __webpack_require__(1025);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__wallet_group_qr_export_wallet_group_qr_export__ = __webpack_require__(1026);





// providers







// pages









let WalletGroupSettingsPage = class WalletGroupSettingsPage {
    constructor(profileProvider, logger, walletProvider, actionSheetProvider, navCtrl, navParams, externalLinkProvider, translate, keyProvider, derivationPathHelperProvider, modalCtrl) {
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.externalLinkProvider = externalLinkProvider;
        this.translate = translate;
        this.keyProvider = keyProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.modalCtrl = modalCtrl;
        this.deleted = false;
        this.logger.info('Loaded:  WalletGroupSettingsPage');
        this.keyId = this.navParams.data.keyId;
        this.showReorder = false;
    }
    ionViewWillEnter() {
        this.walletsGroup = this.profileProvider.getWalletGroup(this.keyId);
        this.wallets = this.profileProvider.getWalletsFromGroup({
            keyId: this.keyId,
            showHidden: true
        });
        this.canSign = this.walletsGroup.canSign;
        this.isDeletedSeed = this.walletsGroup.isDeletedSeed;
        this.needsBackup = this.walletsGroup.needsBackup;
        this.encryptEnabled = this.walletsGroup.isPrivKeyEncrypted;
    }
    touchIdChange() {
        if (this.touchIdPrevValue == this.touchIdEnabled)
            return;
        const newStatus = this.touchIdEnabled;
        this.walletProvider
            .setTouchId(this.wallets, newStatus)
            .then(() => {
            this.touchIdPrevValue = this.touchIdEnabled;
            this.logger.debug('Touch Id status changed: ' + newStatus);
        })
            .catch(err => {
            this.logger.error('Error with fingerprint:', err);
            this.touchIdEnabled = this.touchIdPrevValue;
        });
    }
    encryptChange() {
        const val = this.encryptEnabled;
        this.profileProvider.removeProfileLegacy();
        if (val && !this.walletsGroup.isPrivKeyEncrypted) {
            this.logger.debug('Encrypting private key for', this.walletsGroup.name);
            this.keyProvider
                .encrypt(this.keyId)
                .then(() => {
                const key = this.keyProvider.getKey(this.keyId);
                this.keyProvider.addKey(key);
                this.profileProvider.walletsGroups[this.keyId].isPrivKeyEncrypted = true;
                this.logger.debug('Key encrypted');
            })
                .catch(err => {
                this.encryptEnabled = false;
                const title = this.translate.instant('Could not encrypt wallet');
                this.showErrorInfoSheet(err, title);
            });
        }
        else if (!val && this.walletsGroup.isPrivKeyEncrypted) {
            this.keyProvider
                .decrypt(this.keyId)
                .then(() => {
                const key = this.keyProvider.getKey(this.keyId);
                this.keyProvider.addKey(key);
                this.profileProvider.walletsGroups[this.keyId].isPrivKeyEncrypted = false;
                this.logger.debug('Key decrypted');
            })
                .catch(err => {
                this.encryptEnabled = true;
                const title = this.translate.instant('Could not decrypt wallet');
                this.showErrorInfoSheet(err, title);
            });
        }
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.warn('Could not encrypt/decrypt group wallets:', err);
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: err, title: infoSheetTitle });
        errorInfoSheet.present();
    }
    openBackupSettings() {
        const derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(this.wallets[0].credentials.rootPath);
        if (derivationStrategy == 'BIP45') {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__wallet_settings_wallet_settings_advanced_wallet_export_wallet_export__["a" /* WalletExportPage */], {
                walletId: this.wallets[0].credentials.walletId
            });
        }
        else {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__backup_backup_key_backup_key__["a" /* BackupKeyPage */], {
                keyId: this.keyId
            });
        }
    }
    openWalletGroupDelete() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__wallet_group_delete_wallet_group_delete__["a" /* WalletGroupDeletePage */], {
            keyId: this.keyId
        });
    }
    openQrExport() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_20__wallet_group_qr_export_wallet_group_qr_export__["a" /* WalletGroupQrExportPage */], {
            keyId: this.keyId
        });
    }
    openWalletGroupExtendedPrivateKey() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_19__wallet_group_extended_private_key_wallet_group_extended_private_key__["a" /* WalletGroupExtendedPrivateKeyPage */], {
            keyId: this.keyId
        });
    }
    openSupportEncryptPassword() {
        const url = 'https://support.bitpay.com/hc/en-us/articles/360000244506-What-Does-a-Spending-Password-Do-';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Read more in our support page');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openWalletSettings(id) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__wallet_settings_wallet_settings__["a" /* WalletSettingsPage */], { walletId: id });
    }
    reorder() {
        this.showReorder = !this.showReorder;
    }
    reorderAccounts(indexes) {
        const element = this.wallets[indexes.from];
        this.wallets.splice(indexes.from, 1);
        this.wallets.splice(indexes.to, 0, element);
        __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](this.wallets, (wallet, index) => {
            this.profileProvider.setWalletOrder(wallet.id, index);
        });
    }
    goToAddPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__add_add__["a" /* AddPage */], { keyId: this.keyId });
    }
    openWalletGroupName() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_14__wallet_group_settings_wallet_group_name_wallet_group_name__["a" /* WalletGroupNamePage */], {
            keyId: this.keyId
        });
    }
    showKeyOnboardingSlides() {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_15__wallet_group_settings_wallet_group_onboarding_wallet_group_onboarding__["a" /* WalletGroupOnboardingPage */], null, {
            showBackdrop: true,
            enableBackdropDismiss: true
        });
        modal.present();
    }
};
WalletGroupSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-group-settings',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-settings.html"*/'<ion-header class="wide-header">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        <span *ngIf="canSign">{{\'Key Settings\' | translate}}</span>\n        <span *ngIf="!canSign">{{\'Read Only Wallets\' | translate}}</span>\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary>\n          <span *ngIf="canSign">{{\'Key Settings\' | translate}}</span>\n          <span *ngIf="!canSign">{{\'Read Only Wallets\' | translate}}</span>\n          <div class="subtitle-container" *ngIf="wallets && canSign">\n            <div class="subtitle">\n              This key contains {{wallets.length}} wallets.\n            </div>\n            <div class="onboarding-modal" (click)="showKeyOnboardingSlides()">\n              <ion-icon name="md-help-circle"></ion-icon>\n            </div>\n          </div>\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <label-tip class="no-arrowhead" *ngIf="!canSign" type="warn">\n      <span label-tip-title translate>No Private Key</span>\n      <div label-tip-body translate>\n        Read Only wallets don\'t include the private key.\n      </div>\n    </label-tip>\n\n    <ion-list class="settings-list bp-list">\n      <button ion-item (click)="openWalletGroupName()">\n        <div translate float-left>Key Name</div>\n        <ion-note item-end>\n          {{walletsGroup?.name}}\n        </ion-note>\n      </button>\n\n      <ion-item-divider *ngIf="canSign">{{\'Wallets\' | translate}}\n        <button class="reorder-option" ion-button item-end clear *ngIf="!showReorder && wallets?.length > 1" (click)="reorder()">\n          <img src="assets/img/sort.svg">\n        </button>\n        <button class="reorder-option" ion-button item-end clear *ngIf="showReorder" (click)="reorder()">\n          {{\'Done\' | translate}}\n        </button>\n      </ion-item-divider>\n      <ion-list *ngIf="!showReorder" class="settings-list bp-list">\n        <button ion-item *ngFor="let wallet of wallets" (click)="openWalletSettings(wallet.id)">\n          <ion-icon class="item-img settings-icon" item-start>\n            <img src="assets/img/currencies/{{wallet.coin}}.svg" [ngClass]="{ testnet: wallet.network === \'testnet\' }" class="icon-wallet" />\n          </ion-icon>\n          <ion-label>\n            {{wallet.name}}\n          </ion-label>\n          <ion-note *ngIf="wallet.hidden" item-end>\n            {{\'Hidden\'|translate}}\n          </ion-note>\n        </button>\n        <button ion-item detail-none class="create-button" *ngIf="wallets && wallets[0].canAddNewAccount" (click)="goToAddPage()" translate>\n          Create a new wallet\n        </button>\n      </ion-list>\n      <ion-list reorder="{{showReorder}}" (ionItemReorder)="reorderAccounts($event)" *ngIf="showReorder">\n        <button ion-item detail-none *ngFor="let wallet of wallets">\n          <ion-icon class="item-img settings-icon" item-start>\n            <img src="assets/img/currencies/{{wallet.coin}}.svg" [ngClass]="{ testnet: wallet.network === \'testnet\' }" class="icon-wallet" />\n          </ion-icon>\n          <ion-label>\n            {{wallet.name}}\n          </ion-label>\n        </button>\n      </ion-list>\n\n      <ion-item-divider *ngIf="canSign || touchIdAvailable">{{\'Security\' | translate}}</ion-item-divider>\n      <button ion-item *ngIf="canSign" (click)="openBackupSettings()" [ngClass]="{warn: needsBackup}">\n        <span translate>Backup</span>\n        <ion-note *ngIf="needsBackup" class="wallet-warning" item-end>\n          {{\'Needs backup\' | translate}}\n        </ion-note>\n      </button>\n\n      <div *ngIf="canSign && !needsBackup">\n        <ion-item class="with-label no-border">\n          <ion-label>{{\'Request Encrypt Password\' | translate}}</ion-label>\n          <ion-toggle [(ngModel)]="encryptEnabled" (ionChange)="encryptChange()"></ion-toggle>\n        </ion-item>\n        <label-tip type="info" *ngIf="!encryptEnabled">\n          <span label-tip-title translate>Password Not Recoverable</span>\n          <div label-tip-body>\n            <span translate>This password cannot be recovered. If this password is lost, funds can only be recovered by reimporting your 12-word recovery phrase.</span>\n            <br>\n            <a class="label-tip-link" (click)="openSupportEncryptPassword()" translate>Learn More</a>\n          </div>\n        </label-tip>\n      </div>\n\n      <div *ngIf="touchIdAvailable">\n        <ion-item>\n          <ion-label [ngClass]="{\'disabled\': needsBackup}">{{\'Request Fingerprint\'| translate}}</ion-label>\n          <ion-toggle [(ngModel)]="touchIdEnabled" (ionChange)="touchIdChange()"></ion-toggle>\n        </ion-item>\n      </div>\n\n\n      <ion-item-divider *ngIf="canSign">{{\'Advanced\' | translate}}</ion-item-divider>\n\n      <button *ngIf="!needsBackup && canSign && !isDeletedSeed" ion-item (click)="openQrExport()">\n        <span translate>Export Key</span>\n      </button>\n\n      <button *ngIf="!needsBackup && canSign" ion-item (click)="openWalletGroupExtendedPrivateKey()">\n        <span translate>Extended Private Key</span>\n      </button>\n\n      <button *ngIf="canSign" ion-item (click)="openWalletGroupDelete()">\n        <span translate>Delete</span>\n      </button>\n    </ion-list>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */]])
], WalletGroupSettingsPage);

//# sourceMappingURL=wallet-group-settings.js.map

/***/ }),

/***/ 1015:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackupGamePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__finish_finish__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(15);





// pages

// providers





let BackupGamePage = class BackupGamePage {
    constructor(modalCtrl, navCtrl, navParams, logger, profileProvider, bwcProvider, actionSheetProvider, translate, keyProvider) {
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.bwcProvider = bwcProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.translate = translate;
        this.keyProvider = keyProvider;
        this.mnemonicWords = this.navParams.data.words;
        this.keys = this.navParams.data.keys;
        this.keyId = this.navParams.data.keyId;
        this.setFlow();
    }
    ionViewDidLoad() {
        if (this.gameSlides)
            this.gameSlides.lockSwipes(true);
        this.navBar.backButtonClick = () => {
            if (this.customWords.length > 0) {
                this.clear();
            }
            else {
                this.navCtrl.pop();
            }
        };
    }
    shuffledWords(words) {
        const sort = __WEBPACK_IMPORTED_MODULE_4_lodash__["sortBy"](words);
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["map"](sort, w => {
            return {
                word: w,
                selected: false
            };
        });
    }
    addButton(index, item) {
        const newWord = {
            word: item.word,
            prevIndex: index
        };
        this.customWords.push(newWord);
        this.shuffledMnemonicWords[index].selected = true;
        this.shouldContinue();
        setTimeout(() => {
            this.gameSlides.lockSwipes(false);
            this.gameSlides.slideNext();
            this.gameSlides.lockSwipes(true);
        }, 300);
    }
    removeButton(index, item) {
        this.customWords.splice(index, 1);
        this.shuffledMnemonicWords[item.prevIndex].selected = false;
        this.shouldContinue();
        setTimeout(() => {
            this.gameSlides.lockSwipes(false);
            this.gameSlides.slidePrev();
            this.gameSlides.lockSwipes(true);
        }, 300);
    }
    shouldContinue() {
        this.selectComplete =
            this.customWords.length === this.shuffledMnemonicWords.length
                ? true
                : false;
    }
    clear() {
        this.customWords = [];
        this.shuffledMnemonicWords.forEach(word => {
            word.selected = false;
        });
        this.selectComplete = false;
        setTimeout(() => {
            this.gameSlides.lockSwipes(false);
            this.gameSlides.slideTo(0);
            this.gameSlides.lockSwipes(true);
        }, 300);
    }
    setFlow() {
        if (!this.mnemonicWords)
            return;
        this.shuffledMnemonicWords = this.shuffledWords(this.mnemonicWords);
        this.mnemonicHasPassphrase = this.keyProvider.mnemonicHasPassphrase(this.keyId);
        this.useIdeograms = this.mnemonicWords.indexOf('\u3000') >= 0;
        this.password = '';
        this.customWords = [];
        this.selectComplete = false;
    }
    finalStep() {
        const customWordList = __WEBPACK_IMPORTED_MODULE_4_lodash__["map"](this.customWords, 'word');
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEqual"](this.mnemonicWords, customWordList)) {
            this.showErrorInfoSheet('Mnemonic string mismatch');
            return;
        }
        if (this.mnemonicHasPassphrase) {
            const keyClient = this.bwcProvider.getKey();
            const separator = this.useIdeograms ? '\u3000' : ' ';
            const customSentence = customWordList.join(separator);
            const password = this.password || '';
            let key;
            try {
                key = keyClient.fromMnemonic(customSentence, {
                    useLegacyCoinType: false,
                    useLegacyPurpose: false,
                    passphrase: password
                });
            }
            catch (err) {
                this.showErrorInfoSheet(err);
                return;
            }
            if (key.xPrivKey != this.keys.xPrivKey) {
                this.showErrorInfoSheet('Private key mismatch');
                return;
            }
        }
        this.profileProvider.setBackupGroupFlag(this.keyId);
        const opts = {
            keyId: this.keyId,
            showHidden: true
        };
        const wallets = this.profileProvider.getWalletsFromGroup(opts);
        wallets.forEach(w => {
            this.profileProvider.setWalletBackup(w.credentials.walletId);
        });
        this.showSuccessModal();
    }
    showSuccessModal() {
        const finishText = this.translate.instant('Your recovery phrase is verified');
        const finishComment = this.translate.instant('Be sure to store your recovery phrase in a safe and secure place');
        const cssClass = 'primary';
        const params = { finishText, finishComment, cssClass };
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_5__finish_finish__["a" /* FinishModalPage */], params, {
            showBackdrop: true,
            enableBackdropDismiss: false,
            cssClass: 'finish-modal'
        });
        modal.present();
        modal.onDidDismiss(() => {
            this.navCtrl.popToRoot();
        });
    }
    showErrorInfoSheet(err) {
        this.logger.warn('Failed to verify backup: ', err);
        const infoSheet = this.actionSheetProvider.createInfoSheet('backup-failed');
        infoSheet.present();
        infoSheet.onDidDismiss(() => {
            this.clear();
            this.setFlow();
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('gameSlides'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["r" /* Slides */])
], BackupGamePage.prototype, "gameSlides", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Navbar */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* Navbar */])
], BackupGamePage.prototype, "navBar", void 0);
BackupGamePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-backup-game',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/backup/backup-game/backup-game.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Verify Your Phrase\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n\n<ion-content no-bounce>\n  <div class="grid-container">\n    <div class="key-container" [hidden]="mnemonicHasPassphrase && selectComplete">\n      <div class="word-container">\n        <ion-slides #gameSlides class="word-slides" slidesPerView="2" spaceBetween="20" centeredSlides="true">\n          <ion-slide *ngFor="let mnemonicWord of mnemonicWords; let i = index">\n            <div class="word">\n              <span *ngIf="customWords && customWords[i]">{{customWords[i].word}}</span>\n              <div class="dash-line"></div>\n            </div>\n            <div class="word-number">\n              {{i + 1}} / {{mnemonicWords.length}}\n            </div>\n          </ion-slide>\n        </ion-slides>\n      </div>\n    </div>\n\n    <div class="mnemonic-words-container" [hidden]="mnemonicHasPassphrase && selectComplete">\n      <div class="mnemonic-words" *ngIf="!selectComplete">\n        <div class="bottom-title" translate>Tap each word in the correct order.</div>\n        <div class="words">\n          <button class="button-secondary" ion-button *ngFor="let shuffledWord of shuffledMnemonicWords; let i = index"\n            (click)="addButton(i, shuffledWord)" [disabled]="shuffledWord.selected">{{shuffledWord.word}}</button>\n        </div>\n      </div>\n      <div *ngIf="selectComplete" class="confirm-container">\n        <div translate>Is this correct?</div>\n        <button *ngIf="selectComplete" ion-button class="button-standard" (click)="finalStep()">\n          {{\'Confirm\' | translate}}\n        </button>\n        <button ion-button clear class="button-standard" (click)="clear()">\n          {{\'Clear\' | translate}}\n        </button>\n      </div>\n    </div>\n\n    <div [hidden]="!mnemonicHasPassphrase || !(mnemonicHasPassphrase && selectComplete)">\n      <div class="key-container">\n        <div class="password">\n          <div class="password-title" translate>\n            In order to verify your wallet recovery phrase, please type your password.\n          </div>\n          <ion-item>\n            <ion-label stacked translate>Password</ion-label>\n            <ion-input type="password" id="password" [(ngModel)]="password" autocapitalize="off" spellcheck="false">\n            </ion-input>\n          </ion-item>\n          <div class="password-text">\n            <span class="assertive" translate>This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.</span>\n          </div>\n        </div>\n      </div>\n\n      <div class="bottom-absolute" *ngIf="mnemonicHasPassphrase">\n        <button [disabled]="!password" ion-button class="button-standard" (click)="finalStep()">\n          {{\'Confirm\' | translate}}\n        </button>\n      </div>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/backup/backup-game/backup-game.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers_key_key__["a" /* KeyProvider */]])
], BackupGamePage);

//# sourceMappingURL=backup-game.js.map

/***/ }),

/***/ 1016:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletGroupNamePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(15);






// providers

let WalletGroupNamePage = class WalletGroupNamePage {
    constructor(profileProvider, navCtrl, navParams, formBuilder, logger, translate) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.formBuilder = formBuilder;
        this.logger = logger;
        this.translate = translate;
        this.walletGroupNameForm = this.formBuilder.group({
            walletGroupName: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required])
            ]
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletGroupNamePage');
    }
    ionViewWillEnter() {
        this.walletGroup = this.profileProvider.getWalletGroup(this.navParams.data.keyId);
        this.walletGroupNameForm.value.walletGroupName = this.walletGroup.name;
        this.description = this.translate.instant('You can change the name displayed on this device below.');
    }
    save() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.profileProvider.setWalletGroupName(this.navParams.data.keyId, this.walletGroupNameForm.value.walletGroupName);
            this.navCtrl.pop();
        });
    }
};
WalletGroupNamePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-group-name',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-name/wallet-group-name.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Key Name\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list class="settings-list bp-list">\n    <div class="settings-explanation">\n      <div class="settings-heading" translate>What do you call this key?</div>\n      <div class="settings-description">\n        {{description}}\n      </div>\n    </div>\n    <form [formGroup]="walletGroupNameForm">\n      <ion-item>\n        <ion-label stacked>{{\'Name\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="walletGroupName" [value]="walletGroupNameForm.value.walletGroupName" required></ion-input>\n      </ion-item>\n      <button ion-button class="button-standard" (click)="save()" [disabled]="!walletGroupNameForm.valid">\n        {{\'Save\' | translate}}\n      </button>\n    </form>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-name/wallet-group-name.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], WalletGroupNamePage);

//# sourceMappingURL=wallet-group-name.js.map

/***/ }),

/***/ 1017:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletDeletePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_push_notifications_push_notifications__ = __webpack_require__(115);




// providers






let WalletDeletePage = class WalletDeletePage {
    constructor(profileProvider, navCtrl, navParams, popupProvider, onGoingProcessProvider, logger, translate, keyProvider, pushNotificationsProvider, events) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger = logger;
        this.translate = translate;
        this.keyProvider = keyProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.events = events;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletDeletePage');
    }
    ionViewWillEnter() {
        const walletId = this.navParams.data.walletId;
        this.keyId = this.navParams.data.keyId;
        this.wallet = this.profileProvider.getWallet(walletId);
    }
    showDeletePopup() {
        const title = this.translate.instant('Warning!');
        const message = this.translate.instant('Are you sure you want to delete this wallet?');
        this.popupProvider.ionicConfirm(title, message, null, null).then(res => {
            if (res)
                this.deleteWallet();
        });
    }
    deleteWallet() {
        this.onGoingProcessProvider.set('deletingWallet');
        this.profileProvider.removeProfileLegacy();
        this.profileProvider
            .deleteWalletClient(this.wallet)
            .then(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.onGoingProcessProvider.clear();
            this.pushNotificationsProvider.unsubscribe(this.wallet);
            const keyInUse = this.profileProvider.isKeyInUse(this.keyId);
            if (!keyInUse) {
                this.keyProvider.removeKey(this.keyId);
                delete this.profileProvider.walletsGroups[this.keyId];
                this.goHome();
            }
            else {
                this.logger.warn('Key was not removed. Still in use');
                this.goHome();
            }
        }))
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.warn('Could not remove all wallet data: ', err);
            this.popupProvider.ionicAlert(this.translate.instant('Error'), err.message || err);
        });
    }
    goHome() {
        this.events.publish('Local/WalletListChange');
        setTimeout(() => {
            this.navCtrl.popToRoot();
        }, 1000);
    }
};
WalletDeletePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-delete',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-delete/wallet-delete.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Delete Wallet\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <h3 class="assertive" translate>Warning!</h3>\n  <p translate>\n    Permanently delete this wallet.\n  </p>\n  <p translate>\n    THIS ACTION CANNOT BE REVERSED\n  </p>\n  <button ion-button class="button-standard" color="danger" (click)="showDeletePopup()">\n    {{\'Delete\' | translate}}\n  </button>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-delete/wallet-delete.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */]])
], WalletDeletePage);

//# sourceMappingURL=wallet-delete.js.map

/***/ }),

/***/ 1018:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletNamePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_replace_parameters_replace_parameters__ = __webpack_require__(101);






// providers



let WalletNamePage = class WalletNamePage {
    constructor(profileProvider, navCtrl, navParams, configProvider, formBuilder, events, logger, replaceParametersProvider, translate) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.formBuilder = formBuilder;
        this.events = events;
        this.logger = logger;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.walletNameForm = this.formBuilder.group({
            walletName: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required])
            ]
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletNamePage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.config = this.configProvider.get();
        let alias = this.config.aliasFor &&
            this.config.aliasFor[this.wallet.credentials.walletId];
        this.walletNameForm.value.walletName = alias
            ? alias
            : this.wallet.credentials.walletName;
        this.walletName = this.wallet.credentials.walletName;
        this.description = this.replaceParametersProvider.replace(this.translate.instant('When this wallet was created, it was called "{{walletName}}". You can change the name displayed on this device below.'), { walletName: this.walletName });
    }
    save() {
        let opts = {
            aliasFor: {}
        };
        opts.aliasFor[this.wallet.credentials.walletId] = this.walletNameForm.value.walletName;
        this.configProvider.set(opts);
        this.events.publish('Local/ConfigUpdate', {
            walletId: this.wallet.credentials.walletId
        });
        this.navCtrl.pop();
    }
};
WalletNamePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-name',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-name/wallet-name.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Wallet Name\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list class="settings-list bp-list">\n    <div class="settings-explanation">\n      <div class="settings-heading" translate>What do you call this wallet?</div>\n      <div class="settings-description">\n        {{description}}\n      </div>\n    </div>\n    <form [formGroup]="walletNameForm">\n      <ion-item>\n        <ion-label stacked>{{\'Name\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="walletName" [value]="walletNameForm.value.walletName" required></ion-input>\n      </ion-item>\n      <button ion-button class="button-standard" (click)="save()" [disabled]="!walletNameForm.valid">\n        {{\'Save\' | translate}}\n      </button>\n    </form>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-name/wallet-name.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], WalletNamePage);

//# sourceMappingURL=wallet-name.js.map

/***/ }),

/***/ 1019:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AllAddressesPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(12);




// native

// providers



let AllAddressesPage = class AllAddressesPage {
    constructor(navParams, viewCtrl, onGoingProcessProvider, socialSharing, appProvider, logger, platformProvider) {
        this.navParams = navParams;
        this.viewCtrl = viewCtrl;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.socialSharing = socialSharing;
        this.appProvider = appProvider;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.walletName = this.navParams.data.walletName;
        this.noBalance = this.navParams.data.noBalance;
        this.withBalance = this.navParams.data.withBalance;
        this.coin = this.navParams.data.coin;
        this.allAddresses = this.noBalance.concat(this.withBalance);
        this.isCordova = this.platformProvider.isCordova;
    }
    dismiss() {
        this.viewCtrl.dismiss();
    }
    formatDate(ts) {
        const dateObj = new Date(ts * 1000);
        if (!dateObj) {
            this.logger.warn('Error formating a date');
            return 'DateError';
        }
        if (!dateObj.toJSON()) {
            return '';
        }
        return dateObj.toJSON();
    }
    sendByEmail() {
        this.onGoingProcessProvider.set('sendingByEmail');
        setTimeout(() => {
            this.onGoingProcessProvider.clear();
            const appName = this.appProvider.info.nameCase;
            let body = appName +
                ' Wallet "' +
                this.walletName +
                '" Addresses\n  Only Main Addresses are  shown.\n\n';
            body += '\n';
            body += this.allAddresses
                .map(v => {
                return ('* ' +
                    v.address +
                    ' xpub' +
                    v.path.substring(1) +
                    ' ' +
                    this.formatDate(v.createdOn));
            })
                .join('\n');
            const subject = appName + ' Addresses';
            // Check if sharing via email is supported
            this.socialSharing
                .canShareViaEmail()
                .then(() => {
                this.logger.info('sharing via email is possible');
                this.socialSharing
                    .shareViaEmail(body, subject, null, // TO: must be null or an array
                null, // CC: must be null or an array
                null, // BCC: must be null or an array
                null // FILES: can be null, a string, or an array
                )
                    .then(data => {
                    this.logger.info('Email created successfully: ', data);
                })
                    .catch(err => {
                    this.logger.error('socialSharing Error: ', err);
                });
            })
                .catch(() => {
                this.logger.warn('sharing via email is not possible');
                this.socialSharing.share(body, subject).catch(err => {
                    this.logger.error('socialSharing Error: ', err);
                });
            });
        });
    }
};
AllAddressesPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-all-addresses',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/all-addresses/all-addresses.html"*/'<ion-header>\n  <ion-toolbar>\n    <ion-title>{{\'All addresses\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button class="modal-close-button" ion-button (click)="dismiss()">\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content>\n  <ion-list class="settings-list bp-list">\n    <ion-item-divider *ngIf="withBalance && withBalance[0]">{{\'Addresses with balance\' | translate}}</ion-item-divider>\n    <ion-item *ngFor="let w of withBalance" copy-to-clipboard="{{w.address}}">\n      <div>{{w.address}}</div>\n      <p class="info">\n        {{w.amount | satToUnit: coin}}\n      </p>\n    </ion-item>\n\n    <ion-item-divider *ngIf="noBalance && noBalance[0]">{{\'Unused addresses\' | translate}}</ion-item-divider>\n    <ion-item *ngFor="let u of noBalance" copy-to-clipboard="{{u.address}}">\n      <div>{{u.address}}</div>\n      <ion-note>\n        {{u.path}} {{u.createdOn * 1000 | amDateFormat:\'MMMM Do YYYY, hh:mm a\'}}\n      </ion-note>\n    </ion-item>\n  </ion-list>\n</ion-content>\n<ion-footer>\n  <ion-toolbar *ngIf="isCordova && allAddresses[0]">\n    <button ion-button full class="button-footer" (click)="sendByEmail()">\n      <span translate>Send addresses by email</span>\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/all-addresses/all-addresses.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */]])
], AllAddressesPage);

//# sourceMappingURL=all-addresses.js.map

/***/ }),

/***/ 102:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AmountPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_electron_electron__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_filter_filter__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_rate_rate__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_gift_card_gift_card__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__integrations_bitpay_card_bitpay_card_topup_bitpay_card_topup__ = __webpack_require__(984);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__integrations_coinbase_buy_coinbase_buy_coinbase__ = __webpack_require__(985);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__integrations_coinbase_sell_coinbase_sell_coinbase__ = __webpack_require__(987);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__integrations_gift_cards_confirm_card_purchase_confirm_card_purchase__ = __webpack_require__(468);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__integrations_shapeshift_shapeshift_confirm_shapeshift_confirm__ = __webpack_require__(991);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__receive_custom_amount_custom_amount__ = __webpack_require__(994);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__wallet_tabs_wallet_tabs_child__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__wallet_tabs_wallet_tabs_provider__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__confirm_confirm__ = __webpack_require__(249);





// Providers








// Pages












let AmountPage = class AmountPage extends __WEBPACK_IMPORTED_MODULE_22__wallet_tabs_wallet_tabs_child__["a" /* WalletTabsChild */] {
    constructor(actionSheetProvider, configProvider, filterProvider, giftCardProvider, currencyProvider, logger, navCtrl, navParams, electronProvider, platformProvider, profileProvider, rateProvider, txFormatProvider, changeDetectorRef, walletTabsProvider, events, viewCtrl, statusBar) {
        super(navCtrl, profileProvider, walletTabsProvider);
        this.actionSheetProvider = actionSheetProvider;
        this.configProvider = configProvider;
        this.filterProvider = filterProvider;
        this.giftCardProvider = giftCardProvider;
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.electronProvider = electronProvider;
        this.platformProvider = platformProvider;
        this.rateProvider = rateProvider;
        this.txFormatProvider = txFormatProvider;
        this.changeDetectorRef = changeDetectorRef;
        this.events = events;
        this.viewCtrl = viewCtrl;
        this.statusBar = statusBar;
        this.walletDisableHardwareKeyboardHandler = () => {
            this._disableHardwareKeyboard();
        };
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
        this.config = this.configProvider.get();
        this.useAsModal = this.navParams.data.useAsModal;
        this.recipientType = this.navParams.data.recipientType;
        this.toAddress = this.navParams.data.toAddress;
        this.network = this.navParams.data.network;
        this.name = this.navParams.data.name;
        this.email = this.navParams.data.email;
        this.color = this.navParams.data.color;
        this.fixedUnit = this.navParams.data.fixedUnit;
        this.description = this.navParams.data.description;
        this.onlyIntegers = this.navParams.data.onlyIntegers
            ? this.navParams.data.onlyIntegers
            : false;
        this.showSendMax = false;
        this.useSendMax = false;
        this.allowSend = false;
        this.availableUnits = [];
        this.expression = '';
        this.LENGTH_EXPRESSION_LIMIT = 19;
        this.amount = 0;
        this.altUnitIndex = 0;
        this.unitIndex = 0;
        this.reNr = /^[1234567890\.]$/;
        this.reOp = /^[\*\+\-\/]$/;
        this.requestingAmount =
            this.navParams.get('nextPage') === 'CustomAmountPage';
        this.nextView = this.getNextView();
        // BitPay Card ID or Wallet ID
        this._id = this.navParams.data.id;
        // Use only with ShapeShift
        this.toWalletId = this.navParams.data.toWalletId;
        this.cardName = this.navParams.get('cardName');
    }
    ionViewDidLoad() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.setAvailableUnits();
            this.updateUnitUI();
            const { unitToSatoshi, unitDecimals } = this.availableUnits[this.unitIndex]
                .isFiat
                ? this.currencyProvider.getPrecision(this.availableUnits[this.altUnitIndex].id)
                : this.currencyProvider.getPrecision(this.unit.toLowerCase());
            this.unitToSatoshi = unitToSatoshi;
            this.satToUnit = 1 / this.unitToSatoshi;
            this.unitDecimals = unitDecimals;
            this.cardConfig =
                this.cardName &&
                    (yield this.giftCardProvider.getCardConfig(this.cardName));
        });
    }
    ionViewWillEnter() {
        if (this.platformProvider.isCordova &&
            (this.cardName || this._id || this.toWalletId)) {
            this.statusBar.styleBlackOpaque();
        }
        this.disableHardwareKeyboard = false;
        this.expression = '';
        this.useSendMax = false;
        this.processAmount();
        this.events.subscribe('Wallet/disableHardwareKeyboard', this.walletDisableHardwareKeyboardHandler);
    }
    ionViewWillLeave() {
        if (this.platformProvider.isCordova &&
            (this.cardName || this._id || this.toWalletId)) {
            this.statusBar.styleDefault();
        }
        this._disableHardwareKeyboard();
    }
    _disableHardwareKeyboard() {
        this.disableHardwareKeyboard = true;
    }
    handleKeyboardEvent(event) {
        if (this.disableHardwareKeyboard)
            return;
        if (!event.key)
            return;
        if (event.which === 8) {
            event.preventDefault();
            this.removeDigit();
        }
        if (event.key.match(this.reNr)) {
            this.pushDigit(event.key, true);
        }
        else if (event.key.match(this.reOp)) {
            this.pushOperator(event.key);
        }
        else if (event.keyCode === 86) {
            if (event.ctrlKey || event.metaKey)
                this.processClipboard();
        }
        else if (event.keyCode === 13)
            this.finish();
    }
    isCoin(coin) {
        return !!__WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__["a" /* Coin */][coin];
    }
    setAvailableUnits() {
        this.availableUnits = [];
        const parentWalletCoin = this.navParams.data.wallet
            ? this.navParams.data.wallet.coin
            : this.wallet && this.wallet.coin;
        for (const coin of this.currencyProvider.getAvailableCoins()) {
            if (parentWalletCoin === coin || !parentWalletCoin) {
                const { unitName, unitCode } = this.currencyProvider.getPrecision(coin);
                this.availableUnits.push({
                    name: this.currencyProvider.getCoinName(coin),
                    id: unitCode,
                    shortName: unitName
                });
            }
        }
        this.unitIndex = 0;
        if (this.navParams.data.coin) {
            let coins = this.navParams.data.coin.split(',');
            let newAvailableUnits = [];
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](coins, (c) => {
                let coin = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.availableUnits, {
                    id: c
                });
                if (!coin) {
                    this.logger.warn('Could not find desired coin:' + this.navParams.data.coin);
                }
                else {
                    newAvailableUnits.push(coin);
                }
            });
            if (newAvailableUnits.length > 0) {
                this.availableUnits = newAvailableUnits;
            }
        }
        //  currency have preference
        let fiatName;
        if (this.navParams.data.currency) {
            this.fiatCode = this.navParams.data.currency;
            this.altUnitIndex = this.unitIndex;
            this.unitIndex = this.availableUnits.length;
        }
        else {
            this.fiatCode = this.config.wallet.settings.alternativeIsoCode || 'USD';
            fiatName = this.config.wallet.settings.alternativeName || this.fiatCode;
            this.altUnitIndex = this.availableUnits.length;
        }
        this.availableUnits.push({
            name: fiatName || this.fiatCode,
            // TODO
            id: this.fiatCode,
            shortName: this.fiatCode,
            isFiat: true
        });
        if (this.navParams.data.fixedUnit) {
            this.fixedUnit = true;
        }
    }
    paste(value) {
        this.zone.run(() => {
            this.expression = value;
            this.processAmount();
            this.changeDetectorRef.detectChanges();
        });
    }
    getNextView() {
        let nextPage;
        switch (this.navParams.data.nextPage) {
            case 'BitPayCardTopUpPage':
                this.showSendMax = true;
                nextPage = __WEBPACK_IMPORTED_MODULE_16__integrations_bitpay_card_bitpay_card_topup_bitpay_card_topup__["a" /* BitPayCardTopUpPage */];
                break;
            case 'ConfirmCardPurchasePage':
                nextPage = __WEBPACK_IMPORTED_MODULE_19__integrations_gift_cards_confirm_card_purchase_confirm_card_purchase__["a" /* ConfirmCardPurchasePage */];
                break;
            case 'BuyCoinbasePage':
                nextPage = __WEBPACK_IMPORTED_MODULE_17__integrations_coinbase_buy_coinbase_buy_coinbase__["a" /* BuyCoinbasePage */];
                break;
            case 'SellCoinbasePage':
                nextPage = __WEBPACK_IMPORTED_MODULE_18__integrations_coinbase_sell_coinbase_sell_coinbase__["a" /* SellCoinbasePage */];
                break;
            case 'CustomAmountPage':
                nextPage = __WEBPACK_IMPORTED_MODULE_21__receive_custom_amount_custom_amount__["a" /* CustomAmountPage */];
                break;
            case 'ShapeshiftConfirmPage':
                this.showSendMax = true;
                nextPage = __WEBPACK_IMPORTED_MODULE_20__integrations_shapeshift_shapeshift_confirm_shapeshift_confirm__["a" /* ShapeshiftConfirmPage */];
                break;
            default:
                this.showSendMax = true;
                nextPage = __WEBPACK_IMPORTED_MODULE_24__confirm_confirm__["a" /* ConfirmPage */];
        }
        return nextPage;
    }
    processClipboard() {
        if (!this.platformProvider.isElectron)
            return;
        let value = this.electronProvider.readFromClipboard();
        if (value && this.evaluate(value) > 0)
            this.paste(this.evaluate(value));
    }
    sendMax() {
        this.useSendMax = true;
        this.allowSend = true;
        if (!this.wallet) {
            return this.finish();
        }
        const maxAmount = this.txFormatProvider.satToUnit(this.wallet.cachedStatus.availableBalanceSat, this.wallet.coin);
        this.zone.run(() => {
            this.expression = this.availableUnits[this.unitIndex].isFiat
                ? this.toFiat(maxAmount, this.wallet.coin).toFixed(2)
                : maxAmount;
            this.processAmount();
            this.changeDetectorRef.detectChanges();
            this.finish();
        });
    }
    isSendMaxButtonShown() {
        return (!this.expression &&
            !this.requestingAmount &&
            this.showSendMax &&
            !this.useAsModal);
    }
    pushDigit(digit, isHardwareKeyboard) {
        this.useSendMax = false;
        if (digit === 'delete') {
            return this.removeDigit();
        }
        if (this.isSendMaxButtonShown() && digit === '0' && !isHardwareKeyboard) {
            return this.sendMax();
        }
        if (this.expression &&
            this.expression.length >= this.LENGTH_EXPRESSION_LIMIT)
            return;
        this.zone.run(() => {
            this.expression = (this.expression + digit).replace('..', '.');
            this.processAmount();
            this.changeDetectorRef.detectChanges();
        });
    }
    removeDigit() {
        this.zone.run(() => {
            this.expression = this.expression.slice(0, -1);
            this.processAmount();
            this.changeDetectorRef.detectChanges();
        });
    }
    pushOperator(operator) {
        if (!this.expression || this.expression.length == 0)
            return;
        this.zone.run(() => {
            this.expression = this._pushOperator(this.expression, operator);
            this.changeDetectorRef.detectChanges();
        });
    }
    _pushOperator(val, operator) {
        if (!this.isOperator(__WEBPACK_IMPORTED_MODULE_4_lodash__["last"](val))) {
            return val + operator;
        }
        else {
            return val.slice(0, -1) + operator;
        }
    }
    isOperator(val) {
        const regex = /[\/\-\+\x\*]/;
        return regex.test(val);
    }
    isExpression(val) {
        const regex = /^\.?\d+(\.?\d+)?([\/\-\+\*x]\d?\.?\d+)+$/;
        return regex.test(val);
    }
    processAmount() {
        let formatedValue = this.format(this.expression);
        let result = this.evaluate(formatedValue);
        this.allowSend = this.onlyIntegers
            ? __WEBPACK_IMPORTED_MODULE_4_lodash__["isNumber"](result) && +result > 0 && Number.isInteger(+result)
            : __WEBPACK_IMPORTED_MODULE_4_lodash__["isNumber"](result) && +result > 0;
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isNumber"](result)) {
            this.globalResult = this.isExpression(this.expression)
                ? '= ' + this.processResult(result)
                : '';
            if (this.availableUnits[this.unitIndex].isFiat) {
                let a = this.fromFiat(result);
                if (a) {
                    this.alternativeAmount = this.txFormatProvider.formatAmount(this.availableUnits[this.altUnitIndex].id, a * this.unitToSatoshi, true);
                    this.checkAmountForBitpaycard(result);
                }
                else {
                    this.alternativeAmount = result ? 'N/A' : null;
                    this.allowSend = false;
                }
            }
            else {
                this.alternativeAmount = this.filterProvider.formatFiatAmount(this.toFiat(result));
                this.checkAmountForBitpaycard(this.toFiat(result));
            }
        }
    }
    checkAmountForBitpaycard(amount) {
        // Check if the top up amount is at least 1 usd
        const isTopUp = this.navParams.data.nextPage === 'BitPayCardTopUpPage' ? true : false;
        if (isTopUp && amount < 1) {
            this.allowSend = false;
        }
    }
    processResult(val) {
        if (this.availableUnits[this.unitIndex].isFiat)
            return this.filterProvider.formatFiatAmount(val);
        else
            return this.txFormatProvider.formatAmount(this.unit.toLowerCase(), val.toFixed(this.unitDecimals) * this.unitToSatoshi, true);
    }
    fromFiat(val, coin) {
        coin = coin || this.availableUnits[this.altUnitIndex].id;
        return parseFloat((this.rateProvider.fromFiat(val, this.fiatCode, coin) * this.satToUnit).toFixed(this.unitDecimals));
    }
    toFiat(val, coin) {
        if (!this.rateProvider.getRate(this.fiatCode, coin || this.availableUnits[this.unitIndex].id))
            return undefined;
        return parseFloat(this.rateProvider
            .toFiat(val * this.unitToSatoshi, this.fiatCode, coin || this.availableUnits[this.unitIndex].id)
            .toFixed(2));
    }
    format(val) {
        if (!val)
            return undefined;
        let result = val.toString();
        if (this.isOperator(__WEBPACK_IMPORTED_MODULE_4_lodash__["last"](val)))
            result = result.slice(0, -1);
        return result.replace('x', '*');
    }
    evaluate(val) {
        let result;
        try {
            result = eval(val);
        }
        catch (e) {
            return 0;
        }
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isFinite"](result))
            return 0;
        return result;
    }
    validateGiftCardAmount(amount) {
        return (amount <= this.cardConfig.maxAmount && amount >= this.cardConfig.minAmount);
    }
    showCardAmountInfoSheet(amount) {
        const sheetType = amount < this.cardConfig.minAmount
            ? 'below-minimum-gift-card-amount'
            : 'above-maximum-gift-card-amount';
        this.actionSheetProvider
            .createInfoSheet(sheetType, this.cardConfig)
            .present();
    }
    finish(skipActivationFeeAlert = false) {
        if (!this.allowSend)
            return;
        let unit = this.availableUnits[this.unitIndex];
        let _amount = this.evaluate(this.format(this.expression));
        let coin = unit.id;
        let data;
        if (unit.isFiat) {
            coin = this.availableUnits[this.altUnitIndex].id;
        }
        if (this.navParams.data.nextPage) {
            const amount = this.useSendMax ? null : _amount;
            if (this.cardConfig && !this.validateGiftCardAmount(amount)) {
                this.showCardAmountInfoSheet(amount);
                return;
            }
            data = {
                id: this._id,
                amount,
                currency: unit.id.toUpperCase(),
                coin,
                useSendMax: this.useSendMax,
                toWalletId: this.toWalletId,
                cardName: this.cardName
            };
            if (this.wallet) {
                data.network = this.wallet.network;
                if (this.wallet.credentials.token) {
                    data.tokenAddress = this.wallet.credentials.token.address;
                }
            }
        }
        else {
            let amount = _amount;
            amount = unit.isFiat
                ? (this.fromFiat(amount) * this.unitToSatoshi).toFixed(0)
                : (amount * this.unitToSatoshi).toFixed(0);
            data = {
                recipientType: this.recipientType,
                amount,
                toAddress: this.toAddress,
                name: this.name,
                email: this.email,
                color: this.color,
                coin,
                useSendMax: this.useSendMax,
                description: this.description
            };
            if (this.wallet) {
                data.network = this.wallet.network;
                if (this.wallet.credentials.token) {
                    data.tokenAddress = this.wallet.credentials.token.address;
                }
            }
            if (unit.isFiat) {
                data.fiatAmount = _amount;
                data.fiatCode = this.fiatCode;
            }
        }
        this.useSendMax = null;
        if (this.cardName && !skipActivationFeeAlert) {
            const activationFee = Object(__WEBPACK_IMPORTED_MODULE_14__providers_gift_card_gift_card__["b" /* getActivationFee */])(data.amount, this.cardConfig);
            if (activationFee) {
                return this.alertActivationFeeIncluded(activationFee);
            }
        }
        this.useAsModal
            ? this.closeModal(data)
            : this.navCtrl.push(this.nextView, data);
    }
    alertActivationFeeIncluded(fee) {
        if (!fee)
            return;
        const sheet = this.actionSheetProvider.createInfoSheet('activation-fee-included', {
            currency: this.cardConfig.currency,
            displayName: this.cardConfig.displayName,
            fee
        });
        sheet.present();
        sheet.onDidDismiss(ok => ok && this.finish(true));
    }
    updateUnitUI() {
        this.unit = this.availableUnits[this.unitIndex].shortName;
        this.alternativeUnit = this.availableUnits[this.altUnitIndex].shortName;
        this.processAmount();
        this.logger.debug('Update unit coin @amount unit:' +
            this.unit +
            ' alternativeUnit:' +
            this.alternativeUnit);
    }
    resetValues() {
        this.expression = '';
        this.globalResult = '';
        this.alternativeAmount = null;
    }
    changeUnit() {
        if (this.fixedUnit)
            return;
        this.unitIndex++;
        if (this.unitIndex >= this.availableUnits.length)
            this.unitIndex = 0;
        if (this.availableUnits[this.unitIndex].isFiat) {
            // Always return to BTC... TODO?
            this.altUnitIndex = 0;
        }
        else {
            this.altUnitIndex = __WEBPACK_IMPORTED_MODULE_4_lodash__["findIndex"](this.availableUnits, {
                isFiat: true
            });
        }
        this.resetValues();
        this.zone.run(() => {
            this.updateUnitUI();
            this.changeDetectorRef.detectChanges();
        });
    }
    closeModal(item) {
        if (this.viewCtrl.name === 'AmountPage') {
            if (!item) {
                this.viewCtrl.dismiss();
                return;
            }
            this.events.publish('addRecipient', item);
            this.navCtrl.remove(this.viewCtrl.index - 1).then(() => {
                this.viewCtrl.dismiss();
            });
        }
        else {
            this.viewCtrl.dismiss(item);
        }
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["HostListener"])('document:keydown', ['$event']),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Function),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [KeyboardEvent]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:returntype", void 0)
], AmountPage.prototype, "handleKeyboardEvent", null);
AmountPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-amount',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/send/amount/amount.html"*/'<ion-header [ngClass]="{\'wallet-details-header\': wallet}">\n  <ion-navbar class="app-color" [hideBackButton]="useAsModal">\n    <ion-buttons left *ngIf="useAsModal">\n      <button class="modal-close-button" (click)="closeModal()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n    <ion-title>{{wallet && wallet.name || (\'Amount\' | translate)}}</ion-title>\n  </ion-navbar>\n  <ion-toolbar *ngIf="wallet && !requestingAmount" class="app-color">\n    <div *ngIf="!wallet.balanceHidden && !wallet.scanning && wallet.cachedStatus" class="wallet-details-header__balance">\n      <span>{{wallet.cachedStatus && wallet.cachedStatus.spendableBalanceStr}}</span>\n      <ion-icon *ngIf="wallet.cachedStatus.totalBalanceSat != wallet.cachedStatus.spendableAmount" ios="ios-timer-outline" md="md-timer"></ion-icon>\n    </div>\n    <div *ngIf="wallet.balanceHidden  && !wallet.scanning" class="wallet-details-header__balance-hidden">\n      <span class="title" translate>[Balance Hidden]</span>\n    </div>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content no-bounce>\n\n  <div class="amount-wrapper">\n\n    <div class="amount-header-margin">\n      <div class="amount-header">\n        <div style="flex: 1">\n          <div class="switcher" (click)="changeUnit()" [hidden]="fixedUnit" tappable>\n            <img class="switcher__icon" src="assets/img/icon-swap.svg">\n            <div class="switcher__label">{{unit}}</div>\n          </div>\n        </div>\n        <img class="next-button" [ngClass]="{\'show\': expression && allowSend}" src="assets/img/icon-next.svg" (click)="finish()" tappable>\n      </div>\n    </div>\n\n    <div class="amount-content">\n      <div class="expression-container">\n        <span class="expression">\n          {{expression ? expression : (onlyIntegers || isCoin(unit)) ? \'0\' : \'0.00\'}}\n        </span>\n        <span class="unit" [hidden]="globalResult">{{unit}}</span>\n      </div>\n      <div class="amount" [hidden]="!globalResult">{{globalResult}} {{unit}}</div>\n      <div class="result">&asymp;\n        <span *ngIf="fiatCode === alternativeUnit">{{alternativeAmount || \'0.00\'}}</span>\n        <span *ngIf="fiatCode !== alternativeUnit">{{alternativeAmount || \'0\'}}</span>\n        {{alternativeUnit}}\n      </div>\n    </div>\n\n    <pin-pad (keystroke)="pushDigit($event)" type="amount" [showSendMax]="isSendMaxButtonShown()" [integersOnly]="onlyIntegers"></pin-pad>\n\n  </div>\n\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/send/amount/amount.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_13__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers__["E" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_electron_electron__["a" /* ElectronProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["ChangeDetectorRef"],
        __WEBPACK_IMPORTED_MODULE_23__wallet_tabs_wallet_tabs_provider__["a" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */]])
], AmountPage);

//# sourceMappingURL=amount.js.map

/***/ }),

/***/ 1020:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletDuplicatePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_push_notifications_push_notifications__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wallet_tabs_wallet_tabs_provider__ = __webpack_require__(90);






// Providers











let WalletDuplicatePage = class WalletDuplicatePage {
    constructor(walletProvider, onGoingProcessProvider, popupProvider, pushNotificationsProvider, externalLinkProvider, bwcErrorProvider, logger, translate, events, navParams, configProvider, navCtrl, profileProvider, walletTabsProvider, derivationPathHelperProvider) {
        this.walletProvider = walletProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.logger = logger;
        this.translate = translate;
        this.events = events;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.navCtrl = navCtrl;
        this.profileProvider = profileProvider;
        this.walletTabsProvider = walletTabsProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.defaults = this.configProvider.getDefaults();
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        const derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(this.wallet.credentials.rootPath);
        // Filter out already duplicated wallets
        let walletsBCH = this.profileProvider.getWallets({
            coin: 'bch',
            network: 'livenet'
        });
        let xPubKeyIndex = __WEBPACK_IMPORTED_MODULE_4_lodash__["keyBy"](walletsBCH, 'credentials.xPubKey');
        if (xPubKeyIndex[this.wallet.credentials.xPubKey]) {
            this.nonEligibleWallet = this.wallet;
            this.nonEligibleWallet.excludeReason = this.translate.instant('Already duplicated');
        }
        else if (derivationStrategy != 'BIP44') {
            this.nonEligibleWallet = this.wallet;
            this.nonEligibleWallet.excludeReason = this.translate.instant('Non BIP44 wallet');
        }
        else if (!this.wallet.canSign) {
            this.nonEligibleWallet = this.wallet;
            this.nonEligibleWallet.excludeReason = this.translate.instant('Read only wallet');
        }
        else if (this.wallet.needsBackup) {
            this.nonEligibleWallet = this.wallet;
            this.nonEligibleWallet.excludeReason = this.translate.instant('Wallet Needs Backup');
            this.nonEligibleWallet.body = this.translate.instant(`Before duplicating your wallet, it's recommended that you first write down your recovery phrase and store it securely so that your wallet can be recovered in the case your device was lost or stolen.`);
        }
        else {
            this.availableWallet = this.wallet;
        }
        if (!this.availableWallet)
            return;
    }
    setErr(err) {
        const errorMsg = this.bwcErrorProvider.msg(err, 'Could not duplicate');
        this.logger.warn('Duplicate BCH', errorMsg);
        this.popupProvider.ionicAlert(errorMsg, null, 'OK');
        return;
    }
    duplicate(wallet) {
        this.logger.info(`Duplicating wallet for BCH: ${wallet.id} - ${wallet.name}`);
        let opts = {
            useLegacyCoinType: true,
            useLegacyPurpose: true,
            name: `${wallet.name} [BCH duplicate]`,
            m: wallet.m,
            n: wallet.n,
            myName: wallet.credentials.copayerName,
            networkName: wallet.network,
            coin: __WEBPACK_IMPORTED_MODULE_8__providers_currency_currency__["a" /* Coin */].BCH,
            walletPrivKey: wallet.credentials.walletPrivKey,
            compliantDerivation: wallet.credentials.compliantDerivation,
            bwsurl: this.defaults.bws.url,
            derivationStrategy: wallet.credentials.derivationStrategy,
            addressType: wallet.credentials.addressType
        };
        this.walletProvider
            .getKeys(wallet)
            .then(keys => {
            opts.extendedPrivateKey = keys.xPrivKey;
            this.onGoingProcessProvider.set('duplicatingWallet');
            this.importOrCreate(wallet, opts)
                .then(result => {
                let newWallet = result.walletBch;
                let isNew = result.isNew;
                this.walletProvider.updateRemotePreferences(newWallet);
                this.pushNotificationsProvider.updateSubscription(newWallet);
                // Multisig wallets? add Copayers
                this.addCopayers(wallet, newWallet, isNew)
                    .then(() => {
                    this.onGoingProcessProvider.clear();
                    if (isNew) {
                        this.walletProvider.startScan(newWallet).catch(err => {
                            this.logger.warn(err);
                        });
                    }
                    this.events.publish('status:updated');
                    this.navCtrl.popToRoot();
                })
                    .catch(err => {
                    this.onGoingProcessProvider.clear();
                    this.setErr(err);
                });
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.setErr(err);
            });
        })
            .catch(err => {
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED') {
                this.setErr(this.bwcErrorProvider.msg(err));
            }
        });
    }
    addCopayers(wallet, newWallet, isNew) {
        if (!isNew)
            return Promise.resolve();
        if (wallet.n == 1)
            return Promise.resolve();
        this.logger.debug(`Adding copayers for BCH wallet config: ${wallet.m} - ${wallet.n}`);
        return this.walletProvider.copyCopayers(wallet, newWallet);
    }
    importOrCreate(wallet, opts) {
        return this.walletProvider.fetchStatus(wallet, {}).then(status => {
            opts.singleAddress = status.wallet.singleAddress;
            // first try to import
            return this.profileProvider
                .importWithDerivationPath(opts)
                .then(walletBch => {
                return Promise.resolve({ walletBch });
            })
                .catch(() => {
                this.logger.warn('Could not import. Trying to create wallet');
                return this.profileProvider.createWallet(opts).then(walletBch => {
                    return Promise.resolve({ walletBch, isNew: true });
                });
            });
        });
    }
    openHelpExternalLink() {
        let url = 'https://support.bitpay.com/hc/en-us/articles/115005019583-How-Can-I-Recover-Bitcoin-Cash-BCH-from-My-Wallet-';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Help and support information is available at the website');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
WalletDuplicatePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-duplicate',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-duplicate/wallet-duplicate.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Duplicate Wallet</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div *ngIf="availableWallet">\n    <div class="explanation">\n      <span translate>\n        This feature duplicates a Bitcoin wallet on the Bitcoin Cash chain, enabling access to pre-fork coins. This should only be used if there are unclaimed funds before the Bitcoin Cash fork day on the wallet. The resulting wallet will use the same derivation path as the original BTC wallet.\n      </span>\n      <a (click)="openHelpExternalLink()" translate>\n        <span translate>Help &amp; support</span>\n      </a>\n    </div>\n  </div>\n\n  <div *ngIf="nonEligibleWallet">\n    <label-tip class="no-arrowhead" type="warn">\n      <span label-tip-title>{{nonEligibleWallet.excludeReason}}</span>\n      <div label-tip-body>{{nonEligibleWallet.body}}</div>\n    </label-tip>\n  </div>\n\n  <button ion-button class="button-standard" (click)="duplicate(availableWallet)" [disabled]="nonEligibleWallet">\n    {{\'Duplicate to BCH\' | translate}}\n  </button>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-duplicate/wallet-duplicate.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_15__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_16__wallet_tabs_wallet_tabs_provider__["a" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */]])
], WalletDuplicatePage);

//# sourceMappingURL=wallet-duplicate.js.map

/***/ }),

/***/ 1021:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletInformationPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(15);




// providers



let WalletInformationPage = class WalletInformationPage {
    constructor(profileProvider, currencyProvider, navParams, logger) {
        this.profileProvider = profileProvider;
        this.currencyProvider = currencyProvider;
        this.navParams = navParams;
        this.logger = logger;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded:  WalletInformationPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.walletName = this.wallet.name;
        this.coin = this.wallet.coin.toUpperCase();
        this.unitToSatoshi = this.currencyProvider.getPrecision(this.wallet.coin).unitToSatoshi;
        this.walletId = this.wallet.credentials.walletId;
        this.N = this.wallet.credentials.n;
        this.M = this.wallet.credentials.m;
        if (this.wallet.cachedStatus) {
            this.copayers = this.wallet.cachedStatus.wallet.copayers;
        }
        this.copayerId = this.wallet.credentials.copayerId;
        this.balanceByAddress = this.wallet.balanceByAddress;
        this.account = this.wallet.credentials.account;
        this.network = this.wallet.credentials.network;
        this.addressType = this.wallet.credentials.addressType || 'P2SH';
        this.rootPath = this.wallet.credentials.rootPath;
        this.pubKeys = __WEBPACK_IMPORTED_MODULE_3_lodash__["map"](this.wallet.credentials.publicKeyRing, 'xPubKey');
        this.externalSource = null;
        this.canSign = this.wallet.canSign;
        this.linkedEthWalletName = this.wallet.linkedEthWalletName;
    }
    isUtxoCoin() {
        return this.currencyProvider.isUtxoCoin(this.wallet.coin);
    }
};
WalletInformationPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-information',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-information/wallet-information.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Wallet Information\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <ion-list class="settings-list bp-list">\n    <ion-item>\n      <div translate float-left>Name (at creation)</div>\n      <ion-note item-end>\n        {{walletName}}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span translate>Coin</span>\n      <ion-note item-end>\n        {{coin}}\n      </ion-note>\n    </ion-item>\n    <ion-item copy-to-clipboard="{{walletId}}">\n      <span>Wallet Id</span>\n      <div padding-top>\n        <div text-wrap>\n          {{walletId}}\n        </div>\n      </div>\n    </ion-item>\n    <ion-item *ngIf="linkedEthWalletName">\n      <span translate>Linked Ethereum Wallet</span>\n      <ion-note item-end>\n          {{linkedEthWalletName}}\n      </ion-note>\n    </ion-item>\n \n    <ion-item>\n      <span translate>Configuration (m-n)</span>\n      <ion-note item-end>\n        {{M}}-{{N}}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span translate>Network</span>\n      <ion-note item-end>\n        {{network}}\n      </ion-note>\n    </ion-item>\n    <ion-item *ngIf="wallet && isUtxoCoin()">\n      <span translate>Address Type</span>\n      <ion-note item-end>\n        {{addressType}}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span translate>Derivation Path</span>\n      <ion-note item-end>\n        {{rootPath}}\n      </ion-note>\n    </ion-item>\n    <ion-item *ngIf="!canSign">\n      <span translate>Read Only Wallet</span>\n      <ion-note item-end>\n        <span translate>No private key</span>\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span translate>Account</span>\n      <ion-note item-end>\n        #{{account}}\n      </ion-note>\n    </ion-item>\n    <ion-item-divider *ngIf="copayers">Copayers</ion-item-divider>\n    <ion-item *ngFor="let copayer of copayers">\n      <span>{{copayer.name}}</span>\n      <ion-note *ngIf="copayer.id == copayerId" item-end>\n        ({{\'Me\' | translate}})\n      </ion-note>\n    </ion-item>\n    <ion-item-divider>{{\'Extended Public Keys\' | translate}}</ion-item-divider>\n    <ion-item *ngFor="let pk of pubKeys; let i=index" copy-to-clipboard="{{pk}}">\n      <span>Copayer {{i}}</span>\n      <div padding-top>\n        <div text-wrap>\n          {{pk}}\n        </div>\n      </div>\n      <span *ngIf="i == 0">({{rootPath}})</span>\n    </ion-item>\n    <ion-item-divider *ngIf="balanceByAddress">Balance By Address</ion-item-divider>\n    <ion-item class="item" *ngFor="let a of balanceByAddress" copy-to-clipboard="{{a.address}}">\n      <span>{{a.address}}</span>\n      <ion-note item-end>\n        {{(a.amount / unitToSatoshi).toFixed(8)}} {{coin}}\n      </ion-note>\n    </ion-item>\n    <ion-item-divider></ion-item-divider>\n  </ion-list>\n</ion-content>\n'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-information/wallet-information.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */]])
], WalletInformationPage);

//# sourceMappingURL=wallet-information.js.map

/***/ }),

/***/ 1022:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletServiceUrlPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_splash_screen__ = __webpack_require__(425);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_replace_parameters_replace_parameters__ = __webpack_require__(101);






// native

// providers






let WalletServiceUrlPage = class WalletServiceUrlPage {
    constructor(profileProvider, navCtrl, navParams, configProvider, app, logger, persistenceProvider, formBuilder, events, splashScreen, platformProvider, replaceParametersProvider, translate) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.app = app;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.formBuilder = formBuilder;
        this.events = events;
        this.splashScreen = splashScreen;
        this.platformProvider = platformProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.success = false;
        this.walletServiceForm = this.formBuilder.group({
            bwsurl: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required])
            ]
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded:  WalletServiceUrlPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.defaults = this.configProvider.getDefaults();
        this.config = this.configProvider.get();
        let appName = this.app.info.nameCase;
        this.comment = this.replaceParametersProvider.replace(this.translate.instant("{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance)."), { appName });
        this.walletServiceForm.value.bwsurl =
            (this.config.bwsFor &&
                this.config.bwsFor[this.wallet.credentials.walletId]) ||
                this.defaults.bws.url;
    }
    resetDefaultUrl() {
        this.walletServiceForm.value.bwsurl = this.defaults.bws.url;
    }
    save() {
        let bws;
        switch (this.walletServiceForm.value.bwsurl) {
            case 'prod':
            case 'production':
                bws = 'https://bws.bitpay.com/bws/api';
                break;
            case 'sta':
            case 'staging':
                bws = 'https://bws-staging.b-pay.net/bws/api';
                break;
            case 'loc':
            case 'local':
                bws = 'http://localhost:3232/bws/api';
                break;
        }
        if (bws) {
            this.logger.info('Using BWS URL Alias to ' + bws);
            this.walletServiceForm.value.bwsurl = bws;
        }
        let opts = {
            bwsFor: {}
        };
        opts.bwsFor[this.wallet.credentials.walletId] = this.walletServiceForm.value.bwsurl;
        this.configProvider.set(opts);
        this.persistenceProvider.setCleanAndScanAddresses(this.wallet.credentials.walletId);
        this.events.publish('Local/ConfigUpdate', {
            walletId: this.wallet.credentials.walletId
        });
        this.navCtrl.popToRoot().then(() => {
            this.reload();
        });
    }
    reload() {
        window.location.reload();
        if (this.platformProvider.isCordova)
            this.splashScreen.show();
    }
};
WalletServiceUrlPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-service-url',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-service-url/wallet-service-url.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Wallet Service URL</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <ion-list>\n    <form [formGroup]="walletServiceForm">\n      <ion-item>\n        <ion-label stacked>Wallet Service URL</ion-label>\n        <ion-input type="text" formControlName="bwsurl" [value]="walletServiceForm.value.bwsurl" required></ion-input>\n      </ion-item>\n      <div class="explanation">\n        <span>{{comment}}</span>\n        <a (click)="resetDefaultUrl()" translate>\n          Use default url\n        </a>\n      </div>\n      <button ion-button class="button-standard" (click)="save()" [disabled]="!walletServiceForm.valid">\n        {{\'Save\' | translate}}\n      </button>\n    </form>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-service-url/wallet-service-url.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_6__ionic_native_splash_screen__["a" /* SplashScreen */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */]])
], WalletServiceUrlPage);

//# sourceMappingURL=wallet-service-url.js.map

/***/ }),

/***/ 1023:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletTransactionHistoryPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_papaparse__ = __webpack_require__(1989);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_papaparse___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_papaparse__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_wallet_wallet__ = __webpack_require__(32);






// Providers







let WalletTransactionHistoryPage = class WalletTransactionHistoryPage {
    constructor(profileProvider, navCtrl, navParams, configProvider, currencyProvider, logger, platformProvider, appProvider, translate, walletProvider, events) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.appProvider = appProvider;
        this.translate = translate;
        this.walletProvider = walletProvider;
        this.events = events;
        this.csvReady = false;
        this.csvContent = [];
    }
    ionViewDidLoad() {
        this.logger.info('Loaded:  WalletTransactionHistoryPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.currency = this.wallet.coin.toUpperCase();
        this.isCordova = this.platformProvider.isCordova;
        this.appName = this.appProvider.info.nameCase;
        this.config = this.configProvider.get();
        const { unitToSatoshi } = this.currencyProvider.getPrecision(this.wallet.coin);
        this.satToUnit = 1 / unitToSatoshi;
        this.csvHistory();
    }
    formatDate(date) {
        const dateObj = new Date(date);
        if (!dateObj) {
            this.logger.warn('Error formating a date');
            return 'DateError';
        }
        if (!dateObj.toJSON()) {
            return '';
        }
        return dateObj.toJSON();
    }
    // TODO : move this to walletService.
    csvHistory() {
        this.logger.info('Generating CSV from History');
        this.walletProvider
            .fetchTxHistory(this.wallet, null, {})
            .then(txs => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txs)) {
                this.logger.warn('Failed to generate CSV: no transactions');
                this.err = this.translate.instant('No transactions');
                return;
            }
            this.logger.debug('Wallet Transaction History Length:', txs.length);
            const data = txs;
            this.csvFilename = this.appName + '-' + this.wallet.name + '.csv';
            this.csvHeader = [
                'Date',
                'Destination',
                'Description',
                'Amount',
                'Currency',
                'Txid',
                'Creator',
                'Copayers',
                'Comment'
            ];
            let _amount, _note, _copayers, _creator, _comment;
            data.forEach(it => {
                let amount = it.amount;
                if (it.action == 'moved')
                    amount = 0;
                _copayers = '';
                _creator = '';
                if (it.actions && it.actions.length > 1) {
                    for (let i = 0; i < it.actions.length; i++) {
                        _copayers +=
                            it.actions[i].copayerName + ':' + it.actions[i].type + ' - ';
                    }
                    _creator =
                        it.creatorName && it.creatorName != 'undefined'
                            ? it.creatorName
                            : '';
                }
                _amount =
                    (it.action == 'sent' ? '-' : '') +
                        (amount * this.satToUnit).toFixed(8);
                _note = it.message || '';
                _comment = it.note ? it.note.body : '';
                if (it.action == 'moved')
                    _note += ' Moved:' + (it.amount * this.satToUnit).toFixed(8);
                this.csvContent.push({
                    Date: this.formatDate(it.time * 1000),
                    Destination: it.addressTo || '',
                    Description: _note,
                    Amount: _amount,
                    Currency: this.currency,
                    Txid: it.txid,
                    Creator: _creator,
                    Copayers: _copayers,
                    Comment: _comment
                });
                if (it.fees && (it.action == 'moved' || it.action == 'sent')) {
                    const _fee = (it.fees * this.satToUnit).toFixed(8);
                    this.csvContent.push({
                        Date: this.formatDate(it.time * 1000),
                        Destination: 'Bitcoin Network Fees',
                        Description: '',
                        Amount: '-' + _fee,
                        Currency: this.currency,
                        Txid: '',
                        Creator: '',
                        Copayers: ''
                    });
                }
            });
            this.csvReady = true;
        })
            .catch(err => {
            if (err == 'HISTORY_IN_PROGRESS') {
                this.logger.debug('History in progress: Trying again in 5 secs...');
                setTimeout(() => {
                    this.csvHistory();
                }, 5000);
                return;
            }
            this.logger.warn('Failed to generate CSV:', err);
            this.err = err;
        });
    }
    downloadCSV() {
        if (!this.csvReady)
            return;
        const csv = __WEBPACK_IMPORTED_MODULE_5_papaparse__["unparse"]({
            fields: this.csvHeader,
            data: this.csvContent
        });
        const blob = new Blob([csv]);
        const a = window.document.createElement('a');
        a.href = window.URL.createObjectURL(blob);
        a.download = this.csvFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
    clearTransactionHistory() {
        this.logger.info('Removing Transaction history ' + this.wallet.id);
        this.walletProvider.clearTxHistory(this.wallet);
        this.logger.info('Transaction history cleared for :' + this.wallet.id);
        this.navCtrl.popToRoot().then(() => {
            setTimeout(() => {
                this.events.publish('OpenWallet', this.wallet);
            }, 1000);
        });
    }
};
WalletTransactionHistoryPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-transaction-history',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-transaction-history/wallet-transaction-history.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Transaction History\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <ion-list>\n    <button ion-button class="button-standard" *ngIf="!isCordova" (click)="downloadCSV()" [disabled]="!csvReady">\n      <span *ngIf="csvReady" translate>Export to file</span>\n      <span *ngIf="!csvReady && !err">\n        {{\'preparing...\' | translate}}\n      </span>\n      <span *ngIf="!csvReady && err">\n        {{err}}\n      </span>\n    </button>\n\n    <div class="explanation" translate>\n      The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server\n    </div>\n    <button ion-button class="button-standard" color="danger" (click)="clearTransactionHistory()">\n      <span translate>Clear cache</span>\n    </button>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-transaction-history/wallet-transaction-history.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_12__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */]])
], WalletTransactionHistoryPage);

//# sourceMappingURL=wallet-transaction-history.js.map

/***/ }),

/***/ 1024:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletGroupDeletePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_push_notifications_push_notifications__ = __webpack_require__(115);




// providers






let WalletGroupDeletePage = class WalletGroupDeletePage {
    constructor(profileProvider, navCtrl, navParams, popupProvider, onGoingProcessProvider, logger, translate, keyProvider, pushNotificationsProvider, events) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger = logger;
        this.translate = translate;
        this.keyProvider = keyProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.events = events;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletGroupDeletePage');
    }
    ionViewWillEnter() {
        this.keyId = this.navParams.data.keyId;
        this.walletsGroup = this.profileProvider.getWalletGroup(this.keyId);
    }
    showDeletePopup() {
        const title = this.translate.instant('Warning!');
        const message = this.translate.instant('Are you sure you want to delete all wallets using this key?');
        this.popupProvider.ionicConfirm(title, message, null, null).then(res => {
            if (res)
                this.deleteWalletGroup();
        });
    }
    deleteWalletGroup() {
        this.onGoingProcessProvider.set('deletingWallet');
        this.profileProvider.removeProfileLegacy();
        const opts = {
            keyId: this.keyId,
            showHidden: true
        };
        const wallets = this.profileProvider.getWalletsFromGroup(opts);
        this.profileProvider
            .deleteWalletGroup(this.keyId, wallets)
            .then(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.onGoingProcessProvider.clear();
            wallets.forEach(wallet => {
                this.pushNotificationsProvider.unsubscribe(wallet);
            });
            const keyInUse = this.profileProvider.isKeyInUse(this.keyId);
            if (!keyInUse) {
                this.keyProvider.removeKey(this.keyId);
                delete this.profileProvider.walletsGroups[this.keyId];
                this.goHome();
            }
            else {
                this.logger.warn('Key was not removed. Still in use');
                this.goHome();
            }
        }))
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.warn('Could not remove all wallet data: ', err);
            this.popupProvider.ionicAlert(this.translate.instant('Error'), err.message || err);
        });
    }
    goHome() {
        this.events.publish('Local/WalletListChange');
        setTimeout(() => {
            this.navCtrl.popToRoot();
        }, 1000);
    }
};
WalletGroupDeletePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-group-delete',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-delete/wallet-group-delete.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Delete key\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <h3 class="assertive" translate>Warning!</h3>\n  <p translate>\n    Permanently delete all wallets using this key.\n  </p>\n  <p translate>\n    THIS ACTION CANNOT BE REVERSED\n  </p>\n  <button ion-button class="button-standard" color="danger" (click)="showDeletePopup()">\n    {{\'Delete\' | translate}}\n  </button>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-delete/wallet-group-delete.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */]])
], WalletGroupDeletePage);

//# sourceMappingURL=wallet-group-delete.js.map

/***/ }),

/***/ 1025:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletGroupExtendedPrivateKeyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(15);




// providers





let WalletGroupExtendedPrivateKeyPage = class WalletGroupExtendedPrivateKeyPage {
    constructor(profileProvider, logger, navParams, navCtrl, actionSheetProvider, translate, bwcErrorProvider, keyProvider) {
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.actionSheetProvider = actionSheetProvider;
        this.translate = translate;
        this.bwcErrorProvider = bwcErrorProvider;
        this.keyProvider = keyProvider;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletExtendedPrivateKeyPage');
    }
    ionViewWillEnter() {
        this.keyId = this.navParams.data.keyId;
        this.walletsGroup = this.profileProvider.getWalletGroup(this.keyId);
        this.keysEncrypted = this.walletsGroup.isPrivKeyEncrypted;
    }
    ionViewDidEnter() {
        this.keyProvider
            .handleEncryptedWallet(this.keyId)
            .then((password) => {
            const keys = this.keyProvider.get(this.keyId, password);
            this.xPrivKey = keys.xPrivKey;
            this.keysEncrypted = false;
        })
            .catch(err => {
            if (err && err.message != 'PASSWORD_CANCELLED') {
                let title = this.translate.instant('Could not decrypt wallet');
                this.showErrorInfoSheet(this.bwcErrorProvider.msg(err), title);
            }
            this.navCtrl.pop();
        });
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.error('Could not get keys:', err);
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: err, title: infoSheetTitle });
        errorInfoSheet.present();
    }
};
WalletGroupExtendedPrivateKeyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-group-extended-private-key',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-extended-private-key/wallet-group-extended-private-key.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Extended Private Key\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <div class="container">\n    <h3 translate>Warning!</h3>\n    <div class="warning-message">\n      <p translate>\n        Your extended private keys are all that is needed to access your funds. Be sure to protect your private keys and store them only on secure devices. BitPay does not have access to your private keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach. Only advanced users should handle extended private keys directly.\n      </p>\n    </div>\n    <div *ngIf="!keysEncrypted">\n      <button ion-button class="button-standard" copy-to-clipboard="{{xPrivKey}}">\n        {{\'Copy to clipboard\' | translate}}\n      </button>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-extended-private-key/wallet-group-extended-private-key.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_key_key__["a" /* KeyProvider */]])
], WalletGroupExtendedPrivateKeyPage);

//# sourceMappingURL=wallet-group-extended-private-key.js.map

/***/ }),

/***/ 1026:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletGroupQrExportPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__ = __webpack_require__(15);




// providers






let WalletGroupQrExportPage = class WalletGroupQrExportPage {
    constructor(profileProvider, logger, navParams, navCtrl, actionSheetProvider, translate, bwcErrorProvider, keyProvider, appProvider) {
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.actionSheetProvider = actionSheetProvider;
        this.translate = translate;
        this.bwcErrorProvider = bwcErrorProvider;
        this.keyProvider = keyProvider;
        this.appProvider = appProvider;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletQrExportPage');
    }
    ionViewWillEnter() {
        this.keyId = this.navParams.data.keyId;
        this.walletsGroup = this.profileProvider.getWalletGroup(this.keyId);
        this.keysEncrypted = this.walletsGroup.isPrivKeyEncrypted;
        this.appName = this.appProvider.info.nameCase;
    }
    ionViewDidEnter() {
        this.keyProvider
            .handleEncryptedWallet(this.keyId)
            .then((password) => {
            const keys = this.keyProvider.get(this.keyId, password);
            this.keysEncrypted = false;
            this.generateQrCode(keys);
        })
            .catch(err => {
            if (err && err.message != 'PASSWORD_CANCELLED') {
                let title = this.translate.instant('Could not decrypt wallet');
                this.showErrorInfoSheet(this.bwcErrorProvider.msg(err), title);
            }
            this.navCtrl.pop();
        });
    }
    generateQrCode(keys) {
        if (!keys || !keys.mnemonic) {
            const err = this.translate.instant('Exporting via QR not supported for this wallet');
            const title = this.translate.instant('Error');
            this.showErrorInfoSheet(err, title);
            return;
        }
        const mnemonicHasPassphrase = this.keyProvider.mnemonicHasPassphrase(this.keyId);
        this.code =
            '1|' + keys.mnemonic + '|null|null|' + mnemonicHasPassphrase + '|null';
        this.logger.debug('QR code generated. mnemonicHasPassphrase: ' + mnemonicHasPassphrase);
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.error('Could not get keys:', err);
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: err, title: infoSheetTitle });
        errorInfoSheet.present();
    }
};
WalletGroupQrExportPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-group-qr-export',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-qr-export/wallet-group-qr-export.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Export key\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <div class="container">\n    <h3 translate>Warning!</h3>\n    <div class="warning-message">\n      <p translate>\n        Your Key is all that is needed to access your funds. Be sure to protect your key and store it only on secure devices. BitPay does not have access to your keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach.\n      </p>\n      <p>\n        {{ \'You can import this Key into other devices through the {appName} scanner\' | translate: {appName: appName} }}\n      </p>\n    </div>\n    <div *ngIf="!keysEncrypted">\n      <ngx-qrcode *ngIf="code" hide-toast="true" qrc-value="{{code}}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n      <span *ngIf="walletsGroup && code">{{ walletsGroup.name }}</span>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-qr-export/wallet-group-qr-export.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */]])
], WalletGroupQrExportPage);

//# sourceMappingURL=wallet-group-qr-export.js.map

/***/ }),

/***/ 1027:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CopayersPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_push_notifications_push_notifications__ = __webpack_require__(115);




// Native

// Providers









let CopayersPage = CopayersPage_1 = class CopayersPage {
    constructor(plt, appProvider, events, logger, navParams, platformProvider, popupProvider, profileProvider, socialSharing, onGoingProcessProvider, translate, pushNotificationsProvider, viewCtrl, actionSheetProvider, keyProvider) {
        this.plt = plt;
        this.appProvider = appProvider;
        this.events = events;
        this.logger = logger;
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.socialSharing = socialSharing;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.translate = translate;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.viewCtrl = viewCtrl;
        this.actionSheetProvider = actionSheetProvider;
        this.keyProvider = keyProvider;
        this.secret = null;
        this.appName = this.appProvider.info.userVisibleName;
        this.appUrl = this.appProvider.info.url;
        this.isCordova = this.platformProvider.isCordova;
        this.copayers = [];
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CopayersPage');
        this.onResumeSubscription = this.plt.resume.subscribe(() => {
            this.events.publish('Local/WalletFocus', {
                walletId: this.wallet.credentials.walletId
            });
            this.subscribeEvents();
        });
        this.onPauseSubscription = this.plt.pause.subscribe(() => {
            this.unsubscribeEvents();
        });
    }
    ionViewWillEnter() {
        this.events.publish('Local/WalletFocus', {
            walletId: this.wallet.credentials.walletId
        });
        this.subscribeEvents();
    }
    ionViewWillLeave() {
        this.unsubscribeEvents();
    }
    ngOnDestroy() {
        this.events.publish('Local/WalletListChange');
        this.onResumeSubscription.unsubscribe();
        this.onPauseSubscription.unsubscribe();
    }
    subscribeEvents() {
        this.events.subscribe('Local/WalletUpdate', this.walletUpdate.bind(this));
    }
    unsubscribeEvents() {
        this.events.unsubscribe('Local/WalletUpdate', this.walletUpdate.bind(this));
    }
    close() {
        this.viewCtrl.dismiss();
    }
    walletUpdate(opts) {
        if (!opts.finished)
            return;
        if (this.wallet && opts.walletId == this.wallet.id) {
            this.copayers = this.wallet.cachedStatus.wallet.copayers;
            this.secret = this.wallet.cachedStatus.wallet.secret;
            if (this.wallet.cachedStatus.wallet.status == 'complete' &&
                !CopayersPage_1.processed[opts.walletId]) {
                CopayersPage_1.processed[opts.walletId] = true;
                // TODO?
                this.wallet.openWallet(err => {
                    if (err)
                        this.logger.error(err);
                    this.viewCtrl.dismiss().then(() => {
                        this.events.publish('Local/WalletListChange');
                        this.events.publish('OpenWallet', this.wallet);
                    });
                });
            }
        }
    }
    showDeletePopup() {
        let title = this.translate.instant('Confirm');
        let msg = this.translate.instant('Are you sure you want to cancel and delete this wallet?');
        this.popupProvider.ionicConfirm(title, msg).then(res => {
            if (res)
                this.deleteWallet();
        });
    }
    deleteWallet() {
        this.onGoingProcessProvider.set('deletingWallet');
        this.profileProvider
            .deleteWalletClient(this.wallet)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.pushNotificationsProvider.unsubscribe(this.wallet);
            const keyId = this.wallet.credentials.keyId;
            if (keyId) {
                const keyInUse = this.profileProvider.isKeyInUse(keyId);
                if (!keyInUse) {
                    this.keyProvider.removeKey(keyId);
                    delete this.profileProvider.walletsGroups[keyId];
                }
                else {
                    this.logger.warn('Key was not removed. Still in use');
                }
            }
            this.dismiss();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            let errorText = this.translate.instant('Error');
            this.popupProvider.ionicAlert(errorText, err.message || err);
        });
    }
    dismiss() {
        this.events.publish('Local/WalletListChange');
        setTimeout(() => {
            this.viewCtrl.dismiss();
        }, 1000);
    }
    showFullInfo() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('copayers', {
            secret: this.secret
        });
        infoSheet.present();
    }
    shareAddress() {
        this.socialSharing.share(this.secret);
    }
};
CopayersPage.processed = {};
CopayersPage = CopayersPage_1 = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-copayers',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/add/copayers/copayers.html"*/'<ion-header class="wallet-details-header">\n  <ion-navbar class="app-color">\n    <ion-buttons left>\n      <button class="modal-close-button" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n    <ion-title>\n      {{ wallet.name }} [<span translate>{{wallet.m}}-of-{{wallet.n}}</span>]\n    </ion-title>\n    <ion-buttons right>\n      <button *ngIf="wallet.notAuthorized || (!wallet.notAuthorized && secret)" ion-button (click)="showDeletePopup()" translate>\n        Cancel\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div *ngIf="!wallet.notAuthorized" class="copayers-header">\n    <div class="copayers-header-content">\n      <div class="title" translate>Wallet Invitation</div>\n      <div class="text" translate>Share this address with the devices joining this account.</div>\n      <div class="text" translate>Each copayer has their own recovery phrase. To recover funds stored in a Shared Wallet you will need the recovery phrase from each copayer.</div>\n    </div>\n  </div>\n  <div class="qr-container" *ngIf="!wallet.notAuthorized && secret">\n    <div class="card qr-card">\n      <img class="copy-icon" copy-to-clipboard="{{ secret }}" src="assets/img/paste-clipboard.svg" width="18" />\n      <ngx-qrcode (click)="showFullInfo()" class="qr-code" hide-toast="true" copy-to-clipboard="{{ secret }}" qrc-value="{{secret}}" qrc-class="aclass" qrc-errorCorrectionLevel="L"></ngx-qrcode>\n    </div>\n  </div>\n\n  <div class="white-card" *ngIf="!wallet.notAuthorized && copayers && secret">\n    <span class="title">{{\'Waiting for authorized copayers to join\' | translate}}</span>\n    <div class="timeline-item" *ngFor="let copayer of copayers; let i = index">\n      <div class="timeline-content">\n        <div class="timeline-content-icon">\n          <div class="line" *ngIf="copayers.length < wallet.n">\n            <ion-icon name="checkmark" item-end color="success"></ion-icon>\n          </div>\n        </div>\n        <div class="timeline-content-label ellipsis">\n          <div *ngIf="copayer.id == wallet.copayerId" class="name ellipsis">{{\'Me\'|translate}}</div>\n          <div *ngIf="copayer.id != wallet.copayerId" class="name ellipsis">{{copayer.name}}</div>\n        </div>\n      </div>\n    </div>\n    <div class="timeline-item" *ngIf="!wallet.isComplete() && copayers.length < wallet.n">\n      <div class="timeline-content">\n        <div class="timeline-content-icon">\n          <div class="line no-border">\n            <ion-icon name="ios-time-outline" item-end></ion-icon>\n          </div>\n        </div>\n        <div class="timeline-content-label ellipsis">\n          <div class="name ellipsis">{{\'Waiting\'|translate}}</div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <button class="share-button" *ngIf="isCordova && !wallet.notAuthorized" ion-button clear (click)="shareAddress()">\n    {{ \'Share this invitation with your copayers\' | translate }}\n    &rarr;\n  </button>\n\n  <div class="error-msg" *ngIf="wallet.notAuthorized" padding>\n    <h3 class="assertive" translate>Wallet incomplete and broken</h3>\n    <div translate>Delete it and create a new one</div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/add/copayers/copayers.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_13__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_key_key__["a" /* KeyProvider */]])
], CopayersPage);

var CopayersPage_1;
//# sourceMappingURL=copayers.js.map

/***/ }),

/***/ 1028:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FingerprintModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_touchid_touchid__ = __webpack_require__(173);



// Providers

let FingerprintModalPage = class FingerprintModalPage {
    constructor(touchid, platform, viewCtrl) {
        this.touchid = touchid;
        this.platform = platform;
        this.viewCtrl = viewCtrl;
        this.unregister = this.platform.registerBackButtonAction(() => { });
        this.checkFingerprint();
    }
    checkFingerprint() {
        this.touchid.check().then(() => {
            this.unregister();
            this.viewCtrl.dismiss();
        });
    }
};
FingerprintModalPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-fingerprint',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/fingerprint/fingerprint.html"*/'<ion-content no-bounce fullscreen>\n  <div class="fingerprint-header">\n    <div class="title">\n      <div>\n        {{\'Unlock App\' | translate}}\n      </div>\n    </div>\n    <div class="icon-container">\n      <ion-icon class="app-icon">\n        <img src="assets/img/app/icon-flat.svg" />\n      </ion-icon>\n    </div>\n  </div>\n  <div class="fingerprint-bottom">\n    <button class="button-standard" ion-button (click)="checkFingerprint()">\n      <span>{{\'Scan again\' | translate}}</span>\n      <ion-icon name="finger-print" item-end></ion-icon>\n    </button>\n  </div>\n\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/fingerprint/fingerprint.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_touchid_touchid__["a" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["q" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */]])
], FingerprintModalPage);

//# sourceMappingURL=fingerprint.js.map

/***/ }),

/***/ 1029:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SelectInvoicePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers__ = __webpack_require__(35);




// Provider

let SelectInvoicePage = class SelectInvoicePage {
    constructor(currencyProvider, incomingDataProvider, logger, navParams) {
        this.currencyProvider = currencyProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.paymentOptions = this.navParams.data.payProOptions.paymentOptions;
        this.payProUrl = this.navParams.data.payProOptions.payProUrl;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SelectInvoicePage');
    }
    getCoinName(currency) {
        const coin = currency.toLowerCase();
        return this.currencyProvider.getCoinName(coin);
    }
    goToPayPro(currency) {
        const coin = currency.toLowerCase();
        this.incomingDataProvider.goToPayPro(this.payProUrl, coin);
    }
};
SelectInvoicePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'select-invoice-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/invoice/select-invoice/select-invoice.html"*/'<wide-header-page title="Select Currency">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <div *ngFor="let option of paymentOptions">\n        <button class="list-button" ion-item (click)="goToPayPro(option.currency)">\n          <ion-icon item-start>\n            <img src="assets/img/currencies/{{option.currency.toLowerCase()}}.svg" />\n          </ion-icon>\n          <div class="item-title">{{ getCoinName(option.currency.toLowerCase()) }}</div>\n          <span class="alternative">{{option.estimatedAmount | satToUnit: option.currency.toLowerCase()}} ~ {{option.estimatedAmount | satToFiat: option.currency.toLowerCase()}}</span>\n        </button>\n     </div>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/invoice/select-invoice/select-invoice.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers__["r" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["H" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */]])
], SelectInvoicePage);

//# sourceMappingURL=select-invoice.js.map

/***/ }),

/***/ 1030:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OnboardingPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pages_onboarding_disclaimer_disclaimer__ = __webpack_require__(475);




// pages

let OnboardingPage = class OnboardingPage {
    constructor(navCtrl, logger) {
        this.navCtrl = navCtrl;
        this.logger = logger;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: OnboardingPage');
    }
    getStarted() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__pages_onboarding_disclaimer_disclaimer__["a" /* DisclaimerPage */]);
    }
};
OnboardingPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-onboarding',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/onboarding/onboarding.html"*/'<ion-content no-bounce>\n  <div class="logo-tagline">\n    <img src=\'assets/img/app/logo-negative.svg\' />\n  </div>\n  <div class="bottom-absolute">\n    <button ion-button class="button-standard" (click)="getStarted()">\n      {{\'Get started\' | translate}}\n    </button>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/onboarding/onboarding.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */], __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], OnboardingPage);

//# sourceMappingURL=onboarding.js.map

/***/ }),

/***/ 1031:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_address_book_address_book__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_filter_filter__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_rate_rate__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_tx_confirm_notification_tx_confirm_notification__ = __webpack_require__(466);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_wallet_wallet__ = __webpack_require__(32);







// Providers













let TxDetailsPage = class TxDetailsPage {
    constructor(addressBookProvider, configProvider, currencyProvider, events, externalLinkProvider, logger, navCtrl, navParams, onGoingProcess, popupProvider, profileProvider, txConfirmNotificationProvider, txFormatProvider, walletProvider, translate, filter, rateProvider, platformProvider, statusBar) {
        this.addressBookProvider = addressBookProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcess = onGoingProcess;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.txConfirmNotificationProvider = txConfirmNotificationProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.filter = filter;
        this.rateProvider = rateProvider;
        this.platformProvider = platformProvider;
        this.statusBar = statusBar;
        this.bwsEventHandler = (_, type, n) => {
            let match = false;
            if (type == 'NewBlock' &&
                n &&
                n.data &&
                this.wallet &&
                n.data &&
                n.data.network == this.wallet.network &&
                n.data.coin == this.wallet.coin) {
                match = true;
                this.updateTxDebounced({ hideLoading: true });
            }
            this.logger.debug('bwsEvent handler @tx-details. Matched: ' + match);
        };
        this.updateTxDebounced = __WEBPACK_IMPORTED_MODULE_5_lodash__["debounce"](this.updateTx, 1000);
    }
    ionViewWillEnter() {
        if (this.platformProvider.isCordova) {
            this.statusBar.styleDefault();
        }
    }
    ionViewWillLeave() {
        if (this.platformProvider.isCordova) {
            this.statusBar.styleBlackOpaque();
        }
    }
    ionViewDidLoad() {
        this.config = this.configProvider.get();
        this.txId = this.navParams.data.txid;
        this.title = this.translate.instant('Transaction');
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.color = this.wallet.color;
        this.copayerId = this.wallet.credentials.copayerId;
        this.isShared = this.wallet.credentials.n > 1;
        this.txsUnsubscribedForNotifications = this.config.confirmedTxsNotifications
            ? !this.config.confirmedTxsNotifications.enabled
            : true;
        let defaults = this.configProvider.getDefaults();
        this.blockexplorerUrl = defaults.blockExplorerUrl[this.wallet.coin];
        this.txConfirmNotificationProvider.checkIfEnabled(this.txId).then(res => {
            this.txNotification = {
                value: res
            };
        });
        this.updateTx();
    }
    ionViewWillLoad() {
        this.events.subscribe('bwsEvent', this.bwsEventHandler);
    }
    ionViewWillUnload() {
        this.events.unsubscribe('bwsEvent', this.bwsEventHandler);
    }
    readMore() {
        let url = 'https://support.bitpay.com/hc/en-us/articles/115004497783-What-does-the-BitPay-wallet-s-warning-amount-too-low-to-spend-mean-';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Read more in our support page');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    updateMemo() {
        this.walletProvider
            .getTxNote(this.wallet, this.btx.txid)
            .then(note => {
            if (!note || note.body == '')
                return;
            this.btx.note = note;
        })
            .catch(err => {
            this.logger.warn('Could not fetch transaction note: ' + err);
            return;
        });
    }
    initActionList() {
        this.actionList = [];
        if ((this.btx.action != 'sent' && this.btx.action != 'moved') ||
            !this.isShared)
            return;
        let actionDescriptions = {
            created: this.translate.instant('Proposal Created'),
            accept: this.translate.instant('Accepted'),
            reject: this.translate.instant('Rejected'),
            broadcasted: this.translate.instant('Broadcasted')
        };
        this.actionList.push({
            type: 'created',
            time: this.btx.createdOn,
            description: actionDescriptions.created,
            by: this.btx.creatorName
        });
        __WEBPACK_IMPORTED_MODULE_5_lodash__["each"](this.btx.actions, action => {
            this.actionList.push({
                type: action.type,
                time: action.createdOn,
                description: actionDescriptions[action.type],
                by: action.copayerName
            });
        });
        this.actionList.push({
            type: 'broadcasted',
            time: this.btx.time,
            description: actionDescriptions.broadcasted
        });
        setTimeout(() => {
            this.actionList.reverse();
        }, 10);
    }
    updateTx(opts) {
        opts = opts ? opts : {};
        if (!opts.hideLoading)
            this.onGoingProcess.set('loadingTxInfo');
        this.walletProvider
            .getTx(this.wallet, this.txId)
            .then(tx => {
            if (!opts.hideLoading)
                this.onGoingProcess.clear();
            this.btx = this.txFormatProvider.processTx(this.wallet.coin, tx);
            const chain = this.currencyProvider
                .getChain(this.wallet.coin)
                .toLowerCase();
            this.btx.feeFiatStr = this.txFormatProvider.formatAlternativeStr(chain, tx.fees);
            if (this.currencyProvider.isUtxoCoin(this.wallet.coin)) {
                this.btx.feeRateStr =
                    ((this.btx.fees / (this.btx.amount + this.btx.fees)) * 100).toFixed(2) + '%';
            }
            if (!this.btx.note) {
                this.txMemo = this.btx.message;
            }
            if (this.btx.note && this.btx.note.body) {
                this.txMemo = this.btx.note.body;
            }
            if (this.btx.action != 'invalid') {
                if (this.btx.action == 'sent')
                    this.title = this.translate.instant('Sent Funds');
                if (this.btx.action == 'received')
                    this.title = this.translate.instant('Received Funds');
                if (this.btx.action == 'moved')
                    this.title = this.translate.instant('Moved Funds');
            }
            this.updateMemo();
            this.initActionList();
            this.contact();
            this.updateFiatRate();
            if (this.currencyProvider.isUtxoCoin(this.wallet.coin)) {
                this.walletProvider
                    .getLowAmount(this.wallet)
                    .then((amount) => {
                    this.btx.lowAmount = tx.amount < amount;
                })
                    .catch(err => {
                    this.logger.warn('Error getting low amounts: ' + err);
                    return;
                });
            }
        })
            .catch(err => {
            if (!opts.hideLoading)
                this.onGoingProcess.clear();
            this.logger.warn('Error getting transaction: ' + err);
            this.navCtrl.pop();
            return this.popupProvider.ionicAlert('Error', this.translate.instant('Transaction not available at this time'));
        });
    }
    saveMemoInfo() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.logger.info('Saving memo: ', this.txMemo);
            this.btx.note = {
                body: this.txMemo
            };
            let args = {
                txid: this.btx.txid,
                body: this.txMemo
            };
            yield this.walletProvider
                .editTxNote(this.wallet, args)
                .catch((err) => {
                this.logger.error('Could not save tx comment ' + err);
            });
            this.logger.info('Tx Note edited');
        });
    }
    viewOnBlockchain() {
        let btx = this.btx;
        let url = 'https://' +
            this.blockexplorerUrl +
            (this.getShortNetworkName() == 'test' ? 'testnet/' : 'mainnet/') +
            'tx/' +
            btx.txid;
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Transaction on Insight');
        let okText = this.translate.instant('Open Insight');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    getShortNetworkName() {
        let n = this.wallet.credentials.network;
        return n.substring(0, 4);
    }
    txConfirmNotificationChange() {
        if (this.txNotification.value) {
            this.txConfirmNotificationProvider.subscribe(this.wallet, {
                txid: this.txId
            });
        }
        else {
            this.txConfirmNotificationProvider.unsubscribe(this.wallet, this.txId);
        }
    }
    contact() {
        let addr = this.btx.addressTo;
        this.addressBookProvider
            .get(addr)
            .then(ab => {
            if (ab) {
                let name = __WEBPACK_IMPORTED_MODULE_5_lodash__["isObject"](ab) ? ab.name : ab;
                this.contactName = name;
            }
        })
            .catch(err => {
            this.logger.warn(err);
        });
    }
    openExternalLink(url) {
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Help and support information is available at the website.');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    updateFiatRate() {
        const settings = this.configProvider.get().wallet.settings;
        this.rateProvider
            .getHistoricFiatRate(settings.alternativeIsoCode, this.wallet.coin, (this.btx.time * 1000).toString())
            .then(fiat => {
            if (fiat && fiat.rate) {
                this.btx.fiatRateStr =
                    this.filter.formatFiatAmount(parseFloat((fiat.rate * this.btx.amountValueStr).toFixed(2))) +
                        ' ' +
                        settings.alternativeIsoCode +
                        ' @ ' +
                        this.filter.formatFiatAmount(fiat.rate) +
                        ' USD per ' +
                        this.wallet.coin.toUpperCase();
            }
            else {
                this.btx.fiatRateStr = this.btx.alternativeAmountStr;
            }
        });
    }
};
TxDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-tx-details',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/tx-details/tx-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{title | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-list *ngIf="btx">\n    <ion-item>\n      <div class="header-container">\n        <div class="sending-label" *ngIf="btx.confirmations > 0">\n          <span *ngIf="btx.action === \'sent\'" translate>Sent</span>\n          <span *ngIf="btx.action === \'received\'" translate>Received</span>\n          <span *ngIf="btx.action === \'moved\'" translate>Moved</span>\n        </div>\n        <div class="sending-label" *ngIf="btx.confirmations === 0">\n          <span *ngIf="btx.action == \'sent\'" translate>Sending</span>\n          <span *ngIf="btx.action == \'moved\'" translate>Moving</span>\n          <span *ngIf="btx.action == \'received\'" translate>Receiving</span>\n        </div>\n        <div class="amount-label">\n          <div class="amount">\n            <div>\n              {{btx.amountValueStr}}\n              <span class="amount-coin">{{btx.amountUnitStr}}</span>\n            </div>\n            <span *ngIf="btx.confirmations > 0">\n              <img class="sending-img" src="assets/img/tx-action/icon-sent.svg" width="40" *ngIf="btx.action === \'sent\'">\n              <img class="sending-img" src="assets/img/tx-action/icon-received.svg" width="40" *ngIf="btx.action === \'received\'">\n              <img class="sending-img" src="assets/img/tx-action/icon-moved.svg" width="40" *ngIf="btx.action === \'moved\'">\n            </span>\n            <span *ngIf="btx.confirmations === 0">\n              <img class="sending-img" src="assets/img/tx-action/icon-confirming.svg">\n            </span>\n          </div>\n          <div class="alternative">\n            <span *ngIf="!btx.fiatRateStr">...</span>\n            <span *ngIf="btx.fiatRateStr">{{btx.fiatRateStr}}</span>\n          </div>\n        </div>\n      </div>\n    </ion-item>\n\n    <label-tip class="low-fees" type="warn" *ngIf="btx.action == \'received\' && btx.lowAmount">\n      <span label-tip-title translate>Amount Too Low To Spend</span>\n      <div label-tip-body translate>\n        This transaction amount is too small compared to current Bitcoin network fees. Spending these funds will need a Bitcoin network fee cost comparable to the funds itself.\n        <br>\n        <a class="label-tip-link" (click)="readMore()" translate>Learn More</a>\n      </div>\n    </label-tip>\n\n    <ion-item class="container-tx-info" [ngClass]="{\'with-label\': btx.action == \'received\' && btx.lowFees}" *ngIf="btx && btx.feeStr && btx.action != \'received\'">\n      <span>{{\'Miner fee:\' | translate}}</span>\n      <div class="tx-info">\n        <span class="ellipsis comment">\n          <div>{{btx.feeStr}}</div>\n          <div>\n            {{btx.feeFiatStr}} &middot;\n            <span *ngIf="btx.feeRateStr">{{btx.feeRateStr}}\n              <span translate> of total amount</span>\n            </span>\n          </div>\n        </span>\n      </div>\n    </ion-item>\n\n    <label-tip *ngIf="btx.action == \'received\' && btx.lowFees" type="danger">\n      <span label-tip-title translate>Low Fee</span>\n      <div label-tip-body translate>\n        This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender.\n      </div>\n    </label-tip>\n\n    <page-multiple-outputs *ngIf="btx.action === \'sent\'" [tx]="btx"></page-multiple-outputs>\n\n    <ion-item class="container-tx-info" *ngIf="btx.action != \'received\' && isShared">\n      <span>{{\'Created by\' | translate}}</span>\n      <div class="tx-info">\n        <span class="ellipsis comment">\n          {{btx.creatorName}}\n        </span>\n      </div>\n    </ion-item>\n\n    <ion-item class="container-tx-info" *ngIf="btx.ts || btx.createdOn || btx.time">\n      <span>{{\'Date\' | translate}}</span>\n      <div class="tx-info">\n        <span class="ellipsis comment">\n          <time>{{ (btx.ts || btx.createdOn || btx.time) * 1000 | amDateFormat:\'MM/DD/YYYY hh:mm a\'}}</time>\n        </span>\n      </div>\n    </ion-item>\n\n    <ion-item class="container-tx-info">\n      <span>{{\'Confirmations\' | translate}}</span>\n      <div class="tx-info">\n        <span class="ellipsis comment" *ngIf="!btx.confirmations || btx.confirmations == 0" translate>\n          Unconfirmed\n          <span *ngIf="btx.feeRate">(\n            <span translate>Fee rate</span>:\n            {{btx.feeRate}})\n          </span>\n        </span>\n        <span class="ellipsis comment" *ngIf="btx.confirmations>0 && !btx.safeConfirmed">\n          {{btx.confirmations}}\n        </span>\n        <span class="ellipsis comment" *ngIf="btx.safeConfirmed">\n          {{btx.safeConfirmed}}\n        </span>\n      </div>\n    </ion-item>\n\n    <div *ngIf="!btx.confirmations || btx.confirmations == 0" class="unconfirmed-message">\n      <a class="positive" (click)="openExternalLink(\'https://support.bitpay.com/hc/en-us/articles/360025484512-Missing-transactions-Why-is-my-transaction-unconfirmed-\')">\n        {{\'Why is my transaction unconfirmed?\' | translate}}\n      </a>\n    </div>\n\n    <ion-item>\n      <ion-label stacked>{{\'Memo\' | translate}}</ion-label>\n      <ion-textarea placeholder="{{\'Enter a transaction memo\' | translate}}" (ionBlur)="saveMemoInfo()" [(ngModel)]="txMemo" name="tx.description" autocomplete="off" autocorrect="off"></ion-textarea>\n    </ion-item>\n\n    <ion-item class="container-tx-info">\n      <span translate>Transaction ID</span>\n      <div class="tx-info">\n        <div class="ellipsis id" copy-to-clipboard="{{ btx.txid }}">\n          <span>{{ btx.txid }}</span>\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="txsUnsubscribedForNotifications">\n      <ion-label>{{\'Notify me if confirmed\' | translate}}</ion-label>\n      <ion-toggle checked="false" *ngIf="!btx.confirmations || btx.confirmations == 0" [(ngModel)]="txNotification.value" (ionChange)="txConfirmNotificationChange()"></ion-toggle>\n    </ion-item>\n\n    <div *ngIf="actionList && actionList[0]">\n      <ion-item detail-none>\n        <div>{{\'Timeline\' | translate}}</div>\n      </ion-item>\n      <div class="timeline-item" [ngClass]="{\'action-created\' : a.type == \'created\' || a.type == \'accept\', \'action-rejected\' : a.type == \'reject\'}" *ngFor="let a of actionList; let i = index">\n        <div class="timeline-content">\n          <div class="timeline-content-icon">\n            <div class="rejected" *ngIf="a.type === \'reject\'">!</div>\n            <img src="assets/img/icon-broadcasted.svg" *ngIf="a.type === \'broadcasted\'">\n            <div class="line" *ngIf="a.type !== \'reject\' && a.type !== \'broadcasted\'">{{actionList.length - i}}</div>\n          </div>\n          <div class="timeline-content-label">\n            <div class="action">{{a.description}}</div>\n            <div class="name">{{a.by}}</div>\n          </div>\n          <ion-note class="ellipsis">\n            <time>{{ a.time * 1000 | amTimeAgo}}</time>\n          </ion-note>\n        </div>\n      </div>\n    </div>\n\n    <div text-center padding>\n      <button ion-button clear (click)="viewOnBlockchain()">\n        {{\'View on blockchain\' | translate}}\n      </button>\n    </div>\n\n  </ion-list>\n\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/tx-details/tx-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_12__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_tx_confirm_notification_tx_confirm_notification__["a" /* TxConfirmNotificationProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_11__providers_filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */]])
], TxDetailsPage);

//# sourceMappingURL=tx-details.js.map

/***/ }),

/***/ 1032:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SearchTxModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_time_time__ = __webpack_require__(148);




// Providers



let SearchTxModalPage = class SearchTxModalPage {
    constructor(giftCardProvider, navParams, platformProvider, timeProvider, viewCtrl) {
        this.giftCardProvider = giftCardProvider;
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.timeProvider = timeProvider;
        this.viewCtrl = viewCtrl;
        this.throttleSearch = __WEBPACK_IMPORTED_MODULE_3_lodash__["throttle"]((search) => {
            this.txHistorySearchResults = this.filter(search).slice(0, this.HISTORY_SHOW_LIMIT);
        }, 1000);
        this.HISTORY_SHOW_LIMIT = 10;
        this.currentTxHistoryPage = 0;
        this.txHistorySearchResults = [];
        this.isCordova = this.platformProvider.isCordova;
        this.addressbook = this.navParams.data.addressbook;
        this.completeTxHistory = this.navParams.data.completeHistory;
        this.wallet = this.navParams.data.wallet;
        this.supportedCards = this.giftCardProvider.getSupportedCardMap();
    }
    close(txid) {
        this.viewCtrl.dismiss({ txid });
    }
    updateSearchInput(search) {
        this.currentTxHistoryPage = 0;
        this.throttleSearch(search);
    }
    filter(search) {
        this.filteredTxHistory = [];
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](search)) {
            this.txHistoryShowMore = false;
            return [];
        }
        this.filteredTxHistory = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.completeTxHistory, tx => {
            if (!tx.searcheableString)
                tx.searcheableString = this.computeSearchableString(tx);
            return __WEBPACK_IMPORTED_MODULE_3_lodash__["includes"](tx.searcheableString, search.toLowerCase());
        });
        this.txHistoryShowMore =
            this.filteredTxHistory.length > this.HISTORY_SHOW_LIMIT ? true : false;
        return this.filteredTxHistory;
    }
    computeSearchableString(tx) {
        let addressBook = '';
        if (tx.addressTo && this.addressbook && this.addressbook[tx.addressTo])
            addressBook =
                this.addressbook[tx.addressTo].name ||
                    this.addressbook[tx.addressTo] ||
                    '';
        let searchableDate = this.computeSearchableDate(new Date(tx.time * 1000));
        let message = tx.message ? tx.message : '';
        let comment = tx.note ? tx.note.body : '';
        let addressTo = tx.addressTo ? tx.addressTo : '';
        let txid = tx.txid ? tx.txid : '';
        return (tx.amountStr +
            message +
            addressTo +
            addressBook +
            searchableDate +
            comment +
            txid)
            .toString()
            .toLowerCase();
    }
    computeSearchableDate(date) {
        let day = ('0' + date.getDate()).slice(-2).toString();
        let month = ('0' + (date.getMonth() + 1)).slice(-2).toString();
        let year = date.getFullYear();
        return [month, day, year].join('/');
    }
    moreSearchResults(loading) {
        setTimeout(() => {
            this.currentTxHistoryPage++;
            this.showHistory();
            loading.complete();
        }, 100);
    }
    showHistory() {
        this.txHistorySearchResults = this.filteredTxHistory
            ? this.filteredTxHistory.slice(0, (this.currentTxHistoryPage + 1) * this.HISTORY_SHOW_LIMIT)
            : [];
        this.txHistoryShowMore =
            this.filteredTxHistory.length > this.txHistorySearchResults.length;
    }
    trackByFn(index) {
        return index;
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
};
SearchTxModalPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-search-tx-modal',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/wallet-details/search-tx-modal/search-tx-modal.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Search Transactions\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button class="modal-close-button" (click)="close()" ion-button>\n        <ion-icon name="arrow-round-back"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div>\n    <ion-searchbar placeholder="{{\'Search Transactions\' | translate}}" [(ngModel)]="search" (ngModelChange)="updateSearchInput(search)"></ion-searchbar>\n  </div>\n\n  <ion-list *ngIf="txHistorySearchResults && txHistorySearchResults[0]" class="tx-history">\n    <div>\n      <div *ngFor="let tx of txHistorySearchResults; trackBy: trackByFn; let i = index;">\n        <button ion-item (click)="close(tx.txid)">\n          <ion-icon item-start>\n            <div *ngIf="tx.confirmations == 0">\n              <img src="assets/img/tx-action/icon-confirming.svg" width="40">\n            </div>\n            <div *ngIf="tx.confirmations > 0">\n              <span *ngIf="tx.customData && tx.customData.service">\n                <img class="icon-services" src="assets/img/shapeshift/icon-shapeshift.svg" *ngIf="tx.customData.service == \'shapeshift\'" width="40">\n                <img-loader class="icon-services" *ngIf="tx.customData.service === \'amazon\'" src="https://bitpay.com/gift-cards/assets/amazoncom/icon.svg" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                <img-loader class="icon-services" *ngIf="tx.customData.service === \'mercadolibre\'" src="https://bitpay.com/gift-cards/assets/mercadolivre/icon.svg" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                <ng-container *ngIf="supportedCards | async as cardConfig">\n                  <img-loader class="icon-services" *ngIf="tx.customData.service === \'giftcards\'" [src]="cardConfig[tx.customData.giftCardName]?.icon" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                </ng-container>\n                <img class="icon-services" src="assets/img/bitpay-card/icon-bitpay.svg" *ngIf="tx.customData.service == \'debitcard\'" width="40">\n              </span>\n              <span *ngIf="!tx.customData || !tx.customData.service">\n                <img src="assets/img/tx-action/icon-received.svg" *ngIf="tx.action == \'received\'" width="40">\n                <img src="assets/img/tx-action/icon-sent.svg" *ngIf="tx.action == \'sent\'" width="40">\n                <img src="assets/img/tx-action/icon-moved.svg" *ngIf="tx.action == \'moved\'" width="40">\n              </span>\n            </div>\n          </ion-icon>\n\n          <div class="action" *ngIf="tx.confirmations == 0">\n            <span *ngIf="(tx.action == \'sent\') && !(addressbook && addressbook[tx.outputs[0].address])">{{\'Sending\'\n              | translate}}</span>\n            <span *ngIf="(tx.action == \'moved\') && !(addressbook && addressbook[tx.outputs[0].address])">{{\'Moving\'\n              | translate}}</span>\n            <span *ngIf="(tx.action == \'sent\' || tx.action == \'moved\') && (addressbook && addressbook[tx.outputs[0].address])">{{addressbook[tx.outputs[0].address].name\n              || addressbook[tx.outputs[0].address]}}</span>\n            <span *ngIf="tx.action == \'received\'">{{\'Receiving\' | translate}}</span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'received\'">\n            <span *ngIf="(!tx.note || (tx.note && tx.note.body == \'\')) && (!addressbook || !addressbook[tx.outputs[0].address])">{{\'Received\'\n              | translate}}</span>\n            <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n            <span *ngIf="addressbook && addressbook[tx.outputs[0].address]">\n              {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n            </span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'sent\'">\n            <span *ngIf="!tx.message && (!tx.note || (tx.note && tx.note.body == \'\')) && (!addressbook || !addressbook[tx.outputs[0].address])">{{\'Sent\'\n              | translate}}</span>\n            <span *ngIf="tx.message">{{tx.message}}</span>\n            <span *ngIf="!tx.message && tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n            <span *ngIf="!tx.message && addressbook && addressbook[tx.outputs[0].address]">\n              {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n            </span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'moved\'">\n            <span *ngIf="(!tx.note || (tx.note && tx.note.body == \'\'))" translate>Moved</span>\n            <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'invalid\'">\n            <span class="assertive" *ngIf="!tx.message && !tx.note" translate>Invalid</span>\n          </div>\n\n          <ion-note item-end text-end>\n            <div class="amount">\n              <span [ngClass]="{\'received\': tx.action == \'received\'}" *ngIf="tx.action != \'invalid\'">{{tx.amount |\n                satToUnit: wallet.coin}}</span>\n              <span class="double-spend" *ngIf="tx.action == \'invalid\'" translate>(possible double spend)</span>\n            </div>\n            <div class="date">\n              <span *ngIf="tx.time && createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amTimeAgo}}</span>\n              <span *ngIf="tx.time && !createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amDateFormat:\'MMM D,\n                YYYY\'}}</span>\n            </div>\n          </ion-note>\n        </button>\n      </div>\n    </div>\n    <div class="txs-count" *ngIf="txHistoryShowMore">\n      <span>{{filteredTxHistory.length - txHistorySearchResults.length}} more</span>\n      &nbsp;\n      <ion-icon name="arrow-down"></ion-icon>\n    </div>\n  </ion-list>\n\n  <ion-infinite-scroll *ngIf="txHistoryShowMore" (ionInfinite)="moreSearchResults($event)">\n    <ion-infinite-scroll-content></ion-infinite-scroll-content>\n  </ion-infinite-scroll>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/wallet-details/search-tx-modal/search-tx-modal.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__["a" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */]])
], SearchTxModalPage);

//# sourceMappingURL=search-tx-modal.js.map

/***/ }),

/***/ 1033:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletBalancePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);




let WalletBalancePage = class WalletBalancePage {
    constructor(logger, navParams) {
        this.logger = logger;
        this.navParams = navParams;
        this.status = this.navParams.data.status;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded:  WalletBalancePage');
    }
};
WalletBalancePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-balance',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/wallet-details/wallet-balance/wallet-balance.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>\n      {{\'Spendable balance\' | translate}}\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n    <label-tip type="warn" header="no-header" class="no-arrowhead">\n      <div label-tip-body translate>\n        All of your bitcoin wallet balance may not be available for immediate spending.\n      </div>\n    </label-tip>\n    <ion-item>\n      <div class="balance-container">\n        <div class="title">\n          <img src="assets/img/icon-sigma.svg" />\n          <div translate>Total</div>\n        </div>\n        <div class="balance">\n          <span class="total">\n            {{status.totalBalanceStr}}\n          </span>\n          <div>\n            <span class="fiat">\n              {{status.totalBalanceAlternative}} {{status.alternativeIsoCode}}\n            </span>\n          </div>\n        </div>\n      </div>\n    </ion-item>\n    <label-tip type="info" header="no-header">\n      <div label-tip-body translate>\n        The total amount of bitcoin stored in this wallet.\n      </div>\n    </label-tip>\n\n    <ion-item>\n      <div class="balance-container">\n        <div class="title">\n          <ion-icon ios="ios-checkmark" md="md-checkmark"></ion-icon>\n          <div translate>Available</div>\n        </div>\n        <div class="balance">\n          <span class="available">\n            {{status.spendableBalanceStr}}\n          </span>\n          <div>\n            <span class="fiat">\n              {{status.spendableBalanceAlternative}} {{status.alternativeIsoCode}}\n            </span>\n          </div>\n        </div>\n      </div>\n    </ion-item>\n    <label-tip type="info" header="no-header">\n      <div label-tip-body translate>\n        The amount of bitcoin immediately spendable from this wallet.\n      </div>\n    </label-tip>\n\n    <ion-item>\n      <div class="balance-container">\n        <div class="title">\n          <img src="assets/img/icon-confirming-clear.svg" />\n          <div translate>Confirming</div>\n        </div>\n        <div class="balance">\n          <span class="confirming">\n            {{status.pendingBalanceStr}}\n          </span>\n          <div>\n            <span class="fiat">\n              {{status.pendingBalanceAlternative}} {{status.alternativeIsoCode}}\n            </span>\n          </div>\n        </div>\n      </div>\n    </ion-item>\n    <label-tip type="info" header="no-header">\n      <div label-tip-body translate>\n        The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.\n      </div>\n    </label-tip>\n\n    <ion-item>\n      <div class="balance-container">\n        <div class="title">\n          <img src="assets/img/icon-lock.svg" />\n          <div translate>Locked</div>\n        </div>\n        <div class="balance">\n          <span class="locked">\n            {{status.lockedBalanceStr}}\n          </span>\n          <div>\n            <span class="fiat">\n              {{status.lockedBalanceAlternative}} {{status.alternativeIsoCode}}\n            </span>\n          </div>\n        </div>\n      </div>\n    </ion-item>\n    <label-tip type="info" header="no-header">\n      <div label-tip-body translate>\n        The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.\n      </div>\n    </label-tip>\n\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/wallet-details/wallet-balance/wallet-balance.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */]])
], WalletBalancePage);

//# sourceMappingURL=wallet-balance.js.map

/***/ }),

/***/ 1034:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletTabsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__receive_receive__ = __webpack_require__(1035);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__send_send__ = __webpack_require__(1036);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__wallet_details_wallet_details__ = __webpack_require__(476);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__wallet_tabs_provider__ = __webpack_require__(90);




// Pages



// Providers


let WalletTabsPage = class WalletTabsPage {
    constructor(navParams, walletTabsProvider, events, platformProvider, statusBar) {
        this.navParams = navParams;
        this.walletTabsProvider = walletTabsProvider;
        this.events = events;
        this.platformProvider = platformProvider;
        this.statusBar = statusBar;
        this.receiveRoot = __WEBPACK_IMPORTED_MODULE_4__receive_receive__["a" /* ReceivePage */];
        this.activityRoot = __WEBPACK_IMPORTED_MODULE_6__wallet_details_wallet_details__["a" /* WalletDetailsPage */];
        this.sendRoot = __WEBPACK_IMPORTED_MODULE_5__send_send__["a" /* SendPage */];
        this.selectedTabIndex = 1;
        if (typeof this.navParams.get('selectedTabIndex') !== 'undefined') {
            this.selectedTabIndex = this.navParams.get('selectedTabIndex');
        }
    }
    ionViewDidLoad() {
        this.walletId = this.navParams.get('walletId');
    }
    ionViewWillEnter() {
        if (this.platformProvider.isIOS) {
            setTimeout(() => this.statusBar.styleLightContent(), 300);
        }
    }
    ionViewWillLeave() {
        if (this.platformProvider.isIOS) {
            this.statusBar.styleDefault();
        }
    }
    ngAfterViewInit() {
        this.walletTabsProvider.setTabNav(this.walletTabs);
    }
    ngOnDestroy() {
        this.walletTabsProvider.clear();
        this.events.publish('Wallet/disableHardwareKeyboard');
        this.unsubscribeChildPageEvents();
    }
    unsubscribeChildPageEvents() {
        this.events.unsubscribe('Local/AddressScan');
        this.events.unsubscribe('Wallet/disableHardwareKeyboard');
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('tabs'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], WalletTabsPage.prototype, "walletTabs", void 0);
WalletTabsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        template: `
    <ion-tabs [selectedIndex]="selectedTabIndex" #tabs>
      <ion-tab
        [root]="receiveRoot"
        tabTitle="{{'Receive'|translate}}"
        tabIcon="tab-receive"
      ></ion-tab>
      <ion-tab
        [root]="activityRoot"
        tabTitle="{{'Activity'|translate}}"
        tabIcon="tab-activity"
      ></ion-tab>
      <ion-tab
        [root]="sendRoot"
        tabTitle="{{'Send'|translate}}"
        tabIcon="tab-send"
      ></ion-tab>
    </ion-tabs>
  `
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__wallet_tabs_provider__["a" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */]])
], WalletTabsPage);

//# sourceMappingURL=wallet-tabs.js.map

/***/ }),

/***/ 1035:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReceivePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_social_sharing__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__backup_backup_key_backup_key__ = __webpack_require__(334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__send_amount_amount__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wallet_tabs_wallet_tabs_child__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__wallet_tabs_wallet_tabs_provider__ = __webpack_require__(90);






// Native

// Pages


// Providers









let ReceivePage = class ReceivePage extends __WEBPACK_IMPORTED_MODULE_16__wallet_tabs_wallet_tabs_child__["a" /* WalletTabsChild */] {
    constructor(actionSheetProvider, navCtrl, logger, profileProvider, walletProvider, platformProvider, events, socialSharing, bwcErrorProvider, translate, externalLinkProvider, walletTabsProvider, platform) {
        super(navCtrl, profileProvider, walletTabsProvider);
        this.actionSheetProvider = actionSheetProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.platformProvider = platformProvider;
        this.events = events;
        this.socialSharing = socialSharing;
        this.bwcErrorProvider = bwcErrorProvider;
        this.translate = translate;
        this.externalLinkProvider = externalLinkProvider;
        this.platform = platform;
        this.retryCount = 0;
        this.bwsEventHandler = (walletId, type, n) => {
            if (this.wallet.credentials.walletId == walletId &&
                type == 'NewIncomingTx' &&
                n.data) {
                let addr = this.address.indexOf(':') > -1
                    ? this.address.split(':')[1]
                    : this.address;
                if (n.data.address == addr)
                    this.setAddress(true);
            }
        };
        this.showShareButton = this.platformProvider.isCordova;
    }
    ionViewWillEnter() {
        this.onResumeSubscription = this.platform.resume.subscribe(() => {
            this.setAddress();
            this.events.subscribe('bwsEvent', this.bwsEventHandler);
        });
        this.setAddress();
    }
    ionViewWillLeave() {
        this.onResumeSubscription.unsubscribe();
    }
    ionViewDidLoad() {
        this.events.subscribe('bwsEvent', this.bwsEventHandler);
    }
    requestSpecificAmount() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__send_amount_amount__["a" /* AmountPage */], {
            toAddress: this.address,
            id: this.wallet.credentials.walletId,
            recipientType: 'wallet',
            name: this.wallet.name,
            color: this.wallet.color,
            coin: this.wallet.coin,
            nextPage: 'CustomAmountPage',
            network: this.wallet.network
        });
    }
    setAddress(newAddr, failed) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (!this.wallet ||
                !this.wallet.isComplete() ||
                (this.wallet.needsBackup && this.wallet.network == 'livenet'))
                return;
            this.loading = newAddr || __WEBPACK_IMPORTED_MODULE_15_lodash__["isEmpty"](this.address) ? true : false;
            this.walletProvider
                .getAddress(this.wallet, newAddr)
                .then(addr => {
                this.newAddressError = false;
                this.loading = false;
                if (!addr)
                    return;
                const address = this.walletProvider.getAddressView(this.wallet.coin, this.wallet.network, addr);
                if (this.address && this.address != address) {
                    this.playAnimation = true;
                }
                this.updateQrAddress(address, newAddr);
            })
                .catch(err => {
                this.logger.warn('Retrying to create new adress:' + ++this.retryCount);
                if (this.retryCount > 3) {
                    this.retryCount = 0;
                    this.loading = false;
                    this.showErrorInfoSheet(err);
                }
                else if (err == 'INVALID_ADDRESS') {
                    // Generate new address if the first one is invalid ( fix for concatenated addresses )
                    if (!failed) {
                        this.setAddress(newAddr, true);
                        this.logger.warn(this.bwcErrorProvider.msg(err, 'Receive'));
                        return;
                    }
                    this.setAddress(false); // failed to generate new address -> get last saved address
                }
                else {
                    this.setAddress(false); // failed to generate new address -> get last saved address
                }
                this.logger.warn(this.bwcErrorProvider.msg(err, 'Receive'));
            });
        });
    }
    showErrorInfoSheet(error) {
        this.newAddressError = true;
        const infoSheetTitle = this.translate.instant('Error');
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: this.bwcErrorProvider.msg(error), title: infoSheetTitle });
        errorInfoSheet.present();
    }
    updateQrAddress(address, newAddr) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (newAddr) {
                yield __WEBPACK_IMPORTED_MODULE_4_rxjs__["Observable"].timer(400).toPromise();
            }
            this.address = address;
            yield __WEBPACK_IMPORTED_MODULE_4_rxjs__["Observable"].timer(200).toPromise();
            this.playAnimation = false;
        });
    }
    shareAddress() {
        if (!this.showShareButton)
            return;
        this.socialSharing.share(this.address);
    }
    goToBackup() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__backup_backup_key_backup_key__["a" /* BackupKeyPage */], {
            keyId: this.wallet.credentials.keyId
        });
    }
    openWikiBackupNeeded() {
        const url = 'https://support.bitpay.com/hc/en-us/articles/115002989283-Why-don-t-I-have-an-online-account-for-my-BitPay-wallet-';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Read more in our Wiki');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    showMoreOptions() {
        const showShare = this.showShareButton &&
            this.wallet &&
            this.wallet.isComplete() &&
            !this.wallet.needsBackup;
        const optionsSheet = this.actionSheetProvider.createOptionsSheet('address-options', { showShare });
        optionsSheet.present();
        optionsSheet.onDidDismiss(option => {
            if (option == 'request-amount')
                this.requestSpecificAmount();
            if (option == 'share-address')
                this.shareAddress();
        });
    }
    showFullAddr() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('address-copied', { address: this.address, coin: this.wallet.coin });
        infoSheet.present();
    }
};
ReceivePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-receive',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/receive/receive.html"*/'<ion-header class="wallet-details-header">\n  <ion-navbar class="app-color">\n    <ion-buttons left>\n      <button class="modal-close-button" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n    <ion-title>{{wallet && wallet.name || (\'Receive\'|translate)}}</ion-title>\n    <ion-buttons right>\n      <button *ngIf="wallet && wallet.isComplete() && !wallet.needsBackup" (click)="showMoreOptions()" ion-button icon-only>\n        <ion-icon class="horizontal-lg" name="more"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n  <ion-toolbar class="app-color">\n    <div *ngIf="!wallet.balanceHidden && !wallet.scanning && wallet.cachedStatus" class="wallet-details-header__balance">\n      <span>{{wallet.cachedStatus && wallet.cachedStatus.spendableBalanceStr}}</span>\n      <ion-icon *ngIf="wallet.cachedStatus.totalBalanceSat != wallet.cachedStatus.spendableAmount" ios="ios-timer-outline" md="md-timer"></ion-icon>\n    </div>\n    <div *ngIf="wallet.balanceHidden  && !wallet.scanning" class="wallet-details-header__balance-hidden">\n      <span class="title" translate>[Balance Hidden]</span>\n    </div>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="wrapper">\n    <div class="prompt-user-fullscreen-container" *ngIf="wallet && wallet.isComplete() && wallet.needsBackup">\n      <div class="prompt-user">\n        <div class="title-icon">\n          <img src="assets/img/single-folded-content.svg" />\n        </div>\n        <div class="title-info">\n          <span translate>Needs Backup</span>\n        </div>\n        <div class="subtitle-info">\n          <span translate>Before retrieving your wallet address, it\'s recommended that you first write down your recovery phrase and store it securely so that your wallet can be recovered in the case your device was lost or stolen.</span>\n        </div>\n        <button ion-button class="button-standard" (click)="goToBackup()">\n          {{\'Write Down Recovery Phrase\' | translate}}\n        </button>\n      </div>\n    </div>\n\n    <div *ngIf="wallet && wallet.isComplete() && !wallet.needsBackup && (!newAddressError || address)" class="receive-content">\n      <div class="title">\n        {{\'Address\' | translate}}\n      </div>\n      <div class="address-container">\n        <div class="text-address ellipsis">\n          <img *ngIf="address" class="copy-to-clip" copy-to-clipboard="{{ address }}" src="assets/img/paste-clipboard.svg" width="18" />\n          <div *ngIf="!address" [ngClass]="{\'fade-in-out\': playAnimation}" class="address-text">\n            <span class="address-placeholder" translate>Generating new address...</span>\n          </div>\n          <div *ngIf="address" [ngClass]="{\'fade-in-out\': playAnimation}" (click)="showFullAddr()" class="address-text ellipsis">\n            <span copy-to-clipboard="{{ address }}" hide-toast="true">{{ address }}</span>\n          </div>\n\n          <button *ngIf="!(wallet.cachedStatus && wallet.cachedStatus.wallet && wallet.cachedStatus.wallet.singleAddress)" class="new-address-btn" detail-none text-center (click)="setAddress(true)">\n            <span ion-text color="primary" translate>\n              <img *ngIf="!loading" class="spin-icon" [ngClass]="{\'spin-backwards\': playAnimation}" src="assets/img/right.svg" width="16" />\n              <div *ngIf="loading" [ngClass]="{\'spin-fast\': loading}" class="spinner"></div>\n            </span>\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div class="qr-container" *ngIf="wallet && wallet.isComplete() && !wallet.needsBackup">\n      <div class="lines-background"></div>\n      <div class="prompt-user-fullscreen-container" *ngIf="newAddressError && !address">\n        <div class="prompt-user">\n          <div class="title-icon larger-icon">\n            <img src="assets/img/ghost-straight-face.svg" />\n          </div>\n          <div class="title-info">\n            <span translate>Something goes wrong...</span>\n          </div>\n          <button ion-button class="button-standard" (click)="setAddress(true)">\n            {{\'Generate New Address\' | translate}}\n          </button>\n        </div>\n      </div>\n      <div class="card qr-card qr-placeholder" *ngIf="!address && !newAddressError">\n        <div>...</div>\n      </div>\n      <div class="card qr-card" [ngClass]="{\'qr-code-bounce\': playAnimation}" *ngIf="address">\n        <ngx-qrcode (click)="showFullAddr()" *ngIf="address" copy-to-clipboard="{{ address }}" hide-toast="true" qrc-value="{{address}}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n      </div>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/receive/receive.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_6__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_10__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_11__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_17__wallet_tabs_wallet_tabs_provider__["a" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Platform */]])
], ReceivePage);

//# sourceMappingURL=receive.js.map

/***/ }),

/***/ 1036:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SendPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_address_address__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_incoming_data_incoming_data__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_paypro_paypro__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__wallet_tabs_wallet_tabs_provider__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wallet_tabs_wallet_tabs_child__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__multi_send_multi_send__ = __webpack_require__(1037);






// Providers










// Pages


let SendPage = class SendPage extends __WEBPACK_IMPORTED_MODULE_16__wallet_tabs_wallet_tabs_child__["a" /* WalletTabsChild */] {
    constructor(currencyProvider, navCtrl, navParams, payproProvider, profileProvider, logger, incomingDataProvider, addressProvider, events, walletTabsProvider, actionSheetProvider, externalLinkProvider, appProvider, translate) {
        super(navCtrl, profileProvider, walletTabsProvider);
        this.currencyProvider = currencyProvider;
        this.navParams = navParams;
        this.payproProvider = payproProvider;
        this.logger = logger;
        this.incomingDataProvider = incomingDataProvider;
        this.addressProvider = addressProvider;
        this.events = events;
        this.actionSheetProvider = actionSheetProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.appProvider = appProvider;
        this.translate = translate;
        this.search = '';
        this.wallets = {};
        this.hasWallets = {};
        this.validDataTypeMap = [
            'BitcoinAddress',
            'BitcoinCashAddress',
            'EthereumAddress',
            'EthereumUri',
            'BitcoinUri',
            'BitcoinCashUri'
        ];
        this.updateAddressHandler = data => {
            this.search = data.value;
            this.processInput();
        };
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SendPage');
    }
    ionViewWillEnter() {
        this.events.subscribe('Local/AddressScan', this.updateAddressHandler);
        for (const coin of this.currencyProvider.getAvailableCoins()) {
            this.wallets[coin] = this.profileProvider.getWallets({ coin });
            this.hasWallets[coin] = !__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.wallets[coin]);
        }
    }
    ionViewWillLeave() {
        this.events.unsubscribe('Local/AddressScan', this.updateAddressHandler);
    }
    shouldShowZeroState() {
        return (this.wallet &&
            this.wallet.cachedStatus &&
            !this.wallet.cachedStatus.totalBalanceSat);
    }
    goToReceive() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.walletTabsProvider.goToTabIndex(0);
            const coinName = this.currencyProvider.getCoinName(this.wallet.coin);
            const infoSheet = this.actionSheetProvider.createInfoSheet('receiving-bitcoin', { coinName });
            yield __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__["Observable"].timer(250).toPromise();
            infoSheet.present();
        });
    }
    openScanner() {
        this.scannerOpened = true;
        this.walletTabsProvider.setSendParams({
            amount: this.navParams.data.amount,
            coin: this.navParams.data.coin
        });
        this.walletTabsProvider.setFromPage({ fromSend: true });
        this.events.publish('ScanFromWallet');
    }
    isMultiSend(coin) {
        return this.currencyProvider.isMultiSend(coin);
    }
    checkCoinAndNetwork(data, isPayPro) {
        let isValid, addrData;
        if (isPayPro) {
            isValid =
                data.chain == this.currencyProvider.getChain(this.wallet.coin) &&
                    data.network == this.wallet.network;
        }
        else {
            addrData = this.addressProvider.getCoinAndNetwork(data, this.wallet.network);
            isValid =
                this.currencyProvider.getChain(this.wallet.coin).toLowerCase() ==
                    addrData.coin && addrData.network == this.wallet.network;
        }
        if (isValid) {
            this.invalidAddress = false;
            return true;
        }
        else {
            this.invalidAddress = true;
            let network = isPayPro ? data.network : addrData.network;
            if (this.wallet.coin === 'bch' && this.wallet.network === network) {
                const isLegacy = this.checkIfLegacy();
                isLegacy ? this.showLegacyAddrMessage() : this.showErrorMessage();
            }
            else {
                this.showErrorMessage();
            }
        }
        return false;
    }
    redir() {
        this.incomingDataProvider.redir(this.search, {
            amount: this.navParams.data.amount,
            coin: this.navParams.data.coin
        });
        this.search = '';
    }
    showErrorMessage() {
        const msg = this.translate.instant('The wallet you are using does not match the network and/or the currency of the address provided');
        const title = this.translate.instant('Error');
        const infoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg, title });
        infoSheet.present();
        infoSheet.onDidDismiss(() => {
            this.search = '';
        });
    }
    showLegacyAddrMessage() {
        const appName = this.appProvider.info.nameCase;
        const infoSheet = this.actionSheetProvider.createInfoSheet('legacy-address-info', { appName });
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                let url = 'https://bitpay.github.io/address-translator?addr=' + this.search;
                this.externalLinkProvider.open(url);
            }
            this.search = '';
        });
    }
    cleanSearch() {
        this.search = '';
        this.invalidAddress = false;
    }
    processInput() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (this.search == '')
                this.invalidAddress = false;
            const hasContacts = yield this.checkIfContact();
            if (!hasContacts) {
                const parsedData = this.incomingDataProvider.parseData(this.search);
                if ((parsedData && parsedData.type == 'PayPro') ||
                    (parsedData && parsedData.type == 'InvoiceUri')) {
                    try {
                        const invoiceUrl = this.incomingDataProvider.getPayProUrl(this.search);
                        const payproOptions = yield this.payproProvider.getPayProOptions(invoiceUrl);
                        const selected = payproOptions.paymentOptions.filter(option => option.selected);
                        if (selected.length > 0) {
                            const isValid = this.checkCoinAndNetwork(selected[0], true);
                            if (isValid) {
                                this.incomingDataProvider.redir(this.search);
                            }
                        }
                        else {
                            this.incomingDataProvider.redir(this.search);
                        }
                    }
                    catch (err) {
                        this.invalidAddress = true;
                        this.logger.warn(err);
                    }
                }
                else if (parsedData &&
                    __WEBPACK_IMPORTED_MODULE_4_lodash__["indexOf"](this.validDataTypeMap, parsedData.type) != -1) {
                    const isValid = this.checkCoinAndNetwork(this.search);
                    if (isValid)
                        this.redir();
                }
                else if (parsedData && parsedData.type == 'BitPayCard') {
                    this.close();
                    this.incomingDataProvider.redir(this.search);
                }
                else if (parsedData && parsedData.type == 'PrivateKey') {
                    this.incomingDataProvider.redir(this.search);
                }
                else {
                    this.invalidAddress = true;
                }
            }
            else {
                this.invalidAddress = false;
            }
        });
    }
    checkIfContact() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__["Observable"].timer(50).toPromise();
            return this.transferTo.hasContactsOrWallets;
        });
    }
    checkIfLegacy() {
        return (this.incomingDataProvider.isValidBitcoinCashLegacyAddress(this.search) ||
            this.incomingDataProvider.isValidBitcoinCashUriWithLegacyAddress(this.search));
    }
    goToMultiSendPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__multi_send_multi_send__["a" /* MultiSendPage */]);
    }
    closeCam() {
        if (this.scannerOpened)
            this.events.publish('ExitScan');
        else
            this.getParentTabs().dismiss();
        this.scannerOpened = false;
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('transferTo'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], SendPage.prototype, "transferTo", void 0);
SendPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-send',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/send/send.html"*/'<ion-header [ngClass]="{\'wallet-details-header\': wallet}">\n  <ion-navbar class="app-color">\n    <ion-buttons *ngIf="wallet" left>\n      <button class="modal-close-button" (click)="closeCam()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n    <ion-title>{{wallet && wallet.name || (\'Amount\' | translate)}}</ion-title>\n  </ion-navbar>\n  <ion-toolbar *ngIf="wallet" class="app-color">\n    <div *ngIf="!wallet.balanceHidden && !wallet.scanning && wallet.cachedStatus" class="wallet-details-header__balance">\n      <span>{{wallet.cachedStatus && wallet.cachedStatus.spendableBalanceStr}}</span>\n      <ion-icon *ngIf="wallet.cachedStatus.totalBalanceSat != wallet.cachedStatus.spendableAmount" ios="ios-timer-outline" md="md-timer"></ion-icon>\n    </div>\n    <div *ngIf="wallet.balanceHidden  && !wallet.scanning" class="wallet-details-header__balance-hidden">\n      <span class="title" translate>[Balance Hidden]</span>\n    </div>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content no-bounce>\n\n  <div class="prompt-user-fullscreen-container" *ngIf="shouldShowZeroState()">\n    <div class="prompt-user">\n      <div class="title-icon larger-icon">\n        <img src="assets/img/ghost-straight-face.svg" />\n      </div>\n      <div class="title-info">\n        <span translate>Mmm...</span>\n      </div>\n      <div class="subtitle-info">\n        <span translate>It appears that you do not have any money to send.</span>\n      </div>\n      <button ion-button class="button-standard" (click)="goToReceive()">\n        {{\'Add funds\' | translate}}\n      </button>\n    </div>\n  </div>\n\n  <div *ngIf="!shouldShowZeroState()">\n    <div *ngIf="hasWallets[wallet.coin]">\n      <div class="send-header-wrapper">\n        <span class="send-heading" translate>Recipient</span>\n        <ion-item class="search-wrapper" [ngClass]="{\'invalid\': invalidAddress && search != \'\'}">\n          <ion-input placeholder="{{\'Search or enter address\' | translate}}" [(ngModel)]="search" (ngModelChange)="processInput()"></ion-input>\n          <ion-icon *ngIf="invalidAddress && search != \'\'" item-end class="backspace-icon" name="backspace" (click)="cleanSearch()"></ion-icon>\n          <ion-icon item-end class="scan-icon" (click)="openScanner()">\n            <img src="assets/img/scan-ico.svg">\n          </ion-icon>\n        </ion-item>\n      </div>\n\n      <div *ngIf="isMultiSend(wallet.coin)" class="card">\n        <ion-item-divider class="title">\n          <span translate>Transfer to Multiple Recipients</span>\n        </ion-item-divider>\n        <ion-list>\n          <button ion-item (click)="goToMultiSendPage()">\n            <ion-icon class="item-img" item-start>\n              <img src="assets/img/address-book-add.svg" />\n            </ion-icon>\n            <div class="item-title">Add recipient</div>\n          </button>\n        </ion-list>\n      </div>\n\n      <page-transfer-to [wallet]="wallet" [searchInput]="search" [useAsModal]="false" #transferTo></page-transfer-to>\n\n    </div>\n    <div *ngIf="!hasWallets[wallet.coin]" class="no-wallet-message">\n      <span translate>To get started, you\'ll need to create a wallet and get some funds.</span>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/send/send.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_13__providers_paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_15__wallet_tabs_wallet_tabs_provider__["a" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], SendPage);

//# sourceMappingURL=send.js.map

/***/ }),

/***/ 1037:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MultiSendPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_address_address__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_incoming_data_incoming_data__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wallet_tabs_wallet_tabs_provider__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__wallet_tabs_wallet_tabs_child__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__amount_amount__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__confirm_confirm__ = __webpack_require__(249);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__transfer_to_modal_transfer_to_modal__ = __webpack_require__(1038);






// Providers











// Pages




let MultiSendPage = class MultiSendPage extends __WEBPACK_IMPORTED_MODULE_17__wallet_tabs_wallet_tabs_child__["a" /* WalletTabsChild */] {
    constructor(navCtrl, navParams, profileProvider, currencyProvider, logger, incomingDataProvider, addressProvider, events, walletTabsProvider, actionSheetProvider, externalLinkProvider, appProvider, translate, modalCtrl, decimalPipe, txFormatProvider, bwcProvider) {
        super(navCtrl, profileProvider, walletTabsProvider);
        this.navParams = navParams;
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.incomingDataProvider = incomingDataProvider;
        this.addressProvider = addressProvider;
        this.events = events;
        this.actionSheetProvider = actionSheetProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.appProvider = appProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.decimalPipe = decimalPipe;
        this.txFormatProvider = txFormatProvider;
        this.bwcProvider = bwcProvider;
        this.search = '';
        this.multiRecipients = [];
        this.contactsList = [];
        this.filteredContactsList = [];
        this.filteredWallets = [];
        this.validDataTypeMap = [
            'BitcoinAddress',
            'BitcoinCashAddress',
            'EthereumAddress',
            'EthereumUri',
            'BitcoinUri',
            'BitcoinCashUri'
        ];
        this.updateAddressHandler = data => {
            this.search = data.value;
            this.processInput();
        };
        this.bitcore = {
            btc: this.bwcProvider.getBitcore(),
            bch: this.bwcProvider.getBitcoreCash()
        };
        this.isDisabledContinue = true;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: MultiSendPage');
    }
    ionViewWillEnter() {
        this.events.subscribe('Local/AddressScan', this.updateAddressHandler);
        this.events.subscribe('addRecipient', newRecipient => {
            this.addRecipient(newRecipient);
            this.checkGoToConfirmButton();
        });
    }
    ionViewWillLeave() {
        this.events.unsubscribe('Local/AddressScan', this.updateAddressHandler);
        this.events.unsubscribe('addRecipient');
    }
    openTransferToModal() {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_20__transfer_to_modal_transfer_to_modal__["a" /* TransferToModalPage */], {
            wallet: this.wallet
        }, {
            showBackdrop: false,
            enableBackdropDismiss: true,
            cssClass: 'wallet-details-modal'
        });
        modal.present();
    }
    openAmountModal(item, index) {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_18__amount_amount__["a" /* AmountPage */], {
            wallet: this.wallet,
            useAsModal: true
        }, {
            showBackdrop: false,
            enableBackdropDismiss: true,
            cssClass: 'wallet-details-modal'
        });
        modal.present();
        modal.onDidDismiss(data => {
            this.cleanSearch();
            if (!data)
                return;
            let altAmountStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, +data.amount);
            item.amount = +data.amount;
            item.altAmountStr = altAmountStr;
            item.fiatAmount = data.fiatAmount;
            item.fiatCode = data.fiatCode;
            item.amountToShow = this.decimalPipe.transform(data.amount /
                this.currencyProvider.getPrecision(this.wallet.coin).unitToSatoshi, '1.2-6');
            this.multiRecipients[index] = item;
            this.checkGoToConfirmButton();
        });
    }
    addRecipient(recipient) {
        let amountToShow = +recipient.amount
            ? this.decimalPipe.transform(+recipient.amount /
                this.currencyProvider.getPrecision(this.wallet.coin).unitToSatoshi, '1.2-6')
            : null;
        let altAmountStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, ++recipient.amount);
        this.multiRecipients.push({
            amount: +recipient.amount ? +recipient.amount : null,
            amountToShow,
            altAmountStr: altAmountStr ? altAmountStr : null,
            toAddress: recipient.toAddress,
            recipientType: recipient.recipientType,
            recipient
        });
        this.checkGoToConfirmButton();
        this.cleanSearch();
    }
    newRecipient() {
        if (this.parsedData &&
            (this.parsedData.type === 'BitcoinUri' ||
                this.parsedData.type === 'BitcoinCashUri' ||
                this.parsedData.type === 'EthereumUri')) {
            let parsed;
            let toAddress;
            let amount;
            let recipient;
            let recipientType;
            try {
                if (this.bitcore[this.wallet.coin]) {
                    parsed = this.bitcore[this.wallet.coin].URI(this.search);
                }
                const address = this.incomingDataProvider.extractAddress(this.search);
                toAddress =
                    parsed && parsed.address
                        ? parsed.address.toString()
                        : __WEBPACK_IMPORTED_MODULE_5_lodash__["clone"](address);
                // keep address in original format
                if (parsed &&
                    parsed.address &&
                    this.search.indexOf(toAddress) < 0 &&
                    this.wallet.coin == 'bch') {
                    toAddress = parsed.address.toCashAddress();
                }
                const extractedAmount = /[\?\&]amount|value=(\d+([\,\.]\d+)?)/i.exec(this.search);
                if (parsed && parsed.amount) {
                    amount = parsed.amount;
                }
                else if (extractedAmount) {
                    amount = extractedAmount[1];
                }
                recipientType = 'address';
                recipient = null;
            }
            catch (_err) {
                // If pasted address isn't a valid uri
                toAddress = __WEBPACK_IMPORTED_MODULE_5_lodash__["clone"](this.search);
                recipientType = 'address';
            }
            const newRecipient = {
                amount,
                toAddress,
                recipientType,
                recipient
            };
            const index = this.multiRecipients.length;
            if (!amount) {
                this.openAmountModal(newRecipient, index);
            }
            else {
                this.addRecipient(newRecipient);
            }
        }
        else {
            const newRecipient = {
                toAddress: __WEBPACK_IMPORTED_MODULE_5_lodash__["clone"](this.search),
                recipientType: 'address'
            };
            const index = this.multiRecipients.length;
            this.openAmountModal(newRecipient, index);
        }
    }
    checkGoToConfirmButton() {
        let b = false;
        this.multiRecipients.forEach(recipient => {
            if (!recipient.amountToShow) {
                b = true;
            }
        });
        this.isDisabledContinue = b;
    }
    cleanSearch() {
        this.search = '';
        this.parsedData = {};
    }
    removeRecipient(index) {
        this.multiRecipients.splice(index, 1);
        this.checkGoToConfirmButton();
    }
    openScanner() {
        this.scannerOpened = true;
        this.walletTabsProvider.setSendParams({
            amount: this.navParams.get('amount'),
            coin: this.navParams.get('coin')
        });
        this.walletTabsProvider.setFromPage({ fromSend: true });
        this.events.publish('ScanFromWallet');
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    checkCoinAndNetwork(data) {
        const addrData = this.addressProvider.getCoinAndNetwork(data, this.wallet.network);
        const isValid = this.currencyProvider.getChain(this.wallet.coin).toLowerCase() ==
            addrData.coin && addrData.network == this.wallet.network;
        if (isValid) {
            this.invalidAddress = false;
            return true;
        }
        else {
            this.invalidAddress = true;
            const network = addrData.network;
            if (this.wallet.coin === 'bch' && this.wallet.network === network) {
                const isLegacy = this.checkIfLegacy();
                isLegacy ? this.showLegacyAddrMessage() : this.showErrorMessage();
            }
            else {
                this.showErrorMessage();
            }
        }
        return false;
    }
    showErrorMessage() {
        const msg = this.translate.instant('The wallet you are using does not match the network and/or the currency of the address provided');
        const title = this.translate.instant('Error');
        const infoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg, title });
        infoSheet.present();
        infoSheet.onDidDismiss(() => {
            this.search = '';
        });
    }
    showLegacyAddrMessage() {
        const appName = this.appProvider.info.nameCase;
        const infoSheet = this.actionSheetProvider.createInfoSheet('legacy-address-info', { appName });
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                let url = 'https://bitpay.github.io/address-translator?addr=' + this.search;
                this.externalLinkProvider.open(url);
            }
            this.search = '';
        });
    }
    processInput() {
        if (this.search && this.search.trim() != '') {
            this.parsedData = this.incomingDataProvider.parseData(this.search);
            if (this.parsedData && this.parsedData.type == 'PayPro') {
                this.invalidAddress = true;
            }
            else if (this.parsedData &&
                __WEBPACK_IMPORTED_MODULE_5_lodash__["indexOf"](this.validDataTypeMap, this.parsedData.type) != -1) {
                const isValid = this.checkCoinAndNetwork(this.search);
                if (isValid)
                    this.invalidAddress = false;
            }
            else {
                this.invalidAddress = true;
            }
        }
    }
    checkIfLegacy() {
        return (this.incomingDataProvider.isValidBitcoinCashLegacyAddress(this.search) ||
            this.incomingDataProvider.isValidBitcoinCashUriWithLegacyAddress(this.search));
    }
    goToConfirm() {
        let totalAmount = 0;
        this.multiRecipients.forEach(recipient => {
            totalAmount += recipient.amount;
        });
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_19__confirm_confirm__["a" /* ConfirmPage */], {
            fromMultiSend: true,
            totalAmount,
            recipientType: 'multi',
            color: this.wallet.color,
            coin: this.wallet.coin,
            network: this.wallet.network,
            useSendMax: false,
            recipients: this.multiRecipients
        });
    }
    closeCam() {
        if (this.scannerOpened)
            this.events.publish('ExitScan');
        else
            this.getParentTabs().dismiss();
        this.scannerOpened = false;
    }
};
MultiSendPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Component"])({
        selector: 'page-multi-send',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/send/multi-send/multi-send.html"*/'<ion-header [ngClass]="{\'wallet-details-header\': wallet}">\n  <ion-navbar class="app-color">\n    <ion-title>{{wallet && wallet.name || (\'Amount\' | translate)}}</ion-title>\n    <ion-buttons end>\n      <button ion-button (click)="goToConfirm()" *ngIf="multiRecipients && multiRecipients.length > 0" [disabled]="isDisabledContinue">\n        <span translate>Continue</span>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n  <ion-toolbar *ngIf="wallet" class="app-color">\n    <div *ngIf="!wallet.balanceHidden && !wallet.scanning && wallet.cachedStatus" class="wallet-details-header__balance">\n      <span>{{wallet.cachedStatus && wallet.cachedStatus.totalBalanceStr}}</span>\n      <ion-icon *ngIf="wallet.cachedStatus.totalBalanceSat != wallet.cachedStatus.spendableAmount" ios="ios-timer-outline" md="md-timer"></ion-icon>\n    </div>\n    <div *ngIf="wallet.balanceHidden  && !wallet.scanning" class="wallet-details-header__balance-hidden">\n      <span class="title" translate>[Balance Hidden]</span>\n    </div>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div>\n    <div>\n      <div class="send-header-wrapper">\n        <div class="send-heading">\n          <span translate>Multiple Recipients</span>\n          <ion-icon item-end class="open-modal-icon" (click)="openTransferToModal()">\n            <img src="assets/img/address-book-add.svg" />\n          </ion-icon>\n        </div>\n        <ion-item class="search-wrapper" [ngClass]="{\'invalid\': invalidAddress && search != \'\'}">\n          <ion-input placeholder="{{\'Enter \' + getCoinName(wallet.coin) + \' address\' | translate}}" [(ngModel)]="search" (ngModelChange)="processInput()"></ion-input>\n          <ion-icon *ngIf="invalidAddress && search != \'\'" item-end class="backspace-icon" name="backspace" (click)="search = \'\'"></ion-icon>\n          <ion-icon item-end class="scan-icon" (click)="openScanner()">\n            <img src="assets/img/scan-ico.svg">\n          </ion-icon>\n        </ion-item>\n        <div class="recipient-buttons" *ngIf="!invalidAddress && search != \'\'">\n          <button ion-button class="button-add" outline (click)="newRecipient()">{{ \'Add Recipient\' | translate}}</button>\n          <button ion-button class="button-cancel" outline (click)="cleanSearch()">{{ \'Cancel\' | translate}}</button>\n        </div>\n      </div>\n\n      <div>\n        <div class="card" *ngFor="let item of multiRecipients; let idx = index">\n          <ion-item-divider>\n            <span class="ellipsis">{{ \'Recipient\' | translate}} {{idx +1}}</span>\n            <ion-icon class="close-icon pointer" name="ios-close-outline" item-right (click)="removeRecipient(idx)"></ion-icon>\n          </ion-item-divider>\n          <ion-list class="pointer" (click)="openAmountModal(item, idx)">\n            <div class="wallet" *ngIf="item.recipientType == \'wallet\' && item.recipient">\n              <img [ngClass]="{ testnet: wallet.network === \'testnet\' }" src="assets/img/currencies/{{wallet.coin}}.svg" class="icon-wallet" />\n              <span class="name">{{item.recipient.name}}</span>\n            </div>\n\n            <div class="wallet" *ngIf="item.recipientType == \'contact\' && item.recipient">\n              <ion-icon class="item-gravatar" item-left>\n                <gravatar [name]="item.recipient.name" [height]="35" [width]="35" [email]="item.recipient.email"></gravatar>\n              </ion-icon>\n              <span class="name">{{item.recipient.name}}</span>\n            </div>\n\n            <div class="wallet" *ngIf="item.recipientType == \'address\'">\n              <img class="coin-icon" src="assets/img/icon-{{wallet.coin}}-small.svg" alt="Coin" />\n              <span class="address-divider"></span>\n              <span class="ellipsis">{{item.toAddress}}</span>\n            </div>\n\n            <br>\n            <span *ngIf="item.amountToShow">{{\'Amount:\' | translate}} </span>\n            <span *ngIf="item.amountToShow">{{item.amountToShow}} {{wallet.coin | uppercase}} ({{item.altAmountStr}})</span>\n            <span *ngIf="!item.amountToShow" class="warning">{{\'Please, enter the amount\' | translate}}</span>\n          </ion-list>\n        </div>\n      </div>\n    </div>\n    <div *ngIf="multiRecipients.length == 0" class="no-wallet-message">\n      <span translate>To get started, you\'ll need to enter a valid address, contact or wallet.</span>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/send/multi-send/multi-send.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_14__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["r" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_12__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_16__wallet_tabs_wallet_tabs_provider__["a" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_1__angular_common__["d" /* DecimalPipe */],
        __WEBPACK_IMPORTED_MODULE_15__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__["a" /* BwcProvider */]])
], MultiSendPage);

//# sourceMappingURL=multi-send.js.map

/***/ }),

/***/ 1038:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TransferToModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);



let TransferToModalPage = class TransferToModalPage {
    constructor(navParams, viewCtrl) {
        this.navParams = navParams;
        this.viewCtrl = viewCtrl;
        this.search = '';
        this.wallet = this.navParams.data.wallet;
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
TransferToModalPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-transfer-to-modal',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/send/transfer-to-modal/transfer-to-modal.html"*/'<ion-header>\n  <ion-navbar hideBackButton>\n    <ion-title>{{\'Transfer to\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button class="modal-close-button" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div>\n    <ion-searchbar placeholder="{{\'Search Wallets or Contacts\' | translate}}" [(ngModel)]="search"></ion-searchbar>\n  </div>\n\n  <page-transfer-to [wallet]="wallet" [searchInput]="search" [useAsModal]="true" (addRecipient)="close($event)"></page-transfer-to>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/send/transfer-to-modal/transfer-to-modal.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */]])
], TransferToModalPage);

//# sourceMappingURL=transfer-to-modal.js.map

/***/ }),

/***/ 1039:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxpDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__node_modules_angular_common__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_fee_fee__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_paypro_paypro__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__finish_finish__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_lodash__);






// providers












// pages


let TxpDetailsPage = class TxpDetailsPage {
    constructor(navParams, platformProvider, feeProvider, events, logger, popupProvider, walletProvider, onGoingProcessProvider, viewCtrl, configProvider, currencyProvider, profileProvider, txFormatProvider, translate, modalCtrl, decimalPipe, payproProvider, actionSheetProvider, bwcErrorProvider) {
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.feeProvider = feeProvider;
        this.events = events;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.walletProvider = walletProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.viewCtrl = viewCtrl;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.decimalPipe = decimalPipe;
        this.payproProvider = payproProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwsEventHandler = (walletId, type) => {
            __WEBPACK_IMPORTED_MODULE_19_lodash__["each"]([
                'TxProposalRejectedBy',
                'TxProposalAcceptedBy',
                'transactionProposalRemoved',
                'TxProposalRemoved',
                'NewOutgoingTx',
                'UpdateTx'
            ], (eventName) => {
                if (walletId == this.wallet.id && type == eventName) {
                    this.updateTxInfo(eventName);
                }
            });
        };
        this.showMultiplesOutputs = false;
        let config = this.configProvider.get().wallet;
        this.tx = this.navParams.data.tx;
        this.wallet = this.tx.wallet
            ? this.tx.wallet
            : this.profileProvider.getWallet(this.tx.walletId);
        this.tx = this.txFormatProvider.processTx(this.wallet.coin, this.tx);
        if (!this.tx.toAddress)
            this.tx.toAddress = this.tx.outputs[0].toAddress;
        this.currentSpendUnconfirmed = config.spendUnconfirmed;
        this.loading = false;
        this.isCordova = this.platformProvider.isCordova;
        this.copayers = this.wallet.cachedStatus.wallet.copayers;
        this.copayerId = this.wallet.credentials.copayerId;
        this.isShared = this.wallet.credentials.n > 1;
        this.canSign = this.wallet.canSign;
        this.color = this.wallet.color;
        this.hideSlideButton = false;
        // To test multiple outputs...
        // var txp = {
        //   message: 'test multi-output',
        //   fee: 1000,
        //   createdOn: Math.floor(Date.now() / 1000),
        //   outputs: [],
        // };
        // for (let i = 0; i < 15; i++) {
        //   txp.outputs.push({
        //     amountStr: "600 BTC",
        //     toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
        //     message: 'output #' + (Number(i) + 1)
        //   });
        // };
        // this.tx = _.merge(this.tx, txp);
        // this.tx.hasMultiplesOutputs = true;
    }
    ionViewDidLoad() {
        this.displayFeeValues();
        this.initActionList();
        this.checkPaypro();
        this.applyButtonText();
        this.amount = this.decimalPipe.transform(this.tx.amount /
            this.currencyProvider.getPrecision(this.wallet.coin).unitToSatoshi, '1.2-6');
    }
    ionViewWillLoad() {
        this.events.subscribe('bwsEvent', this.bwsEventHandler);
    }
    ionViewWillUnload() {
        this.events.unsubscribe('bwsEvent', this.bwsEventHandler);
    }
    displayFeeValues() {
        const chain = this.currencyProvider
            .getChain(this.wallet.coin)
            .toLowerCase();
        this.tx.feeFiatStr = this.txFormatProvider.formatAlternativeStr(chain, this.tx.fee);
        if (this.currencyProvider.isUtxoCoin(this.wallet.coin)) {
            this.tx.feeRateStr =
                ((this.tx.fee / (this.tx.amount + this.tx.fee)) * 100).toFixed(2) + '%';
        }
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelStr = feeOpts[this.tx.feeLevel];
    }
    applyButtonText() {
        var lastSigner = __WEBPACK_IMPORTED_MODULE_19_lodash__["filter"](this.tx.actions, {
            type: 'accept'
        }).length ==
            this.tx.requiredSignatures - 1;
        if (lastSigner) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to send')
                : this.translate.instant('Click to send');
            this.successText = this.translate.instant('Payment Sent');
        }
        else {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to accept')
                : this.translate.instant('Click to accept');
            this.successText = this.translate.instant('Payment Accepted');
        }
    }
    initActionList() {
        this.actionList = [];
        if (!this.isShared)
            return;
        var actionDescriptions = {
            created: this.translate.instant('Proposal Created'),
            accept: this.translate.instant('Accepted'),
            reject: this.translate.instant('Rejected'),
            broadcasted: this.translate.instant('Broadcasted')
        };
        this.actionList.push({
            type: 'created',
            time: this.tx.createdOn,
            description: actionDescriptions['created'],
            by: this.tx.creatorName
        });
        __WEBPACK_IMPORTED_MODULE_19_lodash__["each"](this.tx.actions, action => {
            this.actionList.push({
                type: action.type,
                time: action.createdOn,
                description: actionDescriptions[action.type],
                by: action.copayerName
            });
        });
        setTimeout(() => {
            this.actionList.reverse();
        }, 10);
    }
    checkPaypro() {
        if (this.tx.payProUrl) {
            const disableLoader = true;
            this.payproProvider
                .getPayProDetails(this.tx.payProUrl, this.tx.coin, disableLoader)
                .then(payProDetails => {
                this.tx.paypro = payProDetails;
                this.paymentTimeControl(this.tx.paypro.expires);
            })
                .catch(err => {
                this.logger.warn('Error in Payment Protocol: ', err);
                this.paymentExpired = true;
                this.showErrorInfoSheet(err, this.translate.instant('Error fetching this invoice'));
            });
        }
    }
    paymentTimeControl(expires) {
        const expirationTime = Math.floor(new Date(expires).getTime() / 1000);
        let setExpirationTime = () => {
            let now = Math.floor(Date.now() / 1000);
            if (now > expirationTime) {
                this.paymentExpired = true;
                if (this.countDown)
                    clearInterval(this.countDown);
                return;
            }
            let totalSecs = expirationTime - now;
            let m = Math.floor(totalSecs / 60);
            let s = totalSecs % 60;
            this.expires = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
        };
        this.paymentExpired = false;
        setExpirationTime();
        this.countDown = setInterval(() => {
            setExpirationTime();
        }, 1000);
    }
    showErrorInfoSheet(error, title) {
        this.loading = false;
        if (!error)
            return;
        this.logger.warn('ERROR:', error);
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        if (error.message === 'FINGERPRINT_CANCELLED' ||
            error.message === 'PASSWORD_CANCELLED') {
            this.hideSlideButton = false;
            return;
        }
        let infoSheetTitle = title ? title : this.translate.instant('Error');
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: this.bwcErrorProvider.msg(error), title: infoSheetTitle });
        errorInfoSheet.present();
        errorInfoSheet.onDidDismiss(() => {
            this.hideSlideButton = false;
        });
    }
    sign() {
        this.loading = true;
        this.hideSlideButton = true;
        this.walletProvider
            .publishAndSign(this.wallet, this.tx)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorInfoSheet(err, 'Could not send payment');
        });
    }
    reject() {
        let title = this.translate.instant('Warning!');
        let msg = this.translate.instant('Are you sure you want to reject this transaction?');
        this.popupProvider
            .ionicConfirm(title, msg, null, null)
            .then((res) => {
            if (!res)
                return;
            this.loading = true;
            this.onGoingProcessProvider.set('rejectTx');
            this.walletProvider
                .reject(this.wallet, this.tx)
                .then(() => {
                this.onGoingProcessProvider.clear();
                this.close();
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.showErrorInfoSheet(err, this.translate.instant('Could not reject payment'));
            });
        });
    }
    remove() {
        let title = this.translate.instant('Warning!');
        let msg = this.translate.instant('Are you sure you want to remove this transaction?');
        this.popupProvider
            .ionicConfirm(title, msg, null, null)
            .then((res) => {
            if (!res)
                return;
            this.onGoingProcessProvider.set('removeTx');
            this.walletProvider
                .removeTx(this.wallet, this.tx)
                .then(() => {
                this.onGoingProcessProvider.clear();
                this.close();
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                if (err && !(err.message && err.message.match(/Unexpected/))) {
                    this.showErrorInfoSheet(err, this.translate.instant('Could not delete payment proposal'));
                }
            });
        });
    }
    broadcast() {
        this.loading = true;
        this.onGoingProcessProvider.set('broadcastingTx');
        this.walletProvider
            .broadcastTx(this.wallet, this.tx)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorInfoSheet(err, 'Could not broadcast payment');
            this.logger.error('Could not broadcast: ', this.tx.coin, this.tx.network, this.tx.raw);
        });
    }
    getShortNetworkName() {
        return this.wallet.credentials.networkName.substring(0, 4);
    }
    updateTxInfo(eventName) {
        this.walletProvider
            .getTxp(this.wallet, this.tx.id)
            .then(tx => {
            let action = __WEBPACK_IMPORTED_MODULE_19_lodash__["find"](tx.actions, {
                copayerId: this.wallet.credentials.copayerId
            });
            this.tx = this.txFormatProvider.processTx(this.wallet.coin, tx);
            if (!action && tx.status == 'pending')
                this.tx.pendingForUs = true;
            this.updateCopayerList();
            this.initActionList();
        })
            .catch(err => {
            if (err.message &&
                err.message == 'Transaction proposal not found' &&
                (eventName == 'transactionProposalRemoved' ||
                    eventName == 'TxProposalRemoved')) {
                this.tx.removed = true;
                this.tx.canBeRemoved = false;
                this.tx.pendingForUs = false;
            }
        });
    }
    updateCopayerList() {
        __WEBPACK_IMPORTED_MODULE_19_lodash__["map"](this.copayers, (cp) => {
            __WEBPACK_IMPORTED_MODULE_19_lodash__["each"](this.tx.actions, ac => {
                if (cp.id == ac.copayerId) {
                    cp.action = ac.type;
                }
            });
        });
    }
    onConfirm() {
        this.sign();
    }
    close() {
        this.loading = false;
        this.hideSlideButton = false;
        this.viewCtrl.dismiss();
    }
    openFinishModal() {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_18__finish_finish__["a" /* FinishModalPage */], { finishText: this.successText }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => {
            this.close();
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], TxpDetailsPage.prototype, "slideButton", void 0);
TxpDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-txp-details',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/txp-details/txp-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>\n      {{\'Payment Proposal\' | translate}}\n    </ion-title>\n    <ion-buttons left>\n      <button class="modal-close-button" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce [ngClass]="{\'margin-bottom\':(tx && !tx.removed) && (tx && tx.pendingForUs && canSign && !paymentExpired)}">\n  <ion-list *ngIf="tx">\n    <ion-item>\n      <div class="header-container">\n        <div class="sending-label">\n          <span translate>Sending</span>\n        </div>\n        <div class="amount-label">\n          <div class="amount">\n            <div>\n              {{tx.amountValueStr}}\n              <span class="amount-coin">{{tx.amountUnitStr | uppercase}}</span>\n            </div>\n            <img class="sending-img" src="assets/img/icon-tx-sent-outline.svg">\n          </div>\n          <div class="alternative" *ngIf="tx.alternativeAmountStr">{{tx.alternativeAmountStr}}</div>\n        </div>\n      </div>\n    </ion-item>\n    <div *ngIf="tx && tx.removed" class="box-notification warning" text-wrap>\n      <span translate>The payment was removed by creator</span>\n    </div>\n    <div *ngIf="!currentSpendUnconfirmed && tx && tx.hasUnconfirmedInputs" class="box-notification warning" text-wrap>\n      <span translate>Warning: this transaction has unconfirmed inputs</span>\n    </div>\n\n    <div *ngIf="tx && tx.status != \'pending\'">\n      <div class="box-notification info" text-center *ngIf="tx && tx.status == \'accepted\'">\n        <div text-wrap translate>Payment accepted, but not yet broadcasted</div>\n        <button margin ion-button outline small icon-left (click)="broadcast(tx)" [disabled]="loading">\n          <ion-icon name="cloud-upload"></ion-icon>\n          <span translate>Broadcast Payment</span>\n        </button>\n      </div>\n      <div class="box-notification success" *ngIf="tx && tx.status == \'broadcasted\'" translate>\n        Payment Sent\n      </div>\n      <div class="box-notification warning" *ngIf="tx && tx.status ==\'rejected\'" translate>\n        Payment Rejected\n      </div>\n    </div>\n\n    <ion-item class="container-txp-info" *ngIf="tx && tx.feeStr && tx.action != \'received\'">\n      <div>{{\'Miner fee:\' | translate}}</div>\n      <b>{{tx.feeLevelName}}</b>\n      <div class="txp-info">\n        <span class="ellipsis comment">\n          <div>{{tx.feeStr}}</div>\n          <div>\n            {{tx.feeFiatStr}} &middot;\n            <span *ngIf="tx.feeRateStr">{{tx.feeRateStr}}\n              <span translate> of total amount</span>\n            </span>\n          </div>\n        </span>\n      </div>\n    </ion-item>\n\n    <div padding class="proposal-rejection" *ngIf="(tx && !tx.removed) && isShared && (tx && tx.pendingForUs) && !paymentExpired">\n      <button ion-button clear color="danger" (click)="reject()" [disabled]="loading">\n        {{\'Reject Payment Proposal\'| translate}}\n      </button>\n    </div>\n\n    <page-multiple-outputs [tx]="tx"></page-multiple-outputs>\n\n    <ion-item class="container-from">\n      <span translate>From</span>\n      <div class="wallet" *ngIf="wallet">\n        <img [ngClass]="{ testnet: wallet.network === \'testnet\' }" src="assets/img/currencies/{{wallet.coin}}.svg" class="icon-wallet" />\n        <div>{{wallet.name}}</div>\n      </div>\n    </ion-item>\n\n    <ion-item class="container-txp-info" *ngIf="isShared">\n      <span>{{\'Created by\' | translate}}</span>\n      <div class="txp-info">\n        <span class="ellipsis comment">\n          {{tx.creatorName}}\n        </span>\n      </div>\n    </ion-item>\n\n    <ion-item class="container-txp-info" *ngIf="tx && tx.ts || tx.createdOn">\n      <span>{{\'Date\' | translate}}</span>\n      <div class="txp-info">\n        <span class="ellipsis comment">\n          <time>{{ (tx.ts || tx.createdOn ) * 1000 | amDateFormat:\'MM/DD/YYYY hh:mm a\'}}</time>\n        </span>\n      </div>\n    </ion-item>\n\n    <ion-item class="container-txp-info" *ngIf="tx && tx.message">\n      <span translate>Memo</span>\n      <div class="txp-info">\n        <span class="ellipsis comment">{{tx.message}}</span>\n      </div>\n    </ion-item>\n\n    <div *ngIf="tx && tx.paypro">\n      <ion-item-divider>{{\'Payment request\' | translate}}</ion-item-divider>\n      <ion-item *ngIf="paymentExpired">\n        <ion-label>\n          {{\'Expired\'|translate}}\n        </ion-label>\n        <ion-note color="danger" item-end>\n          <time>{{tx.paypro.expires | amTimeAgo }}</time>\n        </ion-note>\n      </ion-item>\n      <ion-item *ngIf="!paymentExpired">\n        <ion-label>\n          {{\'Expires\'|translate}}\n        </ion-label>\n        <ion-note item-end>\n          <time>{{expires}}</time>\n        </ion-note>\n      </ion-item>\n      <ion-item *ngIf="tx.paypro.memo">\n        <span translate>Merchant Message</span>\n        <div class="item-memo" *ngIf="tx.paypro.memo" text-wrap>\n          <ion-note>{{tx.paypro.memo}}</ion-note>\n        </div>\n      </ion-item>\n    </div>\n\n    <div *ngIf="actionList && actionList[0]">\n      <ion-item>\n        <span>{{\'Timeline\' | translate}}</span>\n        <div class="timeline-item" [ngClass]="{\'action-created\' : a.type == \'created\' || a.type == \'accept\', \'action-rejected\' : a.type == \'reject\'}" *ngFor="let a of actionList; let i = index">\n          <div class="timeline-content">\n            <div class="timeline-content-icon">\n              <div class="rejected" *ngIf="a.type === \'reject\'">!</div>\n              <div class="line" *ngIf="a.type !== \'reject\'">{{actionList.length - i}}</div>\n            </div>\n            <div class="timeline-content-label">\n              <div class="action">{{a.description}}</div>\n              <div class="name">{{a.by}}</div>\n            </div>\n            <ion-note class="ellipsis">\n              <time>{{ a.time * 1000 | amTimeAgo}}</time>\n            </ion-note>\n          </div>\n        </div>\n      </ion-item>\n    </div>\n\n    <div padding class="proposal-deletion" *ngIf="((tx && !tx.removed) && (tx && tx.canBeRemoved)) || (tx && tx.status == \'accepted\' && !tx.broadcastedOn)">\n      <div class="proposal-deletion-help" *ngIf="isShared" translate>\n        * A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 10 minutes have passed since the proposal was created.\n      </div>\n      <button ion-button clear color="danger" (click)="remove()" [disabled]="loading">\n        {{\'Delete Payment Proposal\' | translate}}\n      </button>\n    </div>\n\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="(tx && !tx.removed) && (tx && tx.pendingForUs && canSign && !paymentExpired) && isCordova" [buttonText]="buttonText" (slideDone)="onConfirm()" [ngClass]="{\'slide-confirm-fast slide-confirm-down\': hideSlideButton, \'slide-confirm-slow\': !hideSlideButton}">\n  </page-slide-to-accept>\n  <ion-toolbar *ngIf="(tx && !tx.removed) && (tx && tx.pendingForUs && canSign && !paymentExpired) && !isCordova">\n    <button ion-button full class="button-footer" (click)="onConfirm()">{{buttonText}}</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/txp-details/txp-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_8__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_4__node_modules_angular_common__["d" /* DecimalPipe */],
        __WEBPACK_IMPORTED_MODULE_12__providers_paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */]])
], TxpDetailsPage);

//# sourceMappingURL=txp-details.js.map

/***/ }),

/***/ 1040:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WideHeaderPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_platform_platform__ = __webpack_require__(12);




let WideHeaderPage = class WideHeaderPage {
    constructor(platformProvider) {
        this.platformProvider = platformProvider;
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], WideHeaderPage.prototype, "headerColor", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], WideHeaderPage.prototype, "title", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Content */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Content */])
], WideHeaderPage.prototype, "scrollArea", void 0);
WideHeaderPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'wide-header-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/templates/wide-header-page/wide-header-page.html"*/'<ion-header class="wide-header" [ngClass]="{cordova: platformProvider.isCordova}">\n  <ion-navbar [navbar-bg]="headerColor">\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{title}}\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n<ion-content #scrollArea [fixed-scroll-bg-color]="headerColor" [ion-content-background-color]="headerColor">\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar [navbar-bg]="headerColor" class="wide-header__title">\n        <expandable-header-primary>\n          {{title}}\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n    <ng-content select="[page-content]"></ng-content>\n  </div>\n</ion-content>\n<ion-footer>\n  <ng-content select="[footer-content]"></ng-content>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/templates/wide-header-page/wide-header-page.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_platform_platform__["a" /* PlatformProvider */]])
], WideHeaderPage);

//# sourceMappingURL=wide-header-page.js.map

/***/ }),

/***/ 1041:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CardCatalogPage; });
/* unused harmony export isCardInSearchResults */
/* unused harmony export stripPunctuation */
/* unused harmony export sortByFeaturedAndAlphabetically */
/* unused harmony export getCatalogSortValue */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__buy_card_buy_card__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_gift_card_gift_card__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__templates_wide_header_page_wide_header_page__ = __webpack_require__(1040);








let CardCatalogPage = class CardCatalogPage extends __WEBPACK_IMPORTED_MODULE_7__templates_wide_header_page_wide_header_page__["a" /* WideHeaderPage */] {
    constructor(actionSheetProvider, giftCardProvider, platormProvider, navCtrl, translate) {
        super(platormProvider);
        this.actionSheetProvider = actionSheetProvider;
        this.giftCardProvider = giftCardProvider;
        this.navCtrl = navCtrl;
        this.translate = translate;
        this.searchQuery = '';
        this.visibleCards = [];
        this.getHeaderFn = this.getHeader.bind(this);
    }
    ngOnInit() {
        this.title = 'Gift Cards';
    }
    ionViewWillEnter() {
        this.giftCardProvider
            .getAvailableCards()
            .then(allCards => {
            this.cardConfigMap = allCards
                .sort(sortByFeaturedAndAlphabetically)
                .reduce((map, cardConfig) => (Object.assign({}, map, { [cardConfig.name]: cardConfig })), {});
            this.allCards = allCards;
            this.updateCardList();
        })
            .catch(_ => {
            this.showError();
            return [];
        });
    }
    ionViewDidEnter() {
        this.logGiftCardCatalogHomeView();
    }
    onSearch(query) {
        this.searchQuery = query;
        this.updateCardList();
    }
    getHeader(record, recordIndex, records) {
        if (record.featured && recordIndex === 0) {
            return this.translate.instant('Featured Brands');
        }
        const prevRecord = records[recordIndex - 1];
        if ((!record.featured && prevRecord && prevRecord.featured) ||
            (!record.featured && !prevRecord && this.searchQuery)) {
            return this.translate.instant('More Brands');
        }
        return null;
    }
    trackBy(record) {
        return record.name;
    }
    updateCardList() {
        this.visibleCards = this.allCards.filter(c => isCardInSearchResults(c, this.searchQuery));
    }
    buyCard(cardConfig) {
        this.logGiftCardBrandView(cardConfig);
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_3__buy_card_buy_card__["a" /* BuyCardPage */], { cardConfig });
        if (this.hasPercentageDiscount(cardConfig)) {
            this.logDiscountClick(cardConfig);
        }
    }
    logGiftCardCatalogHomeView() {
        this.giftCardProvider.logEvent('giftcards_view_home', {});
    }
    logGiftCardBrandView(cardConfig) {
        this.giftCardProvider.logEvent('giftcards_view_brand', {
            brand: cardConfig.name
        });
        this.giftCardProvider.logEvent('view_item', {
            items: [
                {
                    brand: cardConfig.name,
                    category: 'giftCards'
                }
            ]
        });
    }
    logDiscountClick(cardConfig) {
        this.giftCardProvider.logEvent('clickedGiftCardDiscount', this.giftCardProvider.getDiscountEventParams(cardConfig, 'Gift Card List'));
    }
    hasPercentageDiscount(cardConfig) {
        return Object(__WEBPACK_IMPORTED_MODULE_6__providers_gift_card_gift_card__["e" /* hasVisibleDiscount */])(cardConfig);
    }
    showError() {
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('gift-cards-unavailable');
        errorInfoSheet.present();
        errorInfoSheet.onDidDismiss(() => this.navCtrl.pop());
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_7__templates_wide_header_page_wide_header_page__["a" /* WideHeaderPage */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_7__templates_wide_header_page_wide_header_page__["a" /* WideHeaderPage */])
], CardCatalogPage.prototype, "wideHeaderPage", void 0);
CardCatalogPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'card-catalog-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/card-catalog/card-catalog.html"*/'<ion-header class="wide-header" [ngClass]="{cordova: platformProvider.isCordova}">\n  <ion-navbar [navbar-bg]="headerColor">\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{title}}\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n<ion-content #scrollArea [fixed-scroll-bg-color]="headerColor" [ion-content-background-color]="headerColor">\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar [navbar-bg]="headerColor" class="wide-header__title">\n        <expandable-header-primary>\n          {{title}}\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <search-bar [scrollArea]="wideHeaderPage?.scrollArea" (search)="onSearch($event.target.value)"\n      placeholder="Search Gift Cards"></search-bar>\n    <ion-list class="bp-list" [virtualScroll]="allCards" [approxItemHeight]="\'87px\'" [virtualTrackBy]="trackBy"\n      [headerFn]="getHeaderFn" [hidden]="searchQuery">\n\n      <ion-item-divider *virtualHeader="let header">\n        {{ header }}\n      </ion-item-divider>\n\n      <button ion-item class="card-list-item" *virtualItem="let card" (click)="buyCard(card)">\n        <ion-icon item-start>\n          <img-loader class="card-list-item__icon" [src]="cardConfigMap[card.name]?.icon" [fallbackAsPlaceholder]="true"\n            [fallbackUrl]="giftCardProvider.fallbackIcon"></img-loader>\n        </ion-icon>\n        <ion-label>\n\n          <div *ngIf="cardConfigMap">\n            <div class="card-list-item__label ellipsis">\n              {{ cardConfigMap[card.name].displayName }}\n            </div>\n            <ion-note class="card-list-item__note" *ngIf="!cardConfigMap[card.name].supportedAmounts">\n              {{ cardConfigMap[card.name].minAmount | formatCurrency: cardConfigMap[card.name].currency:0 }} \n              {{ cardConfigMap[card.name].maxAmount | formatCurrency: cardConfigMap[card.name].currency:0 }}\n            </ion-note>\n            <ion-note class="card-list-item__note ellipsis" *ngIf="cardConfigMap[card.name].supportedAmounts">\n              <span *ngFor="\n                    let amount of cardConfigMap[card.name].supportedAmounts;\n                    let last = last\n                  ">\n                {{ amount | formatCurrency: cardConfigMap[card.name].currency:\'minimal\'\n                }}<span *ngIf="!last">,</span>\n              </span>\n            </ion-note>\n          </div>\n        </ion-label>\n        <ion-note item-end class="discount" *ngIf="hasPercentageDiscount(card)">Save <gift-card-discount-text\n            [cardConfig]="card" [discount]="card.discounts[0]"></gift-card-discount-text>\n        </ion-note>\n\n      </button>\n\n    </ion-list>\n\n    <ion-list class="bp-list" [virtualScroll]="visibleCards" [approxItemHeight]="\'87px\'" [virtualTrackBy]="trackBy">\n\n      <button ion-item class="card-list-item" *virtualItem="let card" (click)="buyCard(card)">\n        <ion-icon item-start>\n          <img-loader class="card-list-item__icon" [src]="cardConfigMap[card.name]?.icon" [fallbackAsPlaceholder]="true"\n            [fallbackUrl]="giftCardProvider.fallbackIcon"></img-loader>\n        </ion-icon>\n        <ion-label>\n\n          <div *ngIf="cardConfigMap">\n            <div class="card-list-item__label ellipsis">\n              {{ cardConfigMap[card.name].displayName }}\n            </div>\n            <ion-note class="card-list-item__note" *ngIf="!cardConfigMap[card.name].supportedAmounts">\n              {{ cardConfigMap[card.name].minAmount | formatCurrency: cardConfigMap[card.name].currency:0 }} \n              {{ cardConfigMap[card.name].maxAmount | formatCurrency: cardConfigMap[card.name].currency:0 }}\n            </ion-note>\n            <ion-note class="card-list-item__note ellipsis" *ngIf="cardConfigMap[card.name].supportedAmounts">\n              <span *ngFor="\n                    let amount of cardConfigMap[card.name].supportedAmounts;\n                    let last = last\n                  ">\n                {{ amount | formatCurrency: cardConfigMap[card.name].currency:\'minimal\'\n                }}<span *ngIf="!last">,</span>\n              </span>\n            </ion-note>\n          </div>\n        </ion-label>\n        <ion-note item-end class="discount" *ngIf="hasPercentageDiscount(card)">Save\n          <gift-card-discount-text [cardConfig]="card" [discount]="card.discounts[0]"></gift-card-discount-text>\n        </ion-note>\n      </button>\n\n    </ion-list>\n\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/card-catalog/card-catalog.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_gift_card_gift_card__["a" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["R" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__["f" /* TranslateService */]])
], CardCatalogPage);

function isCardInSearchResults(c, search = '') {
    const cardName = (c.displayName || c.name).toLowerCase();
    const query = search.toLowerCase();
    const matchableText = [cardName, stripPunctuation(cardName)];
    return search && matchableText.some(text => text.indexOf(query) > -1);
}
function stripPunctuation(text) {
    return text.replace(/[^\w\s]|_/g, '');
}
function sortByFeaturedAndAlphabetically(a, b) {
    return getCatalogSortValue(a) > getCatalogSortValue(b) ? 1 : -1;
}
function getCatalogSortValue(cardConfig) {
    return `${cardConfig.featured ? 'a' : 'b'}${Object(__WEBPACK_IMPORTED_MODULE_6__providers_gift_card_gift_card__["c" /* getDisplayNameSortValue */])(cardConfig.displayName)}`;
}
//# sourceMappingURL=card-catalog.js.map

/***/ }),

/***/ 1042:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser_dynamic__ = __webpack_require__(1043);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_web_animations_js_web_animations_min__ = __webpack_require__(1047);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_web_animations_js_web_animations_min___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_web_animations_js_web_animations_min__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app_module__ = __webpack_require__(1048);

// tslint:disable-next-line:no-submodule-imports


Object(__WEBPACK_IMPORTED_MODULE_0__angular_platform_browser_dynamic__["a" /* platformBrowserDynamic */])().bootstrapModule(__WEBPACK_IMPORTED_MODULE_2__app_module__["a" /* AppModule */]);
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 1048:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export translateParserFactory */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser_animations__ = __webpack_require__(1049);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_image_loader__ = __webpack_require__(343);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ngx_markdown__ = __webpack_require__(652);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ngx_markdown___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_ngx_markdown__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__angular_platform_browser__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__zxing_ngx_scanner__ = __webpack_require__(1107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_angular2_moment__ = __webpack_require__(1407);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_angular2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_angular2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ngx_barcode__ = __webpack_require__(1410);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_ngx_qrcode2__ = __webpack_require__(1446);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__environments__ = __webpack_require__(424);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__app_component__ = __webpack_require__(1469);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__pages_pages__ = __webpack_require__(1990);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__pipes_fiatToUnit__ = __webpack_require__(2012);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__pipes_format_currency__ = __webpack_require__(990);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__pipes_keys__ = __webpack_require__(2013);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__pipes_order_by__ = __webpack_require__(2014);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__pipes_satToFiat__ = __webpack_require__(2015);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__pipes_satToUnit__ = __webpack_require__(2016);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__directives_animate_animate__ = __webpack_require__(469);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__directives_copy_to_clipboard_copy_to_clipboard__ = __webpack_require__(2017);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__directives_externalize_links_externalize_links__ = __webpack_require__(2018);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__directives_fixed_scroll_bg_color_fixed_scroll_bg_color__ = __webpack_require__(2019);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__directives_ion_content_background_color_ion_content_background_color__ = __webpack_require__(2020);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__directives_long_press_long_press__ = __webpack_require__(2021);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__directives_navbar_bg_navbar_bg__ = __webpack_require__(2022);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__directives_no_low_fee_no_low_fee__ = __webpack_require__(2023);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__directives_reveal_at_scroll_pos_reveal_at_scroll_pos__ = __webpack_require__(2024);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__directives_scrolled_into_view_scrolled_into_view__ = __webpack_require__(2025);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__pages_templates_wide_header_page_wide_header_bar_button__ = __webpack_require__(2026);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__components_components__ = __webpack_require__(2027);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__providers_language_loader_language_loader__ = __webpack_require__(978);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__providers_providers_module__ = __webpack_require__(2040);








/* Modules */





/* Copay App */



/* Pipes */






/* Directives */











/* Components */

/* Providers */


function translateParserFactory() {
    return new InterpolatedTranslateParser();
}
class InterpolatedTranslateParser extends __WEBPACK_IMPORTED_MODULE_8__ngx_translate_core__["b" /* TranslateDefaultParser */] {
    constructor() {
        super(...arguments);
        this.templateMatcher = /{\s?([^{}\s]*)\s?}/g;
    }
}
/* unused harmony export InterpolatedTranslateParser */

class MyMissingTranslationHandler {
    constructor() {
        this.parser = translateParserFactory();
    }
    handle(params) {
        return this.parser.interpolate(params.key, params.interpolateParams);
    }
}
/* unused harmony export MyMissingTranslationHandler */

let AppModule = class AppModule {
    constructor(config) {
        this.config = config;
    }
};
AppModule = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_5__angular_core__["NgModule"])({
        declarations: [
            __WEBPACK_IMPORTED_MODULE_14__app_component__["a" /* CopayApp */],
            ...__WEBPACK_IMPORTED_MODULE_15__pages_pages__["a" /* PAGES */],
            ...__WEBPACK_IMPORTED_MODULE_33__components_components__["a" /* COMPONENTS */],
            /* Directives */
            __WEBPACK_IMPORTED_MODULE_23__directives_copy_to_clipboard_copy_to_clipboard__["a" /* CopyToClipboard */],
            __WEBPACK_IMPORTED_MODULE_24__directives_externalize_links_externalize_links__["a" /* ExternalizeLinks */],
            __WEBPACK_IMPORTED_MODULE_25__directives_fixed_scroll_bg_color_fixed_scroll_bg_color__["a" /* FixedScrollBgColor */],
            __WEBPACK_IMPORTED_MODULE_26__directives_ion_content_background_color_ion_content_background_color__["a" /* IonContentBackgroundColor */],
            __WEBPACK_IMPORTED_MODULE_27__directives_long_press_long_press__["a" /* LongPress */],
            __WEBPACK_IMPORTED_MODULE_28__directives_navbar_bg_navbar_bg__["a" /* NavbarBg */],
            __WEBPACK_IMPORTED_MODULE_29__directives_no_low_fee_no_low_fee__["a" /* NoLowFee */],
            __WEBPACK_IMPORTED_MODULE_22__directives_animate_animate__["a" /* Animate */],
            __WEBPACK_IMPORTED_MODULE_30__directives_reveal_at_scroll_pos_reveal_at_scroll_pos__["a" /* RevealAtScrollPosition */],
            __WEBPACK_IMPORTED_MODULE_31__directives_scrolled_into_view_scrolled_into_view__["a" /* ScrolledIntoView */],
            __WEBPACK_IMPORTED_MODULE_32__pages_templates_wide_header_page_wide_header_bar_button__["a" /* WideHeaderBarButton */],
            /* Pipes */
            __WEBPACK_IMPORTED_MODULE_16__pipes_fiatToUnit__["a" /* FiatToUnitPipe */],
            __WEBPACK_IMPORTED_MODULE_17__pipes_format_currency__["a" /* FormatCurrencyPipe */],
            __WEBPACK_IMPORTED_MODULE_18__pipes_keys__["a" /* KeysPipe */],
            __WEBPACK_IMPORTED_MODULE_21__pipes_satToUnit__["a" /* SatToUnitPipe */],
            __WEBPACK_IMPORTED_MODULE_20__pipes_satToFiat__["a" /* SatToFiatPipe */],
            __WEBPACK_IMPORTED_MODULE_19__pipes_order_by__["a" /* OrderByPipe */]
        ],
        imports: [
            __WEBPACK_IMPORTED_MODULE_7_ionic_angular__["i" /* IonicModule */].forRoot(__WEBPACK_IMPORTED_MODULE_14__app_component__["a" /* CopayApp */], {
                animate: __WEBPACK_IMPORTED_MODULE_13__environments__["a" /* default */].enableAnimations,
                tabsHideOnSubPages: true,
                tabsPlacement: 'bottom',
                backButtonIcon: 'arrow-round-back',
                backButtonText: ''
            }),
            __WEBPACK_IMPORTED_MODULE_3_ionic_image_loader__["c" /* IonicImageLoader */].forRoot(),
            __WEBPACK_IMPORTED_MODULE_6__angular_platform_browser__["a" /* BrowserModule */],
            __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser_animations__["a" /* BrowserAnimationsModule */],
            __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["b" /* HttpClientModule */],
            __WEBPACK_IMPORTED_MODULE_4_ngx_markdown__["MarkdownModule"].forRoot(),
            __WEBPACK_IMPORTED_MODULE_10_angular2_moment__["MomentModule"],
            __WEBPACK_IMPORTED_MODULE_11_ngx_barcode__["a" /* NgxBarcodeModule */],
            __WEBPACK_IMPORTED_MODULE_12_ngx_qrcode2__["a" /* NgxQRCodeModule */],
            __WEBPACK_IMPORTED_MODULE_35__providers_providers_module__["a" /* ProvidersModule */],
            __WEBPACK_IMPORTED_MODULE_8__ngx_translate_core__["d" /* TranslateModule */].forRoot({
                parser: { provide: __WEBPACK_IMPORTED_MODULE_8__ngx_translate_core__["e" /* TranslateParser */], useFactory: translateParserFactory },
                missingTranslationHandler: {
                    provide: __WEBPACK_IMPORTED_MODULE_8__ngx_translate_core__["a" /* MissingTranslationHandler */],
                    useClass: MyMissingTranslationHandler
                },
                loader: {
                    provide: __WEBPACK_IMPORTED_MODULE_8__ngx_translate_core__["c" /* TranslateLoader */],
                    useClass: __WEBPACK_IMPORTED_MODULE_34__providers_language_loader_language_loader__["a" /* LanguageLoader */]
                }
            }),
            __WEBPACK_IMPORTED_MODULE_9__zxing_ngx_scanner__["a" /* ZXingScannerModule */].forRoot()
        ],
        bootstrap: [__WEBPACK_IMPORTED_MODULE_7_ionic_angular__["g" /* IonicApp */]],
        entryComponents: [__WEBPACK_IMPORTED_MODULE_14__app_component__["a" /* CopayApp */], ...__WEBPACK_IMPORTED_MODULE_15__pages_pages__["a" /* PAGES */], ...__WEBPACK_IMPORTED_MODULE_33__components_components__["a" /* COMPONENTS */]],
        providers: [
            {
                provide: __WEBPACK_IMPORTED_MODULE_5__angular_core__["ErrorHandler"],
                useClass: __WEBPACK_IMPORTED_MODULE_7_ionic_angular__["h" /* IonicErrorHandler */]
            },
            __WEBPACK_IMPORTED_MODULE_17__pipes_format_currency__["a" /* FormatCurrencyPipe */]
        ]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7_ionic_angular__["d" /* Config */]])
], AppModule);

//# sourceMappingURL=app.module.js.map

/***/ }),

/***/ 108:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_bwc_bwc__ = __webpack_require__(46);


// Providers

let AddressProvider = class AddressProvider {
    constructor(bwcProvider) {
        this.bwcProvider = bwcProvider;
        this.bitcore = this.bwcProvider.getBitcore();
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.core = this.bwcProvider.getCore();
    }
    extractAddress(str) {
        const extractedAddress = str.replace(/^[a-z]+:/i, '').replace(/\?.*/, '');
        return extractedAddress;
    }
    getCoinAndNetwork(str, network = 'livenet') {
        const address = this.extractAddress(str);
        try {
            network = this.bitcore.Address(address).network.name;
            return { coin: 'btc', network };
        }
        catch (e) {
            try {
                network = this.bitcoreCash.Address(address).network.name;
                return { coin: 'bch', network };
            }
            catch (e) {
                try {
                    const isValidEthAddress = this.core.Validation.validateAddress('ETH', network, address);
                    if (isValidEthAddress) {
                        return { coin: 'eth', network };
                    }
                    else {
                        return null;
                    }
                }
                catch (e) {
                    return null;
                }
            }
        }
    }
    isValid(str) {
        // Check if the input is a valid uri or address
        const URI = this.bitcore.URI;
        const Address = this.bitcore.Address;
        const URICash = this.bitcoreCash.URI;
        const AddressCash = this.bitcoreCash.Address;
        const AddressEth = this.core.Validation;
        // Bip21 uri
        if (URI.isValid(str))
            return true;
        if (URICash.isValid(str))
            return true;
        if (AddressEth.validateUri('ETH', str))
            return true;
        // Regular Address: try Bitcoin and Bitcoin Cash
        if (Address.isValid(str, 'livenet'))
            return true;
        if (Address.isValid(str, 'testnet'))
            return true;
        if (AddressCash.isValid(str, 'livenet'))
            return true;
        if (AddressCash.isValid(str, 'testnet'))
            return true;
        if (AddressEth.validateAddress('ETH', 'livenet', str))
            return true;
        return false;
    }
};
AddressProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_bwc_bwc__["a" /* BwcProvider */]])
], AddressProvider);

//# sourceMappingURL=address.js.map

/***/ }),

/***/ 113:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HomeIntegrationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);





const exchangeList = [{ name: 'coinbase' }, { name: 'shapeshift' }];
let HomeIntegrationsProvider = class HomeIntegrationsProvider {
    constructor(http, logger) {
        this.http = http;
        this.logger = logger;
        this.logger.debug('HomeIntegrationsProviders initialized');
        this.services = [];
    }
    register(serviceInfo) {
        // Check if already exists
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.services, { name: serviceInfo.name }))
            return;
        this.logger.info('Adding home Integrations entry:' + serviceInfo.name);
        this.services.push(serviceInfo);
    }
    unregister(serviceName) {
        this.services = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.services, x => {
            return x.name != serviceName;
        });
    }
    updateLink(serviceName, token) {
        this.services = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.services, x => {
            if (x.name == serviceName)
                x.linked = !!token;
            return x;
        });
    }
    updateConfig(serviceName, show) {
        this.services = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.services, x => {
            if (x.name == serviceName)
                x.show = !!show;
            return x;
        });
    }
    shouldShowInHome(serviceName) {
        const service = this.services.find(i => i.name === serviceName);
        if (service && service.name === 'debitcard')
            return service && service.show && !service.linked;
        else
            return service && service.show;
    }
    get() {
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["orderBy"](this.services, ['name'], ['asc']);
    }
    getAvailableExchange() {
        let exchangeServices = __WEBPACK_IMPORTED_MODULE_4_lodash__["intersectionBy"](this.services, exchangeList, 'name');
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](exchangeServices, { linked: true, show: true });
    }
};
HomeIntegrationsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], HomeIntegrationsProvider);

//# sourceMappingURL=home-integrations.js.map

/***/ }),

/***/ 114:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeeProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);




// providers



let FeeProvider = class FeeProvider {
    constructor(configProvider, logger, bwcProvider, translate) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.translate = translate;
        this.CACHE_TIME_TS = 60;
        this.cache = {
            updateTs: 0,
            coin: ''
        };
        this.logger.debug('FeeProvider initialized');
    }
    getFeeOpts() {
        const feeOpts = {
            urgent: this.translate.instant('Urgent'),
            priority: this.translate.instant('Priority'),
            normal: this.translate.instant('Normal'),
            economy: this.translate.instant('Economy'),
            superEconomy: this.translate.instant('Super Economy'),
            custom: this.translate.instant('Custom')
        };
        return feeOpts;
    }
    getCurrentFeeLevel() {
        return this.configProvider.get().wallet.settings.feeLevel || 'normal';
    }
    getFeeRate(coin, network, feeLevel) {
        return new Promise((resolve, reject) => {
            if (feeLevel == 'custom')
                return resolve();
            network = network || 'livenet';
            this.getFeeLevels(coin)
                .then(response => {
                let feeLevelRate;
                feeLevelRate = __WEBPACK_IMPORTED_MODULE_6_lodash__["find"](response.levels[network], o => {
                    return o.level == feeLevel;
                });
                if (!feeLevelRate || !feeLevelRate.feePerKb) {
                    let msg = this.translate.instant('Could not get dynamic fee for level:') +
                        ' ' +
                        feeLevel;
                    return reject(msg);
                }
                let feeRate = feeLevelRate.feePerKb;
                if (!response.fromCache)
                    this.logger.debug('Dynamic fee: ' +
                        feeLevel +
                        '/' +
                        network +
                        ' ' +
                        (feeLevelRate.feePerKb / 1000).toFixed() +
                        ' SAT/B');
                return resolve(feeRate);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getFeeLevels(coin) {
        return new Promise((resolve, reject) => {
            coin = coin || 'btc';
            if (this.cache.coin == coin &&
                this.cache.updateTs > Date.now() - this.CACHE_TIME_TS * 1000) {
                return resolve({ levels: this.cache.data, fromCache: true });
            }
            let walletClient = this.bwcProvider.getClient(null, {});
            walletClient.getFeeLevels(coin, 'livenet', (errLivenet, levelsLivenet) => {
                if (errLivenet) {
                    return reject(this.translate.instant('Could not get dynamic fee'));
                }
                walletClient.getFeeLevels(coin, 'testnet', (errTestnet, levelsTestnet) => {
                    if (errTestnet) {
                        return reject(this.translate.instant('Could not get dynamic fee'));
                    }
                    this.cache.updateTs = Date.now();
                    this.cache.coin = coin;
                    this.cache.data = {
                        livenet: levelsLivenet,
                        testnet: levelsTestnet
                    };
                    return resolve({ levels: this.cache.data });
                });
            });
        });
    }
};
FeeProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], FeeProvider);

//# sourceMappingURL=fee.js.map

/***/ }),

/***/ 115:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PushNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_fcm_ng__ = __webpack_require__(426);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_fcm_ng___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_fcm_ng__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_lodash__);







// providers






let PushNotificationsProvider = class PushNotificationsProvider {
    constructor(http, profileProvider, platformProvider, configProvider, logger, appProvider, bwcProvider, FCMPlugin, events) {
        this.http = http;
        this.profileProvider = profileProvider;
        this.platformProvider = platformProvider;
        this.configProvider = configProvider;
        this.logger = logger;
        this.appProvider = appProvider;
        this.bwcProvider = bwcProvider;
        this.FCMPlugin = FCMPlugin;
        this.events = events;
        this._token = null;
        this.logger.debug('PushNotificationsProvider initialized');
        this.isIOS = this.platformProvider.isIOS;
        this.isAndroid = this.platformProvider.isAndroid;
        this.usePushNotifications = this.platformProvider.isCordova;
    }
    init() {
        if (!this.usePushNotifications || this._token)
            return;
        this.configProvider.load().then(() => {
            const config = this.configProvider.get();
            if (!config.pushNotificationsEnabled)
                return;
            this.logger.debug('Starting push notification registration...');
            // Keep in mind the function will return null if the token has not been established yet.
            this.FCMPlugin.getToken().then(token => {
                if (!token) {
                    setTimeout(() => {
                        this.init();
                    }, 5000);
                    return;
                }
                this.logger.debug('Get token for push notifications: ' + token);
                this._token = token;
                this.enable();
                // enabling topics
                this.handlePushNotifications();
                if (config.offersAndPromotions.enabled)
                    this.subscribeToTopic('offersandpromotions');
                if (config.productsUpdates.enabled)
                    this.subscribeToTopic('productsupdates');
            });
        });
    }
    handlePushNotifications() {
        if (this.usePushNotifications) {
            this.FCMPlugin.onNotification().subscribe((data) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
                if (!this._token)
                    return;
                this.logger.debug('New Event Push onNotification: ' + JSON.stringify(data));
                if (data.wasTapped) {
                    // Notification was received on device tray and tapped by the user.
                    const walletIdHashed = data.walletId;
                    if (!walletIdHashed)
                        return;
                    this._openWallet(walletIdHashed);
                }
            }));
        }
    }
    updateSubscription(walletClient) {
        if (!this._token) {
            this.logger.warn('Push notifications disabled for this device. Nothing to do here.');
            return;
        }
        if (!__WEBPACK_IMPORTED_MODULE_12_lodash__["isArray"](walletClient))
            walletClient = [walletClient];
        walletClient.forEach(w => {
            this._subscribe(w);
        });
    }
    enable() {
        if (!this._token) {
            this.logger.warn('No token available for this device. Cannot set push notifications. Needs registration.');
            return;
        }
        const opts = {
            showHidden: true
        };
        const wallets = this.profileProvider.getWallets(opts);
        __WEBPACK_IMPORTED_MODULE_12_lodash__["forEach"](wallets, walletClient => {
            this._subscribe(walletClient);
        });
    }
    disable() {
        if (!this._token) {
            this.logger.warn('No token available for this device. Cannot disable push notifications.');
            return;
        }
        // disabling topics
        this.unsubscribeFromTopic('offersandpromotions');
        this.unsubscribeFromTopic('productsupdates');
        const opts = {
            showHidden: true
        };
        const wallets = this.profileProvider.getWallets(opts);
        __WEBPACK_IMPORTED_MODULE_12_lodash__["forEach"](wallets, walletClient => {
            this._unsubscribe(walletClient);
        });
        this._token = null;
    }
    unsubscribe(walletClient) {
        if (!this._token)
            return;
        this._unsubscribe(walletClient);
    }
    subscribeToTopic(topic) {
        this.FCMPlugin.subscribeToTopic(topic);
    }
    unsubscribeFromTopic(topic) {
        this.FCMPlugin.unsubscribeFromTopic(topic);
    }
    _subscribe(walletClient) {
        const opts = {
            token: this._token,
            platform: this.isIOS ? 'ios' : this.isAndroid ? 'android' : null,
            packageName: this.appProvider.info.packageNameId
        };
        walletClient.pushNotificationsSubscribe(opts, err => {
            if (err)
                this.logger.error(walletClient.name + ': Subscription Push Notifications error. ', err.message);
            else
                this.logger.debug(walletClient.name + ': Subscription Push Notifications success.');
        });
    }
    _unsubscribe(walletClient) {
        walletClient.pushNotificationsUnsubscribe(this._token, err => {
            if (err)
                this.logger.error(walletClient.name + ': Unsubscription Push Notifications error. ', err.message);
            else
                this.logger.debug(walletClient.name + ': Unsubscription Push Notifications Success.');
        });
    }
    _openWallet(walletIdHashed) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const wallet = this.findWallet(walletIdHashed);
            if (!wallet)
                return;
            yield __WEBPACK_IMPORTED_MODULE_5_rxjs__["Observable"].timer(1000).toPromise(); // wait for subscription to OpenWallet event
            this.events.publish('OpenWallet', wallet);
        });
    }
    findWallet(walletIdHashed) {
        let walletIdHash;
        const sjcl = this.bwcProvider.getSJCL();
        const wallets = this.profileProvider.getWallets();
        const wallet = __WEBPACK_IMPORTED_MODULE_12_lodash__["find"](wallets, w => {
            walletIdHash = sjcl.hash.sha256.hash(w.credentials.walletId);
            return __WEBPACK_IMPORTED_MODULE_12_lodash__["isEqual"](walletIdHashed, sjcl.codec.hex.fromBits(walletIdHash));
        });
        return wallet;
    }
    clearAllNotifications() {
        if (!this._token)
            return;
        this.FCMPlugin.clearAllNotifications();
    }
};
PushNotificationsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_11__profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_10__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_9__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_8__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_3_fcm_ng__["FCMNG"],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */]])
], PushNotificationsProvider);

//# sourceMappingURL=push-notifications.js.map

/***/ }),

/***/ 12:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PlatformProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);





let PlatformProvider = class PlatformProvider {
    constructor(platform, logger, device) {
        this.platform = platform;
        this.logger = logger;
        this.device = device;
        let ua = navigator ? navigator.userAgent : null;
        if (!ua) {
            this.logger.info('Could not determine navigator. Using fixed string');
            ua = 'dummy user-agent';
        }
        // Fixes IOS WebKit UA
        ua = ua.replace(/\(\d+\)$/, '');
        this.isAndroid = this.platform.is('android');
        this.isIOS = this.platform.is('ios');
        this.ua = ua;
        this.isCordova = this.platform.is('cordova');
        this.isElectron = this.isElectronPlatform();
        this.isMobile = this.platform.is('mobile');
        this.isDevel = !this.isMobile && !this.isElectron;
        this.logger.debug('PlatformProvider initialized');
    }
    getBrowserName() {
        let userAgent = window.navigator.userAgent;
        let browsers = {
            chrome: /chrome/i,
            safari: /safari/i,
            firefox: /firefox/i,
            ie: /internet explorer/i
        };
        for (let key in browsers) {
            if (browsers[key].test(userAgent)) {
                return key;
            }
        }
        return 'unknown';
    }
    isElectronPlatform() {
        const userAgent = navigator && navigator.userAgent
            ? navigator.userAgent.toLowerCase()
            : null;
        if (userAgent && userAgent.indexOf('electron/') > -1) {
            return true;
        }
        else {
            return false;
        }
    }
    getOS() {
        let OS = {
            OSName: '',
            extension: ''
        };
        if (this.isElectron) {
            if (navigator.appVersion.indexOf('Win') != -1) {
                OS.OSName = 'Windows';
                OS.extension = '.exe';
            }
            if (navigator.appVersion.indexOf('Mac') != -1) {
                OS.OSName = 'MacOS';
                OS.extension = '.dmg';
            }
            if (navigator.appVersion.indexOf('Linux') != -1) {
                OS.OSName = 'Linux';
                OS.extension = '-linux.zip';
            }
        }
        return OS;
    }
    getDeviceInfo() {
        let info;
        if (this.isElectron) {
            info = ' (' + navigator.appVersion + ')';
        }
        else {
            info =
                ' (' +
                    this.device.platform +
                    ' ' +
                    this.device.version +
                    ' - ' +
                    this.device.model +
                    ')';
        }
        return info;
    }
};
PlatformProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__["a" /* Device */]])
], PlatformProvider);

//# sourceMappingURL=platform.js.map

/***/ }),

/***/ 121:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressBookProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__address_address__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);







let AddressBookProvider = class AddressBookProvider {
    constructor(logger, persistenceProvider, translate, addressProvider) {
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.addressProvider = addressProvider;
        this.logger.debug('AddressBookProvider initialized');
    }
    get(addr) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook('testnet')
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                if (ab && ab[addr])
                    return resolve(ab[addr]);
                this.persistenceProvider
                    .getAddressBook('livenet')
                    .then(ab => {
                    if (ab && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                        ab = JSON.parse(ab);
                    if (ab && ab[addr])
                        return resolve(ab[addr]);
                    return resolve();
                })
                    .catch(() => {
                    return reject();
                });
            })
                .catch(() => {
                return reject();
            });
        });
    }
    list() {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook('testnet')
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                ab = ab || {};
                this.persistenceProvider
                    .getAddressBook('livenet')
                    .then(ab2 => {
                    if (ab2 && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                        ab2 = JSON.parse(ab2);
                    ab2 = ab2 || {};
                    return resolve(__WEBPACK_IMPORTED_MODULE_6_lodash__["defaults"](ab2, ab));
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(() => {
                let msg = this.translate.instant('Could not get the Addressbook');
                return reject(msg);
            });
        });
    }
    add(entry) {
        return new Promise((resolve, reject) => {
            const addrData = this.addressProvider.getCoinAndNetwork(entry.address);
            if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](addrData)) {
                let msg = this.translate.instant('Not valid bitcoin address');
                return reject(msg);
            }
            this.persistenceProvider
                .getAddressBook(addrData.network)
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                ab = ab || {};
                if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isArray"](ab))
                    ab = {}; // No array
                if (ab[entry.address]) {
                    let msg = this.translate.instant('Entry already exist');
                    return reject(msg);
                }
                ab[entry.address] = entry;
                this.persistenceProvider
                    .setAddressBook(addrData.network, JSON.stringify(ab))
                    .then(() => {
                    this.list()
                        .then(ab => {
                        return resolve(ab);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(() => {
                    let msg = this.translate.instant('Error adding new entry');
                    return reject(msg);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    remove(addr) {
        return new Promise((resolve, reject) => {
            const addrData = this.addressProvider.getCoinAndNetwork(addr);
            if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](addrData)) {
                let msg = this.translate.instant('Not valid bitcoin address');
                return reject(msg);
            }
            this.persistenceProvider
                .getAddressBook(addrData.network)
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                ab = ab || {};
                if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](ab)) {
                    let msg = this.translate.instant('Addressbook is empty');
                    return reject(msg);
                }
                if (!ab[addr]) {
                    let msg = this.translate.instant('Entry does not exist');
                    return reject(msg);
                }
                delete ab[addr];
                this.persistenceProvider
                    .setAddressBook(addrData.network, JSON.stringify(ab))
                    .then(() => {
                    this.list()
                        .then(ab => {
                        return resolve(ab);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(() => {
                    let msg = this.translate.instant('Error deleting entry');
                    return reject(msg);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
};
AddressBookProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__address_address__["a" /* AddressProvider */]])
], AddressBookProvider);

//# sourceMappingURL=address-book.js.map

/***/ }),

/***/ 1408:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 697,
	"./af.js": 697,
	"./ar": 698,
	"./ar-dz": 699,
	"./ar-dz.js": 699,
	"./ar-kw": 700,
	"./ar-kw.js": 700,
	"./ar-ly": 701,
	"./ar-ly.js": 701,
	"./ar-ma": 702,
	"./ar-ma.js": 702,
	"./ar-sa": 703,
	"./ar-sa.js": 703,
	"./ar-tn": 704,
	"./ar-tn.js": 704,
	"./ar.js": 698,
	"./az": 705,
	"./az.js": 705,
	"./be": 706,
	"./be.js": 706,
	"./bg": 707,
	"./bg.js": 707,
	"./bm": 708,
	"./bm.js": 708,
	"./bn": 709,
	"./bn.js": 709,
	"./bo": 710,
	"./bo.js": 710,
	"./br": 711,
	"./br.js": 711,
	"./bs": 712,
	"./bs.js": 712,
	"./ca": 713,
	"./ca.js": 713,
	"./cs": 714,
	"./cs.js": 714,
	"./cv": 715,
	"./cv.js": 715,
	"./cy": 716,
	"./cy.js": 716,
	"./da": 717,
	"./da.js": 717,
	"./de": 718,
	"./de-at": 719,
	"./de-at.js": 719,
	"./de-ch": 720,
	"./de-ch.js": 720,
	"./de.js": 718,
	"./dv": 721,
	"./dv.js": 721,
	"./el": 722,
	"./el.js": 722,
	"./en-SG": 723,
	"./en-SG.js": 723,
	"./en-au": 724,
	"./en-au.js": 724,
	"./en-ca": 725,
	"./en-ca.js": 725,
	"./en-gb": 726,
	"./en-gb.js": 726,
	"./en-ie": 727,
	"./en-ie.js": 727,
	"./en-il": 728,
	"./en-il.js": 728,
	"./en-nz": 729,
	"./en-nz.js": 729,
	"./eo": 730,
	"./eo.js": 730,
	"./es": 731,
	"./es-do": 732,
	"./es-do.js": 732,
	"./es-us": 733,
	"./es-us.js": 733,
	"./es.js": 731,
	"./et": 734,
	"./et.js": 734,
	"./eu": 735,
	"./eu.js": 735,
	"./fa": 736,
	"./fa.js": 736,
	"./fi": 737,
	"./fi.js": 737,
	"./fo": 738,
	"./fo.js": 738,
	"./fr": 739,
	"./fr-ca": 740,
	"./fr-ca.js": 740,
	"./fr-ch": 741,
	"./fr-ch.js": 741,
	"./fr.js": 739,
	"./fy": 742,
	"./fy.js": 742,
	"./ga": 743,
	"./ga.js": 743,
	"./gd": 744,
	"./gd.js": 744,
	"./gl": 745,
	"./gl.js": 745,
	"./gom-latn": 746,
	"./gom-latn.js": 746,
	"./gu": 747,
	"./gu.js": 747,
	"./he": 748,
	"./he.js": 748,
	"./hi": 749,
	"./hi.js": 749,
	"./hr": 750,
	"./hr.js": 750,
	"./hu": 751,
	"./hu.js": 751,
	"./hy-am": 752,
	"./hy-am.js": 752,
	"./id": 753,
	"./id.js": 753,
	"./is": 754,
	"./is.js": 754,
	"./it": 755,
	"./it-ch": 756,
	"./it-ch.js": 756,
	"./it.js": 755,
	"./ja": 757,
	"./ja.js": 757,
	"./jv": 758,
	"./jv.js": 758,
	"./ka": 759,
	"./ka.js": 759,
	"./kk": 760,
	"./kk.js": 760,
	"./km": 761,
	"./km.js": 761,
	"./kn": 762,
	"./kn.js": 762,
	"./ko": 763,
	"./ko.js": 763,
	"./ku": 764,
	"./ku.js": 764,
	"./ky": 765,
	"./ky.js": 765,
	"./lb": 766,
	"./lb.js": 766,
	"./lo": 767,
	"./lo.js": 767,
	"./lt": 768,
	"./lt.js": 768,
	"./lv": 769,
	"./lv.js": 769,
	"./me": 770,
	"./me.js": 770,
	"./mi": 771,
	"./mi.js": 771,
	"./mk": 772,
	"./mk.js": 772,
	"./ml": 773,
	"./ml.js": 773,
	"./mn": 774,
	"./mn.js": 774,
	"./mr": 775,
	"./mr.js": 775,
	"./ms": 776,
	"./ms-my": 777,
	"./ms-my.js": 777,
	"./ms.js": 776,
	"./mt": 778,
	"./mt.js": 778,
	"./my": 779,
	"./my.js": 779,
	"./nb": 780,
	"./nb.js": 780,
	"./ne": 781,
	"./ne.js": 781,
	"./nl": 782,
	"./nl-be": 783,
	"./nl-be.js": 783,
	"./nl.js": 782,
	"./nn": 784,
	"./nn.js": 784,
	"./pa-in": 785,
	"./pa-in.js": 785,
	"./pl": 786,
	"./pl.js": 786,
	"./pt": 787,
	"./pt-br": 788,
	"./pt-br.js": 788,
	"./pt.js": 787,
	"./ro": 789,
	"./ro.js": 789,
	"./ru": 790,
	"./ru.js": 790,
	"./sd": 791,
	"./sd.js": 791,
	"./se": 792,
	"./se.js": 792,
	"./si": 793,
	"./si.js": 793,
	"./sk": 794,
	"./sk.js": 794,
	"./sl": 795,
	"./sl.js": 795,
	"./sq": 796,
	"./sq.js": 796,
	"./sr": 797,
	"./sr-cyrl": 798,
	"./sr-cyrl.js": 798,
	"./sr.js": 797,
	"./ss": 799,
	"./ss.js": 799,
	"./sv": 800,
	"./sv.js": 800,
	"./sw": 801,
	"./sw.js": 801,
	"./ta": 802,
	"./ta.js": 802,
	"./te": 803,
	"./te.js": 803,
	"./tet": 804,
	"./tet.js": 804,
	"./tg": 805,
	"./tg.js": 805,
	"./th": 806,
	"./th.js": 806,
	"./tl-ph": 807,
	"./tl-ph.js": 807,
	"./tlh": 808,
	"./tlh.js": 808,
	"./tr": 809,
	"./tr.js": 809,
	"./tzl": 810,
	"./tzl.js": 810,
	"./tzm": 811,
	"./tzm-latn": 812,
	"./tzm-latn.js": 812,
	"./tzm.js": 811,
	"./ug-cn": 813,
	"./ug-cn.js": 813,
	"./uk": 814,
	"./uk.js": 814,
	"./ur": 815,
	"./ur.js": 815,
	"./uz": 816,
	"./uz-latn": 817,
	"./uz-latn.js": 817,
	"./uz.js": 816,
	"./vi": 818,
	"./vi.js": 818,
	"./x-pseudo": 819,
	"./x-pseudo.js": 819,
	"./yo": 820,
	"./yo.js": 820,
	"./zh-cn": 821,
	"./zh-cn.js": 821,
	"./zh-hk": 822,
	"./zh-hk.js": 822,
	"./zh-tw": 823,
	"./zh-tw.js": 823
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 1408;

/***/ }),

/***/ 145:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RateProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__environments__ = __webpack_require__(424);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);







let RateProvider = class RateProvider {
    constructor(currencyProvider, http, logger) {
        this.currencyProvider = currencyProvider;
        this.http = http;
        this.logger = logger;
        this.rates = {};
        this.ratesAvailable = {};
        this.rateServiceUrl = {};
        this.fiatRateAPIUrl = 'https://bws.bitpay.com/bws/api/v1/fiatrates';
        this.logger.debug('RateProvider initialized');
        this.alternatives = {};
        for (const coin of this.currencyProvider.getAvailableCoins()) {
            this.rateServiceUrl[coin] = __WEBPACK_IMPORTED_MODULE_4__environments__["a" /* default */].ratesAPI[coin];
            this.rates[coin] = { USD: 1 };
            this.ratesAvailable[coin] = false;
            this.updateRates(coin);
        }
    }
    updateRates(chain) {
        return new Promise((resolve, reject) => {
            this.getCoin(chain)
                .then(dataCoin => {
                __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](dataCoin, currency => {
                    if (currency && currency.code && currency.rate) {
                        this.rates[chain][currency.code] = currency.rate;
                        if (currency.name)
                            this.alternatives[currency.code] = { name: currency.name };
                    }
                });
                this.ratesAvailable[chain] = true;
                resolve();
            })
                .catch(errorCoin => {
                this.logger.error(errorCoin);
                reject(errorCoin);
            });
        });
    }
    getCoin(chain) {
        return new Promise(resolve => {
            this.http.get(this.rateServiceUrl[chain]).subscribe(data => {
                resolve(data);
            });
        });
    }
    getRate(code, chain) {
        return this.rates[chain][code];
    }
    getAlternatives() {
        const alternatives = [];
        for (let key in this.alternatives) {
            alternatives.push({ isoCode: key, name: this.alternatives[key].name });
        }
        return alternatives;
    }
    isCoinAvailable(chain) {
        return this.ratesAvailable[chain];
    }
    toFiat(satoshis, code, chain) {
        if (!this.isCoinAvailable(chain)) {
            return null;
        }
        return (satoshis *
            (1 / this.currencyProvider.getPrecision(chain).unitToSatoshi) *
            this.getRate(code, chain));
    }
    fromFiat(amount, code, chain) {
        if (!this.isCoinAvailable(chain)) {
            return null;
        }
        return ((amount / this.getRate(code, chain)) *
            this.currencyProvider.getPrecision(chain).unitToSatoshi);
    }
    listAlternatives(sort) {
        const alternatives = this.getAlternatives();
        if (sort) {
            alternatives.sort((a, b) => {
                return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;
            });
        }
        return __WEBPACK_IMPORTED_MODULE_3_lodash__["uniqBy"](alternatives, 'isoCode');
    }
    whenRatesAvailable(chain) {
        return new Promise(resolve => {
            if (this.ratesAvailable[chain])
                resolve();
            else {
                if (chain) {
                    this.updateRates(chain).then(() => {
                        resolve();
                    });
                }
            }
        });
    }
    getHistoricFiatRate(currency, coin, ts) {
        return new Promise(resolve => {
            const url = this.fiatRateAPIUrl + '/' + currency + '?coin=' + coin + '&ts=' + ts;
            this.http.get(url).subscribe(data => {
                resolve(data);
            });
        });
    }
};
RateProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */]])
], RateProvider);

//# sourceMappingURL=rate.js.map

/***/ }),

/***/ 146:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayCardProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app_identity_app_identity__ = __webpack_require__(317);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__bitpay_bitpay__ = __webpack_require__(246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__home_integrations_home_integrations__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_moment__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__analytics_analytics__ = __webpack_require__(243);



// providers









let BitPayCardProvider = class BitPayCardProvider {
    constructor(logger, bitPayProvider, appIdentityProvider, onGoingProcessProvider, persistenceProvider, configProvider, homeIntegrationsProvider, analyticsProvider) {
        this.logger = logger;
        this.bitPayProvider = bitPayProvider;
        this.appIdentityProvider = appIdentityProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.persistenceProvider = persistenceProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.analyticsProvider = analyticsProvider;
        this.logger.debug('BitPayCardProvider initialized');
    }
    logDebitCardLinked() {
        this.analyticsProvider.setUserProperty('hasLinkedDebitCard', 'true');
    }
    isActive(cb) {
        this.getCards(cards => {
            return cb(!__WEBPACK_IMPORTED_MODULE_9_lodash__["isEmpty"](cards));
        });
    }
    _setError(msg, e) {
        this.logger.error(msg);
        var error = e && e.data && e.data.error ? e.data.error : msg;
        return error;
    }
    _buildDate(date, time) {
        date = date.match(/(\d{2})\/(\d{2})\/(\d{4})/);
        time = time.match(/(\d{2})(\d{2})(\d{2})/);
        var newDate = new Date(date[1] + '/' + date[2] + '/' + date[3]);
        newDate.setHours(time[1], time[2], time[3]);
        return newDate;
    }
    _lowercaseMerchant(merchant) {
        if (merchant.name && merchant.name.toLowerCase) {
            merchant.name = merchant.name.toLowerCase();
        }
        if (merchant.city && merchant.city.toLowerCase) {
            merchant.city = merchant.city.toLowerCase();
        }
        return merchant;
    }
    _getMerchantInfo(tx) {
        var bpTranCodesTemp = bpTranCodes;
        __WEBPACK_IMPORTED_MODULE_9_lodash__["keys"](bpTranCodesTemp).forEach(code => {
            if (tx.type.indexOf(code) === 0) {
                __WEBPACK_IMPORTED_MODULE_9_lodash__["assign"](tx, bpTranCodesTemp[code]);
            }
        });
        return tx;
    }
    _getIconName(tx) {
        var icon = tx.mcc || tx.category || null;
        if (!icon || iconMap[icon] == undefined)
            return 'default';
        return iconMap[icon];
    }
    _processDescription(tx) {
        if (__WEBPACK_IMPORTED_MODULE_9_lodash__["isArray"](tx.description)) {
            return tx.description[0];
        }
        return tx.description;
    }
    _processLocation(tx) {
        if (tx.merchant.city && tx.merchant.state) {
            return tx.merchant.city + ', ' + tx.merchant.state;
        }
        else {
            return tx.merchant.city || tx.merchant.state || '';
        }
    }
    _fromTransaction(txn, runningBalance) {
        var dateTime = this._buildDate(txn.date, txn.time);
        var merchant = this._lowercaseMerchant(txn.merchant);
        return this._getMerchantInfo({
            date: txn.timestamp || dateTime,
            category: txn.mcc,
            merchant,
            description: txn.description[0],
            price: parseFloat(txn.amount) + parseFloat(txn.fee),
            type: txn.type,
            runningBalance
        });
    }
    logEvent(eventName, eventParams) {
        this.analyticsProvider.logEvent(eventName, eventParams);
    }
    _processTransactions(invoices, history) {
        var balance = history.endingBalance || history.currentCardBalance;
        var runningBalance = parseFloat(balance);
        var activityList = [];
        if (history && history.transactionList) {
            for (let j = 0; j < history.transactionList.length; j++) {
                runningBalance -= parseFloat(history.transactionList[j].amount);
                activityList.push(this._fromTransaction(history.transactionList[j], runningBalance));
            }
        }
        if (activityList.length > 0) {
            invoices = invoices || [];
            for (let i = 0; i < invoices.length; i++) {
                var matched = false;
                for (let j = 0; j < history.transactionList.length; j++) {
                    var description = history.transactionList[j].description;
                    for (let k = 0; k < description.length; k++) {
                        if (description[k] && description[k].indexOf(invoices[i].id) > -1) {
                            matched = true;
                        }
                    }
                }
                var isInvoiceLessThanOneDayOld = __WEBPACK_IMPORTED_MODULE_10_moment__() < __WEBPACK_IMPORTED_MODULE_10_moment__(new Date(invoices[i].invoiceTime)).add(1, 'day');
                if (!matched && isInvoiceLessThanOneDayOld) {
                    var isInvoiceUnderpaid = invoices[i].exceptionStatus === 'paidPartial';
                    if (['paid', 'confirmed', 'complete'].indexOf(invoices[i].status) >=
                        0 ||
                        (invoices[i].status === 'invalid' || isInvoiceUnderpaid)) {
                        activityList.unshift(this._getMerchantInfo({
                            date: new Date(invoices[i].invoiceTime),
                            category: '',
                            merchant: '',
                            description: invoices[i].itemDesc,
                            price: invoices[i].price,
                            type: '00611 = Client Funded Deposit',
                            runningBalance: null,
                            pending: true,
                            transactionId: invoices[i].transactions && invoices[i].transactions[0]
                                ? invoices[i].transactions[0].txid
                                : ''
                        }));
                    }
                }
            }
        }
        for (let i = 0; i < activityList.length; i++) {
            activityList[i].icon = this._getIconName(activityList[i]);
            activityList[i].desc = this._processDescription(activityList[i]);
            activityList[i].merchant['location'] = this._processLocation(activityList[i]);
        }
        return activityList;
    }
    filterTransactions(type, txns) {
        var list, getPreAuth = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](txns, txn => {
            return txn.type.indexOf('93') > -1;
        }), getPending = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](txns, txn => {
            return txn.pending;
        }), getCompleted = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](txns, txn => {
            return !txn.pending && txn.type.indexOf('93') == -1;
        });
        switch (type) {
            case 'preAuth':
                list = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](getPreAuth);
                break;
            case 'confirming':
                list = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](getPending);
                break;
            case 'completed':
                list = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](getCompleted);
                break;
            default:
                // code...
                break;
        }
        return list;
    }
    sync(apiContext, cb) {
        var json = {
            method: 'getDebitCards'
        };
        this.onGoingProcessProvider.set('fetchingBitPayCards');
        // Get Debit Cards
        this.bitPayProvider.post('/api/v2/' + apiContext.token, json, data => {
            if (data && data.error) {
                this.onGoingProcessProvider.clear();
                return cb(data.error);
            }
            this.logger.info('BitPay Get Debit Cards: SUCCESS');
            var cards = [];
            __WEBPACK_IMPORTED_MODULE_9_lodash__["each"](data.data, x => {
                var n = {};
                if (!x.eid || !x.id || !x.lastFourDigits || !x.token) {
                    this.logger.warn('BAD data from BitPay card' + JSON.stringify(x));
                    return;
                }
                n.eid = x.eid;
                n.id = x.id;
                n.lastFourDigits = x.lastFourDigits;
                n.token = x.token;
                n.currency = x.currency;
                n.country = x.country;
                cards.push(n);
            });
            this.persistenceProvider
                .setBitpayDebitCards(this.bitPayProvider.getEnvironment().network, apiContext.pairData.email, cards)
                .then(() => {
                this.logDebitCardLinked();
                this.onGoingProcessProvider.clear();
                return cb(null, cards);
            });
        }, data => {
            this.onGoingProcessProvider.clear();
            return cb(this._setError('BitPay Card Error: Get Debit Cards', data));
        });
    }
    setCurrencySymbol(card) {
        // Sets a currency symbol.
        // Uses the currency code if no symbol is mapped (should never happen).
        // Backwards compatibility for FirstView cards (all USD).
        // This avoids users having to re-pair their account.
        if (!card.currency) {
            card.currency = 'USD';
        }
        card.currencySymbol = currencySymbols[card.currency] || card.currency + ' ';
    }
    // opts: range
    updateHistory(cardId, opts, cb) {
        var invoices, history;
        opts = opts || {};
        var json = {
            method: 'getInvoiceHistory'
        };
        this.appIdentityProvider.getIdentity(this.bitPayProvider.getEnvironment().network, err => {
            if (err)
                return cb(err);
            this.getCards(data => {
                var card = __WEBPACK_IMPORTED_MODULE_9_lodash__["find"](data, {
                    id: cardId
                });
                if (!card)
                    return cb(this._setError('Card not found'));
                // Get invoices
                this.bitPayProvider.post('/api/v2/' + card.token, json, data => {
                    this.logger.info('BitPay Get Invoices: SUCCESS');
                    invoices = data.data || [];
                    if (__WEBPACK_IMPORTED_MODULE_9_lodash__["isEmpty"](invoices))
                        this.logger.info('No invoices');
                    json = {
                        method: 'getTransactionHistory',
                        params: JSON.stringify(opts)
                    };
                    // Get transactions History list
                    this.bitPayProvider.post('/api/v2/' + card.token, json, data => {
                        this.logger.info('BitPay Get History: SUCCESS');
                        history = data.data || {};
                        history['txs'] = this._processTransactions(invoices, history);
                        this.persistenceProvider.setLastKnownHistory(cardId, history.txs);
                        this.persistenceProvider.setLastKnownBalance(cardId, history.currentCardBalance);
                        return cb(data.error, history);
                    }, data => {
                        this.logger.info('Error loading BitPay Card transaction history for ', 'card id: ', cardId, 'Message: ', data.error);
                        return cb(this._setError('BitPay Card Error: Get History', data));
                    });
                }, data => {
                    this.logger.info('Error loading BitPay Card invoice history for ', 'card id: ', cardId, 'Message: ', data.error);
                    return cb(this._setError('BitPay Card Error: Get Invoices', data));
                });
            });
        });
    }
    topUp(cardId, opts, cb) {
        opts = opts || {};
        var json = {
            method: 'generateTopUpInvoice',
            params: JSON.stringify(opts)
        };
        this.appIdentityProvider.getIdentity(this.bitPayProvider.getEnvironment().network, err => {
            if (err)
                return cb(err);
            this.getCards(data => {
                var card = __WEBPACK_IMPORTED_MODULE_9_lodash__["find"](data, {
                    id: cardId
                });
                if (!card)
                    return cb(this._setError('Card not found'));
                this.bitPayProvider.post('/api/v2/' + card.token, json, res => {
                    if (res.error) {
                        this.logger.error('BitPay TopUp: With Errors');
                        return cb(res.error);
                    }
                    else {
                        this.logger.info('BitPay TopUp: SUCCESS');
                        return cb(null, res.data.invoice);
                    }
                }, res => {
                    return cb(this._setError('BitPay Card Error: TopUp', res));
                });
            });
        });
    }
    getInvoice(id, cb) {
        this.bitPayProvider.get('/invoices/' + id, res => {
            this.logger.info('BitPay Get Invoice: SUCCESS');
            return cb(res.error, res.data);
        }, res => {
            return cb(this._setError('BitPay Card Error: Get Invoice', res));
        });
    }
    // get all cards, for all accounts.
    getCards(cb) {
        this.persistenceProvider
            .getBitpayDebitCards(this.bitPayProvider.getEnvironment().network)
            .then(val => {
            return cb(val);
        });
    }
    remove(cardId, cb) {
        this.persistenceProvider
            .removeBitpayDebitCard(this.bitPayProvider.getEnvironment().network, cardId)
            .then(() => {
            this.persistenceProvider.removeLastKnownBalance(cardId);
            return cb();
        })
            .catch(err => {
            this.logger.error('Error removing BitPay debit card: ' + err);
            return cb(err);
        });
    }
    getRates(currency, cb) {
        this.bitPayProvider.get('/rates/' + currency, data => {
            this.logger.info('BitPay Get Rates: SUCCESS');
            return cb(data.error, data.data);
        }, data => {
            return cb(this._setError('BitPay Error: Get Rates', data));
        });
    }
    getRatesFromCoin(coin, currency, cb) {
        this.bitPayProvider.get('/rates/' + coin + '/' + currency, data => {
            this.logger.info('BitPay Get Rates: SUCCESS');
            return cb(data.error, data.data);
        }, data => {
            return cb(this._setError('BitPay Error: Get Rates', data));
        });
    }
    get(opts) {
        opts = opts || {};
        return new Promise(resolve => {
            this.getCards(cards => {
                if (__WEBPACK_IMPORTED_MODULE_9_lodash__["isEmpty"](cards)) {
                    this.homeIntegrationsProvider.updateLink('debitcard', null); // Name, linked
                    return resolve();
                }
                this.homeIntegrationsProvider.updateLink('debitcard', true); // Name, linked
                if (opts.cardId) {
                    cards = __WEBPACK_IMPORTED_MODULE_9_lodash__["filter"](cards, card => {
                        return opts.cardId == card.eid;
                    });
                }
                const completeBalance = () => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
                    for (let i = 0; i < cards.length; i++) {
                        this.setCurrencySymbol(cards[i]);
                        if (!opts.noBalance) {
                            yield this.persistenceProvider
                                .getLastKnownBalance(cards[i].eid)
                                .then(balanceCache => {
                                cards[i].balance =
                                    balanceCache && balanceCache.balance
                                        ? Number(balanceCache.balance)
                                        : null;
                                cards[i].updateOn = balanceCache && balanceCache.updatedOn;
                            });
                        }
                        // async refresh
                        if (!opts.noHistory) {
                            yield this.persistenceProvider
                                .getLastKnownHistory(cards[i].eid)
                                .then(historyCache => {
                                cards[i].history = historyCache && historyCache.txs;
                                cards[i].updateOn = historyCache && historyCache.updatedOn;
                            });
                        }
                    }
                    return resolve(cards);
                });
                completeBalance();
            });
        });
    }
    register() {
        this.isActive(isActive => {
            this.homeIntegrationsProvider.register({
                name: 'debitcard',
                title: 'BitPay Visa Card',
                icon: 'assets/img/bitpay-card/icon-bitpay.svg',
                page: 'BitPayCardIntroPage',
                show: !!this.configProvider.get().showIntegration['debitcard'],
                linked: !!isActive
            });
        });
    }
};
BitPayCardProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__bitpay_bitpay__["a" /* BitPayProvider */],
        __WEBPACK_IMPORTED_MODULE_3__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_7__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_8__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_5__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_11__analytics_analytics__["a" /* AnalyticsProvider */]])
], BitPayCardProvider);

/*
 * CONSTANTS
 */
const currencySymbols = {
    EUR: '',
    GBP: '',
    USD: '$'
};
const bpTranCodes = {
    '00611': {
        merchant: {
            name: 'BitPay',
            city: 'Atlanta',
            state: 'GA'
        },
        category: 'bp001',
        description: 'Top-Up'
    },
    '602': {
        merchant: {
            name: 'ATM Withdrawal Fee'
        },
        category: 'bp002',
        description: ''
    },
    '604': {
        merchant: {
            name: 'Foreign Transaction Fee'
        },
        category: 'bp002',
        description: ''
    },
    '606': {
        merchant: {
            name: 'International ATM Fee'
        },
        category: 'bp002',
        description: ''
    },
    '00240': {
        merchant: {
            name: 'ACH Debit Fee'
        },
        category: 'bp002',
        description: ''
    },
    '5032': {
        merchant: {
            name: 'ACH Debit'
        },
        category: 'bp002',
        description: ''
    },
    '37': {
        merchant: {
            name: 'ACH / Payroll Deposit'
        },
        category: 'bp002',
        description: ''
    },
    '10036': {
        merchant: {
            name: 'Inactivity Fee (90 days)'
        },
        category: 'bp002',
        description: ''
    },
    load: {
        merchant: {
            name: 'BitPay',
            city: 'Atlanta',
            state: 'GA'
        },
        category: 'bp001',
        description: 'Top-Up'
    },
    'unload | pos': {
        description: 'Purchase'
    },
    'unload | epos': {
        description: 'Online Purchase'
    },
    transactionfee: {
        merchant: {
            name: 'Transaction Fee'
        },
        category: 'bp002',
        description: ''
    }
};
const iconMap = {
    742: 'medical',
    763: 'plant',
    780: 'plant',
    1520: 'repair',
    1711: 'repair',
    1731: 'repair',
    1740: 'repair',
    1750: 'repair',
    1761: 'repair',
    1771: 'repair',
    1799: 'repair',
    2741: 'books',
    2791: 'books',
    2842: 'clean',
    3000: 'airplane',
    3001: 'airplane',
    3002: 'airplane',
    3003: 'airplane',
    3004: 'airplane',
    3005: 'airplane',
    3006: 'airplane',
    3007: 'airplane',
    3008: 'airplane',
    3009: 'airplane',
    3010: 'airplane',
    3011: 'airplane',
    3012: 'airplane',
    3013: 'airplane',
    3014: 'airplane',
    3015: 'airplane',
    3016: 'airplane',
    3017: 'airplane',
    3018: 'airplane',
    3019: 'airplane',
    3020: 'airplane',
    3021: 'airplane',
    3022: 'airplane',
    3023: 'airplane',
    3024: 'airplane',
    3025: 'airplane',
    3026: 'airplane',
    3027: 'airplane',
    3028: 'airplane',
    3029: 'airplane',
    3030: 'airplane',
    3031: 'airplane',
    3032: 'airplane',
    3033: 'airplane',
    3034: 'airplane',
    3035: 'airplane',
    3036: 'airplane',
    3037: 'airplane',
    3038: 'airplane',
    3039: 'airplane',
    3040: 'airplane',
    3041: 'airplane',
    3042: 'airplane',
    3043: 'airplane',
    3044: 'airplane',
    3045: 'airplane',
    3046: 'airplane',
    3047: 'airplane',
    3048: 'airplane',
    3049: 'airplane',
    3050: 'airplane',
    3051: 'airplane',
    3052: 'airplane',
    3053: 'airplane',
    3054: 'airplane',
    3055: 'airplane',
    3056: 'airplane',
    3057: 'airplane',
    3058: 'airplane',
    3059: 'airplane',
    3060: 'airplane',
    3061: 'airplane',
    3062: 'airplane',
    3063: 'airplane',
    3064: 'airplane',
    3065: 'airplane',
    3066: 'airplane',
    3067: 'airplane',
    3068: 'airplane',
    3069: 'airplane',
    3070: 'airplane',
    3071: 'airplane',
    3072: 'airplane',
    3073: 'airplane',
    3074: 'airplane',
    3075: 'airplane',
    3076: 'airplane',
    3077: 'airplane',
    3078: 'airplane',
    3079: 'airplane',
    3080: 'airplane',
    3081: 'airplane',
    3082: 'airplane',
    3083: 'airplane',
    3084: 'airplane',
    3085: 'airplane',
    3086: 'airplane',
    3087: 'airplane',
    3088: 'airplane',
    3089: 'airplane',
    3090: 'airplane',
    3091: 'airplane',
    3092: 'airplane',
    3093: 'airplane',
    3094: 'airplane',
    3095: 'airplane',
    3096: 'airplane',
    3097: 'airplane',
    3098: 'airplane',
    3099: 'airplane',
    3100: 'airplane',
    3101: 'airplane',
    3102: 'airplane',
    3103: 'airplane',
    3104: 'airplane',
    3105: 'airplane',
    3106: 'airplane',
    3107: 'airplane',
    3108: 'airplane',
    3109: 'airplane',
    3110: 'airplane',
    3111: 'airplane',
    3112: 'airplane',
    3113: 'airplane',
    3114: 'airplane',
    3115: 'airplane',
    3116: 'airplane',
    3117: 'airplane',
    3118: 'airplane',
    3119: 'airplane',
    3120: 'airplane',
    3121: 'airplane',
    3122: 'airplane',
    3123: 'airplane',
    3124: 'airplane',
    3125: 'airplane',
    3126: 'airplane',
    3127: 'airplane',
    3128: 'airplane',
    3129: 'airplane',
    3130: 'airplane',
    3131: 'airplane',
    3132: 'airplane',
    3133: 'airplane',
    3134: 'airplane',
    3135: 'airplane',
    3136: 'airplane',
    3137: 'airplane',
    3138: 'airplane',
    3139: 'airplane',
    3140: 'airplane',
    3141: 'airplane',
    3142: 'airplane',
    3143: 'airplane',
    3144: 'airplane',
    3145: 'airplane',
    3146: 'airplane',
    3147: 'airplane',
    3148: 'airplane',
    3149: 'airplane',
    3150: 'airplane',
    3151: 'airplane',
    3152: 'airplane',
    3153: 'airplane',
    3154: 'airplane',
    3155: 'airplane',
    3156: 'airplane',
    3157: 'airplane',
    3158: 'airplane',
    3159: 'airplane',
    3160: 'airplane',
    3161: 'airplane',
    3162: 'airplane',
    3163: 'airplane',
    3164: 'airplane',
    3165: 'airplane',
    3166: 'airplane',
    3167: 'airplane',
    3168: 'airplane',
    3169: 'airplane',
    3170: 'airplane',
    3171: 'airplane',
    3172: 'airplane',
    3173: 'airplane',
    3174: 'airplane',
    3175: 'airplane',
    3176: 'airplane',
    3177: 'airplane',
    3178: 'airplane',
    3179: 'airplane',
    3180: 'airplane',
    3181: 'airplane',
    3182: 'airplane',
    3183: 'airplane',
    3184: 'airplane',
    3185: 'airplane',
    3186: 'airplane',
    3187: 'airplane',
    3188: 'airplane',
    3189: 'airplane',
    3190: 'airplane',
    3191: 'airplane',
    3192: 'airplane',
    3193: 'airplane',
    3194: 'airplane',
    3195: 'airplane',
    3196: 'airplane',
    3197: 'airplane',
    3198: 'airplane',
    3199: 'airplane',
    3200: 'airplane',
    3201: 'airplane',
    3202: 'airplane',
    3203: 'airplane',
    3204: 'airplane',
    3205: 'airplane',
    3206: 'airplane',
    3207: 'airplane',
    3208: 'airplane',
    3209: 'airplane',
    3210: 'airplane',
    3211: 'airplane',
    3212: 'airplane',
    3213: 'airplane',
    3214: 'airplane',
    3215: 'airplane',
    3216: 'airplane',
    3217: 'airplane',
    3218: 'airplane',
    3219: 'airplane',
    3220: 'airplane',
    3221: 'airplane',
    3222: 'airplane',
    3223: 'airplane',
    3224: 'airplane',
    3225: 'airplane',
    3226: 'airplane',
    3227: 'airplane',
    3228: 'airplane',
    3229: 'airplane',
    3230: 'airplane',
    3231: 'airplane',
    3232: 'airplane',
    3233: 'airplane',
    3234: 'airplane',
    3235: 'airplane',
    3236: 'airplane',
    3237: 'airplane',
    3238: 'airplane',
    3239: 'airplane',
    3240: 'airplane',
    3241: 'airplane',
    3242: 'airplane',
    3243: 'airplane',
    3244: 'airplane',
    3245: 'airplane',
    3246: 'airplane',
    3247: 'airplane',
    3248: 'airplane',
    3249: 'airplane',
    3250: 'airplane',
    3251: 'airplane',
    3252: 'airplane',
    3253: 'airplane',
    3254: 'airplane',
    3255: 'airplane',
    3256: 'airplane',
    3257: 'airplane',
    3258: 'airplane',
    3259: 'airplane',
    3260: 'airplane',
    3261: 'airplane',
    3262: 'airplane',
    3263: 'airplane',
    3264: 'airplane',
    3265: 'airplane',
    3266: 'airplane',
    3267: 'airplane',
    3268: 'airplane',
    3269: 'airplane',
    3270: 'airplane',
    3271: 'airplane',
    3272: 'airplane',
    3273: 'airplane',
    3274: 'airplane',
    3275: 'airplane',
    3276: 'airplane',
    3277: 'airplane',
    3278: 'airplane',
    3279: 'airplane',
    3280: 'airplane',
    3281: 'airplane',
    3282: 'airplane',
    3283: 'airplane',
    3284: 'airplane',
    3285: 'airplane',
    3286: 'airplane',
    3287: 'airplane',
    3288: 'airplane',
    3289: 'airplane',
    3290: 'airplane',
    3291: 'airplane',
    3292: 'airplane',
    3293: 'airplane',
    3294: 'airplane',
    3295: 'airplane',
    3296: 'airplane',
    3297: 'airplane',
    3298: 'airplane',
    3299: 'airplane',
    3351: 'car',
    3352: 'car',
    3353: 'car',
    3354: 'car',
    3355: 'car',
    3356: 'car',
    3357: 'car',
    3358: 'car',
    3359: 'car',
    3360: 'car',
    3361: 'car',
    3362: 'car',
    3363: 'car',
    3364: 'car',
    3365: 'car',
    3366: 'car',
    3367: 'car',
    3368: 'car',
    3369: 'car',
    3370: 'car',
    3371: 'car',
    3372: 'car',
    3373: 'car',
    3374: 'car',
    3375: 'car',
    3376: 'car',
    3377: 'car',
    3378: 'car',
    3379: 'car',
    3380: 'car',
    3381: 'car',
    3382: 'car',
    3383: 'car',
    3384: 'car',
    3385: 'car',
    3386: 'car',
    3387: 'car',
    3388: 'car',
    3389: 'car',
    3390: 'car',
    3391: 'car',
    3392: 'car',
    3393: 'car',
    3394: 'car',
    3395: 'car',
    3396: 'car',
    3397: 'car',
    3398: 'car',
    3399: 'car',
    3400: 'car',
    3401: 'car',
    3402: 'car',
    3403: 'car',
    3404: 'car',
    3405: 'car',
    3406: 'car',
    3407: 'car',
    3408: 'car',
    3409: 'car',
    3410: 'car',
    3411: 'car',
    3412: 'car',
    3413: 'car',
    3414: 'car',
    3415: 'car',
    3416: 'car',
    3417: 'car',
    3418: 'car',
    3419: 'car',
    3420: 'car',
    3421: 'car',
    3422: 'car',
    3423: 'car',
    3424: 'car',
    3425: 'car',
    3426: 'car',
    3427: 'car',
    3428: 'car',
    3429: 'car',
    3430: 'car',
    3431: 'car',
    3432: 'car',
    3433: 'car',
    3434: 'car',
    3435: 'car',
    3436: 'car',
    3437: 'car',
    3438: 'car',
    3439: 'car',
    3440: 'car',
    3441: 'car',
    3501: 'hotel',
    3502: 'hotel',
    3503: 'hotel',
    3504: 'hotel',
    3505: 'hotel',
    3506: 'hotel',
    3507: 'hotel',
    3508: 'hotel',
    3509: 'hotel',
    3510: 'hotel',
    3511: 'hotel',
    3512: 'hotel',
    3513: 'hotel',
    3514: 'hotel',
    3515: 'hotel',
    3516: 'hotel',
    3517: 'hotel',
    3518: 'hotel',
    3519: 'hotel',
    3520: 'hotel',
    3521: 'hotel',
    3522: 'hotel',
    3523: 'hotel',
    3524: 'hotel',
    3525: 'hotel',
    3526: 'hotel',
    3527: 'hotel',
    3528: 'hotel',
    3529: 'hotel',
    3530: 'hotel',
    3531: 'hotel',
    3532: 'hotel',
    3533: 'hotel',
    3534: 'hotel',
    3535: 'hotel',
    3536: 'hotel',
    3537: 'hotel',
    3538: 'hotel',
    3539: 'hotel',
    3540: 'hotel',
    3541: 'hotel',
    3542: 'hotel',
    3543: 'hotel',
    3544: 'hotel',
    3545: 'hotel',
    3546: 'hotel',
    3547: 'hotel',
    3548: 'hotel',
    3549: 'hotel',
    3550: 'hotel',
    3551: 'hotel',
    3552: 'hotel',
    3553: 'hotel',
    3554: 'hotel',
    3555: 'hotel',
    3556: 'hotel',
    3557: 'hotel',
    3558: 'hotel',
    3559: 'hotel',
    3560: 'hotel',
    3561: 'hotel',
    3562: 'hotel',
    3563: 'hotel',
    3564: 'hotel',
    3565: 'hotel',
    3566: 'hotel',
    3567: 'hotel',
    3568: 'hotel',
    3569: 'hotel',
    3570: 'hotel',
    3571: 'hotel',
    3572: 'hotel',
    3573: 'hotel',
    3574: 'hotel',
    3575: 'hotel',
    3576: 'hotel',
    3577: 'hotel',
    3578: 'hotel',
    3579: 'hotel',
    3580: 'hotel',
    3581: 'hotel',
    3582: 'hotel',
    3583: 'hotel',
    3584: 'hotel',
    3585: 'hotel',
    3586: 'hotel',
    3587: 'hotel',
    3588: 'hotel',
    3589: 'hotel',
    3590: 'hotel',
    3591: 'hotel',
    3592: 'hotel',
    3593: 'hotel',
    3594: 'hotel',
    3595: 'hotel',
    3596: 'hotel',
    3597: 'hotel',
    3598: 'hotel',
    3599: 'hotel',
    3600: 'hotel',
    3601: 'hotel',
    3602: 'hotel',
    3603: 'hotel',
    3604: 'hotel',
    3605: 'hotel',
    3606: 'hotel',
    3607: 'hotel',
    3608: 'hotel',
    3609: 'hotel',
    3610: 'hotel',
    3611: 'hotel',
    3612: 'hotel',
    3613: 'hotel',
    3614: 'hotel',
    3615: 'hotel',
    3616: 'hotel',
    3617: 'hotel',
    3618: 'hotel',
    3619: 'hotel',
    3620: 'hotel',
    3621: 'hotel',
    3622: 'hotel',
    3623: 'hotel',
    3624: 'hotel',
    3625: 'hotel',
    3626: 'hotel',
    3627: 'hotel',
    3628: 'hotel',
    3629: 'hotel',
    3630: 'hotel',
    3631: 'hotel',
    3632: 'hotel',
    3633: 'hotel',
    3634: 'hotel',
    3635: 'hotel',
    3636: 'hotel',
    3637: 'hotel',
    3638: 'hotel',
    3639: 'hotel',
    3640: 'hotel',
    3641: 'hotel',
    3642: 'hotel',
    3643: 'hotel',
    3644: 'hotel',
    3645: 'hotel',
    3646: 'hotel',
    3647: 'hotel',
    3648: 'hotel',
    3649: 'hotel',
    3650: 'hotel',
    3651: 'hotel',
    3652: 'hotel',
    3653: 'hotel',
    3654: 'hotel',
    3655: 'hotel',
    3656: 'hotel',
    3657: 'hotel',
    3658: 'hotel',
    3659: 'hotel',
    3660: 'hotel',
    3661: 'hotel',
    3662: 'hotel',
    3663: 'hotel',
    3664: 'hotel',
    3665: 'hotel',
    3666: 'hotel',
    3667: 'hotel',
    3668: 'hotel',
    3669: 'hotel',
    3670: 'hotel',
    3671: 'hotel',
    3672: 'hotel',
    3673: 'hotel',
    3674: 'hotel',
    3675: 'hotel',
    3676: 'hotel',
    3677: 'hotel',
    3678: 'hotel',
    3679: 'hotel',
    3680: 'hotel',
    3681: 'hotel',
    3682: 'hotel',
    3683: 'hotel',
    3684: 'hotel',
    3685: 'hotel',
    3686: 'hotel',
    3687: 'hotel',
    3688: 'hotel',
    3689: 'hotel',
    3690: 'hotel',
    3691: 'hotel',
    3692: 'hotel',
    3693: 'hotel',
    3694: 'hotel',
    3695: 'hotel',
    3696: 'hotel',
    3697: 'hotel',
    3698: 'hotel',
    3699: 'hotel',
    3700: 'hotel',
    3701: 'hotel',
    3702: 'hotel',
    3703: 'hotel',
    3704: 'hotel',
    3705: 'hotel',
    3706: 'hotel',
    3707: 'hotel',
    3708: 'hotel',
    3709: 'hotel',
    3710: 'hotel',
    3711: 'hotel',
    3712: 'hotel',
    3713: 'hotel',
    3714: 'hotel',
    3715: 'hotel',
    3716: 'hotel',
    3717: 'hotel',
    3718: 'hotel',
    3719: 'hotel',
    3720: 'hotel',
    3721: 'hotel',
    3722: 'hotel',
    3723: 'hotel',
    3724: 'hotel',
    3725: 'hotel',
    3726: 'hotel',
    3727: 'hotel',
    3728: 'hotel',
    3729: 'hotel',
    3730: 'hotel',
    3731: 'hotel',
    3732: 'hotel',
    3733: 'hotel',
    3734: 'hotel',
    3735: 'hotel',
    3736: 'hotel',
    3737: 'hotel',
    3738: 'hotel',
    3739: 'hotel',
    3740: 'hotel',
    3741: 'hotel',
    3742: 'hotel',
    3743: 'hotel',
    3744: 'hotel',
    3745: 'hotel',
    3746: 'hotel',
    3747: 'hotel',
    3748: 'hotel',
    3749: 'hotel',
    3750: 'hotel',
    3751: 'hotel',
    3752: 'hotel',
    3753: 'hotel',
    3754: 'hotel',
    3755: 'hotel',
    3756: 'hotel',
    3757: 'hotel',
    3758: 'hotel',
    3759: 'hotel',
    3760: 'hotel',
    3761: 'hotel',
    3762: 'hotel',
    3763: 'hotel',
    3764: 'hotel',
    3765: 'hotel',
    3766: 'hotel',
    3767: 'hotel',
    3768: 'hotel',
    3769: 'hotel',
    3770: 'hotel',
    3771: 'hotel',
    3772: 'hotel',
    3773: 'hotel',
    3774: 'hotel',
    3775: 'hotel',
    3776: 'hotel',
    3777: 'hotel',
    3778: 'hotel',
    3779: 'hotel',
    3780: 'hotel',
    3781: 'hotel',
    3782: 'hotel',
    3783: 'hotel',
    3784: 'hotel',
    3785: 'hotel',
    3786: 'hotel',
    3787: 'hotel',
    3788: 'hotel',
    3789: 'hotel',
    3790: 'hotel',
    3816: 'hotel',
    3835: 'hotel',
    4011: 'car',
    4111: 'car',
    4112: 'car',
    4119: 'car',
    4121: 'car',
    4131: 'car',
    4214: 'car',
    4215: 'bus',
    4225: 'default',
    4411: 'boat',
    4457: 'boat',
    4468: 'boat',
    4511: 'airplane',
    4582: 'airplane',
    4722: 'airplane',
    4723: 'airplane',
    4784: 'car',
    4789: 'car',
    4812: 'car',
    4814: 'telephone',
    4815: 'telephone',
    4816: 'computer',
    4821: 'money',
    4829: 'money',
    4899: 'television',
    4900: 'gas',
    5013: 'car',
    5021: 'default',
    5039: 'repair',
    5044: 'computer',
    5045: 'computer',
    5046: 'default',
    5047: 'medical',
    5051: 'default',
    5065: 'default',
    5072: 'default',
    5074: 'default',
    5085: 'default',
    5094: 'diamond-ring',
    5099: 'default',
    5111: 'default',
    5122: 'medical',
    5131: 'default',
    5137: 'shirt',
    5139: 'shoes',
    5169: 'gas',
    5172: 'gas',
    5192: 'books',
    5193: 'plant',
    5198: 'repair',
    5199: 'repair',
    5200: 'repair',
    5211: 'repair',
    5231: 'repair',
    5251: 'default',
    5261: 'plant',
    5271: 'bus',
    5300: 'purchase',
    5309: 'purchase',
    5310: 'purchase',
    5311: 'purchase',
    5331: 'purchase',
    5399: 'purchase',
    5411: 'food',
    5422: 'food',
    5441: 'food',
    5451: 'food',
    5462: 'food',
    5499: 'food',
    5511: 'car',
    5521: 'car',
    5531: 'car',
    5532: 'car',
    5533: 'car',
    5541: 'gas',
    5542: 'gas',
    5551: 'boat',
    5561: 'motorcycle',
    5571: 'motorcycle',
    5592: 'default',
    5598: 'default',
    5599: 'car',
    5611: 'shirt',
    5621: 'shirt',
    5631: 'shirt',
    5641: 'shirt',
    5651: 'shirt',
    5655: 'shirt',
    5661: 'shoes',
    5681: 'default',
    5691: 'shirt',
    5697: 'default',
    5698: 'default',
    5699: 'default',
    5712: 'default',
    5713: 'default',
    5714: 'default',
    5718: 'default',
    5719: 'default',
    5722: 'default',
    5732: 'computer',
    5733: 'music',
    5734: 'computer',
    5735: 'music',
    5811: 'food',
    5812: 'food',
    5813: 'cocktail',
    5814: 'food',
    5815: 'books',
    5816: 'computer',
    5817: 'default',
    5818: 'default',
    5832: 'default',
    5912: 'medical',
    5921: 'cocktail',
    5931: 'default',
    5932: 'default',
    5933: 'default',
    5935: 'default',
    5937: 'default',
    5940: 'bicycle',
    5941: 'bicycle',
    5942: 'books',
    5943: 'default',
    5944: 'clock',
    5945: 'toy',
    5946: 'camera',
    5947: 'default',
    5948: 'default',
    5949: 'default',
    5950: 'default',
    5960: 'default',
    5961: 'mail',
    5962: 'telephone',
    5963: 'default',
    5964: 'telephone',
    5965: 'telephone',
    5966: 'telephone',
    5967: 'telephone',
    5968: 'telephone',
    5969: 'telephone',
    5970: 'art',
    5971: 'art',
    5972: 'coins',
    5973: 'default',
    5975: 'default',
    5976: 'default',
    5977: 'default',
    5978: 'default',
    5983: 'gas',
    5992: 'plant',
    5993: 'default',
    5994: 'newspaper',
    5995: 'pet',
    5996: 'cocktail',
    5997: 'purchase',
    5998: 'tent',
    5999: 'money',
    6010: 'money',
    6011: 'money',
    6012: 'money',
    6051: 'money',
    6211: 'money',
    6300: 'money',
    6381: 'money',
    6399: 'repair',
    6513: 'repair',
    7011: 'hotel',
    7012: 'hotel',
    7032: 'park',
    7033: 'park',
    7210: 'shirt',
    7211: 'shirt',
    7216: 'shirt',
    7217: 'default',
    7221: 'camera',
    7230: 'scissors',
    7251: 'shoe',
    7261: 'sadface',
    7273: 'smiley-face',
    7276: 'money',
    7277: 'people',
    7278: 'people',
    7296: 'shirt',
    7297: 'smiley-face',
    7298: 'smiley-face',
    7299: 'default',
    7311: 'default',
    7321: 'default',
    7332: 'computer',
    7333: 'camera',
    7338: 'computer',
    7339: 'people',
    7342: 'bug',
    7349: 'default',
    7361: 'people',
    7372: 'computer',
    7375: 'computer',
    7379: 'computer',
    7392: 'people',
    7393: 'search',
    7394: 'default',
    7395: 'car',
    7399: 'car',
    7511: 'truck',
    7512: 'car',
    7513: 'truck',
    7519: 'truck',
    7523: 'car',
    7531: 'car',
    7534: 'car',
    7535: 'car',
    7538: 'car',
    7542: 'car',
    7549: 'truck',
    7622: 'television',
    7623: 'default',
    7629: 'default',
    7631: 'watch',
    7641: 'furniture',
    7692: 'default',
    7699: 'default',
    7800: 'money',
    7801: 'money',
    7802: 'money',
    7829: 'money',
    7832: 'film',
    7841: 'film',
    7911: 'music',
    7922: 'ticket',
    7929: 'ticket',
    7932: 'music',
    7933: 'bowling',
    7941: 'football',
    7991: 'people',
    7992: 'golf',
    7993: 'game',
    7994: 'game',
    7995: 'coins',
    7996: 'ticket',
    7997: 'money',
    7998: 'ticket',
    7999: 'people',
    8011: 'medical',
    8021: 'medical',
    8031: 'medical',
    8041: 'medical',
    8042: 'medical',
    8043: 'medical',
    8044: 'medical',
    8049: 'medical',
    8050: 'medical',
    8062: 'medical',
    8071: 'medical',
    8099: 'medical',
    8111: 'law',
    8211: 'books',
    8220: 'books',
    8241: 'books',
    8244: 'books',
    8249: 'books',
    8299: 'people',
    8351: 'people',
    8398: 'people',
    8641: 'people',
    8651: 'people',
    8661: 'people',
    8675: 'car',
    8699: 'people',
    8734: 'medical',
    8911: 'tree',
    8931: 'books',
    8999: 'suitcase',
    9211: 'law',
    9222: 'law',
    9223: 'law',
    9311: 'law',
    9399: 'default',
    9402: 'mail',
    9405: 'default',
    9700: 'default',
    9701: 'default',
    9702: 'default',
    9950: 'default',
    bp001: 'bitcoin-topup',
    bp002: 'default'
};
//# sourceMappingURL=bitpay-card.js.map

/***/ }),

/***/ 1466:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__providers_currency_currency__ = __webpack_require__(25);

/**
 * Environment: prod
 */
const env = {
    name: 'production',
    enableAnimations: true,
    ratesAPI: new __WEBPACK_IMPORTED_MODULE_0__providers_currency_currency__["b" /* CurrencyProvider */]().getRatesApi(),
    activateScanner: true
};
/* harmony default export */ __webpack_exports__["a"] = (env);
//# sourceMappingURL=prod.js.map

/***/ }),

/***/ 1467:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const availableCoins = {
    btc: {
        name: 'Bitcoin',
        chain: 'BTC',
        coin: 'btc',
        unitInfo: {
            unitName: 'BTC',
            unitToSatoshi: 100000000,
            unitDecimals: 8,
            unitCode: 'btc'
        },
        properties: {
            hasMultiSig: true,
            hasMultiSend: true,
            isUtxo: true,
            isERCToken: false,
            isStableCoin: false,
            singleAddress: false
        },
        paymentInfo: {
            paymentCode: 'BIP73',
            protocolPrefix: { livenet: 'bitcoin', testnet: 'bitcoin' },
            ratesApi: 'https://bitpay.com/api/rates',
            blockExplorerUrls: 'insight.bitcore.io/#/BTC/'
        },
        feeInfo: {
            feeUnit: 'sat/byte',
            feeUnitAmount: 1000,
            blockTime: 10,
            maxMerchantFee: 'urgent'
        },
        theme: {
            backgroundColor: 'rgba(247,146,26,1)',
            gradientBackgroundColor: 'rgba(247,146,26, 0.2)'
        }
    },
    bch: {
        name: 'Bitcoin Cash',
        chain: 'BCH',
        coin: 'bch',
        unitInfo: {
            unitName: 'BCH',
            unitToSatoshi: 100000000,
            unitDecimals: 8,
            unitCode: 'bch'
        },
        properties: {
            hasMultiSig: true,
            hasMultiSend: true,
            isUtxo: true,
            isERCToken: false,
            isStableCoin: false,
            singleAddress: false
        },
        paymentInfo: {
            paymentCode: 'BIP73',
            protocolPrefix: { livenet: 'bitcoincash', testnet: 'bchtest' },
            ratesApi: 'https://bitpay.com/api/rates/bch',
            blockExplorerUrls: 'insight.bitcore.io/#/BCH/'
        },
        feeInfo: {
            feeUnit: 'sat/byte',
            feeUnitAmount: 1000,
            blockTime: 10,
            maxMerchantFee: 'normal'
        },
        theme: {
            backgroundColor: 'rgba(47,207,110,1)',
            gradientBackgroundColor: 'rgba(47,207,110, 0.2)'
        }
    },
    eth: {
        name: 'Ethereum',
        chain: 'ETH',
        coin: 'eth',
        unitInfo: {
            unitName: 'ETH',
            unitToSatoshi: 1e18,
            unitDecimals: 18,
            unitCode: 'eth'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: false,
            isStableCoin: false,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bitpay.com/api/rates/eth',
            blockExplorerUrls: 'insight.bitcore.io/#/ETH/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            backgroundColor: 'rgba(135,206,250,1)',
            gradientBackgroundColor: 'rgba(30,144,255, 0.2)'
        }
    },
    pax: {
        name: 'Paxos Standard',
        chain: 'ETH',
        coin: 'pax',
        unitInfo: {
            unitName: 'PAX',
            unitToSatoshi: 1e18,
            unitDecimals: 18,
            unitCode: 'pax'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: true,
            isStableCoin: true,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681b',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bitpay.com/api/rates/pax',
            blockExplorerUrls: 'insight.bitcore.io/#/ETH/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            backgroundColor: 'rgba(0,132,93,1)',
            gradientBackgroundColor: 'rgba(0,209,147, 0.2)'
        }
    },
    usdc: {
        name: 'USD Coin',
        chain: 'ETH',
        coin: 'usdc',
        unitInfo: {
            unitName: 'USDC',
            unitToSatoshi: 1e6,
            unitDecimals: 6,
            unitCode: 'usdc'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: true,
            isStableCoin: true,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681b',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bitpay.com/api/rates/usdc',
            blockExplorerUrls: 'insight.bitcore.io/#/ETH/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            backgroundColor: 'rgba(39,117,201,1)',
            gradientBackgroundColor: 'rgba(93,156,224, 0.2)'
        }
    },
    gusd: {
        name: 'Gemini Dollar',
        chain: 'ETH',
        coin: 'gusd',
        unitInfo: {
            unitName: 'GUSD',
            unitToSatoshi: 1e2,
            unitDecimals: 2,
            unitCode: 'gusd'
        },
        properties: {
            hasMultiSig: false,
            hasMultiSend: false,
            isUtxo: false,
            isERCToken: true,
            isStableCoin: true,
            singleAddress: true
        },
        paymentInfo: {
            paymentCode: 'EIP681b',
            protocolPrefix: { livenet: 'ethereum', testnet: 'ethereum' },
            ratesApi: 'https://bitpay.com/api/rates/gusd',
            blockExplorerUrls: 'insight.bitcore.io/#/ETH/'
        },
        feeInfo: {
            feeUnit: 'Gwei',
            feeUnitAmount: 1e9,
            blockTime: 0.2,
            maxMerchantFee: 'urgent'
        },
        theme: {
            backgroundColor: 'rgba(0,220,250,1)',
            gradientBackgroundColor: 'rgba(72,233,255, 0.2)'
        }
    }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = availableCoins;

//# sourceMappingURL=coin.js.map

/***/ }),

/***/ 1468:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const TokenOpts = {
    '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': {
        name: 'USD Coin',
        symbol: 'USDC',
        decimal: 6,
        address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
    },
    '0x8e870d67f660d95d5be530380d0ec0bd388289e1': {
        name: 'Paxos Standard',
        symbol: 'PAX',
        decimal: 18,
        address: '0x8e870d67f660d95d5be530380d0ec0bd388289e1'
    },
    '0x056fd409e1d7a124bd7017459dfea2f387b6d5cd': {
        name: 'Gemini Dollar',
        symbol: 'GUSD',
        decimal: 2,
        address: '0x056fd409e1d7a124bd7017459dfea2f387b6d5cd'
    }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = TokenOpts;

//# sourceMappingURL=token.js.map

/***/ }),

/***/ 1469:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CopayApp; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_screen_orientation__ = __webpack_require__(847);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_splash_screen__ = __webpack_require__(425);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_user_agent__ = __webpack_require__(848);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__pages_wallet_tabs_wallet_tabs_provider__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_bitpay_card_bitpay_card__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_coinbase_coinbase__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_email_notifications_email_notifications__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_incoming_data_incoming_data__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_push_notifications_push_notifications__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_shapeshift_shapeshift__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_touchid_touchid__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_ionic_image_loader__ = __webpack_require__(343);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__pages_add_wallet_add_wallet__ = __webpack_require__(320);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__pages_add_copayers_copayers__ = __webpack_require__(1027);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__pages_add_import_wallet_import_wallet__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__pages_add_join_wallet_join_wallet__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__pages_fingerprint_fingerprint__ = __webpack_require__(1028);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__pages_integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__pages_integrations_coinbase_coinbase__ = __webpack_require__(248);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__pages_integrations_invoice_select_invoice_select_invoice__ = __webpack_require__(1029);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__pages_integrations_shapeshift_shapeshift__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__pages_onboarding_disclaimer_disclaimer__ = __webpack_require__(475);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__pages_onboarding_onboarding__ = __webpack_require__(1030);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__pages_paper_wallet_paper_wallet__ = __webpack_require__(467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__pages_pin_pin_modal_pin_modal__ = __webpack_require__(332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__pages_send_amount_amount__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__pages_send_confirm_confirm__ = __webpack_require__(249);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__pages_settings_addressbook_add_add__ = __webpack_require__(333);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__pages_tabs_tabs__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__pages_wallet_details_wallet_details__ = __webpack_require__(476);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__pages_wallet_tabs_wallet_tabs__ = __webpack_require__(1034);









// providers
















// pages




















// As the handleOpenURL handler kicks in before the App is started,
// declare the handler function at the top of app.component.ts (outside the class definition)
// to track the passed Url
window.handleOpenURL = (url) => {
    window.handleOpenURL_LastURL = url;
};
let CopayApp = class CopayApp {
    constructor(config, platform, platformProvider, statusBar, splashScreen, events, logger, appProvider, profile, configProvider, giftCardProvider, imageLoaderConfig, modalCtrl, coinbaseProvider, bitPayCardProvider, shapeshiftProvider, emailNotificationsProvider, screenOrientation, popupProvider, pushNotificationsProvider, incomingDataProvider, walletTabsProvider, renderer, userAgent, device, keyProvider) {
        this.config = config;
        this.platform = platform;
        this.platformProvider = platformProvider;
        this.statusBar = statusBar;
        this.splashScreen = splashScreen;
        this.events = events;
        this.logger = logger;
        this.appProvider = appProvider;
        this.profile = profile;
        this.configProvider = configProvider;
        this.giftCardProvider = giftCardProvider;
        this.imageLoaderConfig = imageLoaderConfig;
        this.modalCtrl = modalCtrl;
        this.coinbaseProvider = coinbaseProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.shapeshiftProvider = shapeshiftProvider;
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.screenOrientation = screenOrientation;
        this.popupProvider = popupProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.walletTabsProvider = walletTabsProvider;
        this.renderer = renderer;
        this.userAgent = userAgent;
        this.device = device;
        this.keyProvider = keyProvider;
        this.pageMap = {
            AddressbookAddPage: __WEBPACK_IMPORTED_MODULE_41__pages_settings_addressbook_add_add__["a" /* AddressbookAddPage */],
            AmountPage: __WEBPACK_IMPORTED_MODULE_39__pages_send_amount_amount__["a" /* AmountPage */],
            BitPayCardIntroPage: __WEBPACK_IMPORTED_MODULE_31__pages_integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__["a" /* BitPayCardIntroPage */],
            CoinbasePage: __WEBPACK_IMPORTED_MODULE_32__pages_integrations_coinbase_coinbase__["a" /* CoinbasePage */],
            ConfirmPage: __WEBPACK_IMPORTED_MODULE_40__pages_send_confirm_confirm__["a" /* ConfirmPage */],
            CopayersPage: __WEBPACK_IMPORTED_MODULE_27__pages_add_copayers_copayers__["a" /* CopayersPage */],
            ImportWalletPage: __WEBPACK_IMPORTED_MODULE_28__pages_add_import_wallet_import_wallet__["a" /* ImportWalletPage */],
            JoinWalletPage: __WEBPACK_IMPORTED_MODULE_29__pages_add_join_wallet_join_wallet__["a" /* JoinWalletPage */],
            AddWalletPage: __WEBPACK_IMPORTED_MODULE_26__pages_add_wallet_add_wallet__["a" /* AddWalletPage */],
            PaperWalletPage: __WEBPACK_IMPORTED_MODULE_37__pages_paper_wallet_paper_wallet__["a" /* PaperWalletPage */],
            ShapeshiftPage: __WEBPACK_IMPORTED_MODULE_34__pages_integrations_shapeshift_shapeshift__["a" /* ShapeshiftPage */],
            SelectInvoicePage: __WEBPACK_IMPORTED_MODULE_33__pages_integrations_invoice_select_invoice_select_invoice__["a" /* SelectInvoicePage */],
            WalletDetailsPage: __WEBPACK_IMPORTED_MODULE_43__pages_wallet_details_wallet_details__["a" /* WalletDetailsPage */]
        };
        this.imageLoaderConfig.setFileNameCachedWithExtension(true);
        this.imageLoaderConfig.useImageTag(true);
        this.imageLoaderConfig.enableSpinner(false);
        this.initializeApp();
    }
    ngOnDestroy() {
        this.onResumeSubscription.unsubscribe();
    }
    initializeApp() {
        this.config.set('backButtonIcon', 'tab-button-back');
        this.platform
            .ready()
            .then(readySource => {
            this.onPlatformReady(readySource);
        })
            .catch(e => {
            this.logger.error('Platform is not ready.', e);
        });
    }
    onPlatformReady(readySource) {
        this.appProvider
            .load()
            .then(() => {
            this.onAppLoad(readySource);
        })
            .catch(err => {
            const title = 'Could not initialize the app';
            let message;
            try {
                message = err instanceof Error ? err.toString() : JSON.stringify(err);
            }
            catch (error) {
                message = 'Unknown error';
            }
            this.popupProvider.ionicAlert(title, message);
        });
    }
    onAppLoad(readySource) {
        const deviceInfo = this.platformProvider.getDeviceInfo();
        this.logger.info('Platform ready (' +
            readySource +
            '): ' +
            this.appProvider.info.nameCase +
            ' - v' +
            this.appProvider.info.version +
            ' #' +
            this.appProvider.info.commitHash +
            deviceInfo);
        if (this.platform.is('cordova')) {
            this.statusBar.show();
            // Set User-Agent
            this.userAgent.set(this.appProvider.info.name +
                ' ' +
                this.appProvider.info.version +
                ' (' +
                this.device.platform +
                ' ' +
                this.device.version +
                ' - ' +
                this.device.model +
                ')');
            // Set to portrait
            this.screenOrientation.lock(this.screenOrientation.ORIENTATIONS.PORTRAIT);
            // Only overlay for iOS
            if (this.platform.is('ios'))
                this.statusBar.overlaysWebView(true);
            this.statusBar.styleLightContent();
            this.splashScreen.hide();
            // Subscribe Resume
            this.onResumeSubscription = this.platform.resume.subscribe(() => {
                // Check PIN or Fingerprint on Resume
                this.openLockModal();
                // Clear all notifications
                this.pushNotificationsProvider.clearAllNotifications();
            });
            // Check PIN or Fingerprint
            this.openLockModal();
            // Clear all notifications
            this.pushNotificationsProvider.clearAllNotifications();
        }
        this.registerIntegrations();
        this.incomingDataRedirEvent();
        this.scanFromWalletEvent();
        this.events.subscribe('OpenWallet', (wallet, params) => this.openWallet(wallet, params));
        this.keyProvider
            .load()
            .then(() => {
            // Check Profile
            this.profile
                .loadAndBindProfile()
                .then(profile => {
                this.onProfileLoad(profile);
            })
                .catch((err) => {
                switch (err.message) {
                    case 'NONAGREEDDISCLAIMER':
                        this.logger.warn('Non agreed disclaimer');
                        this.rootPage = __WEBPACK_IMPORTED_MODULE_35__pages_onboarding_disclaimer_disclaimer__["a" /* DisclaimerPage */];
                        break;
                    default:
                        this.popupProvider.ionicAlert('Could not initialize the app', err.message);
                }
            });
        })
            .catch(err => {
            this.popupProvider.ionicAlert('Error loading keys', err.message || '');
            this.logger.error('Error loading keys: ', err);
        });
    }
    onProfileLoad(profile) {
        this.emailNotificationsProvider.init(); // Update email subscription if necessary
        this.initPushNotifications();
        if (profile) {
            this.logger.info('Profile exists.');
            this.rootPage = __WEBPACK_IMPORTED_MODULE_42__pages_tabs_tabs__["a" /* TabsPage */];
            if (this.platform.is('cordova')) {
                this.handleDeepLinks();
            }
            if (this.isElectronPlatform()) {
                this.handleDeepLinksElectron();
            }
        }
        else {
            this.logger.info('No profile exists.');
            this.profile.createProfile();
            this.rootPage = __WEBPACK_IMPORTED_MODULE_36__pages_onboarding_onboarding__["a" /* OnboardingPage */];
        }
    }
    openLockModal() {
        if (this.appProvider.isLockModalOpen)
            return;
        const config = this.configProvider.get();
        const lockMethod = config && config.lock && config.lock.method
            ? config.lock.method.toLowerCase()
            : null;
        if (!lockMethod)
            return;
        if (lockMethod == 'pin')
            this.openPINModal('checkPin');
        if (lockMethod == 'fingerprint')
            this.openFingerprintModal();
    }
    openPINModal(action) {
        this.appProvider.isLockModalOpen = true;
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_38__pages_pin_pin_modal_pin_modal__["a" /* PinModalPage */], { action }, {
            enableBackdropDismiss: false,
            cssClass: 'fullscreen-modal'
        });
        modal.present({ animate: false });
        modal.onDidDismiss(() => {
            this.appProvider.isLockModalOpen = false;
            this.events.publish('Home/reloadStatus');
        });
    }
    openFingerprintModal() {
        this.appProvider.isLockModalOpen = true;
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_30__pages_fingerprint_fingerprint__["a" /* FingerprintModalPage */], {}, {
            enableBackdropDismiss: false,
            cssClass: 'fullscreen-modal'
        });
        modal.present({ animate: false });
        modal.onDidDismiss(() => {
            this.appProvider.isLockModalOpen = false;
            this.events.publish('Home/reloadStatus');
        });
    }
    registerIntegrations() {
        // Gift Cards
        if (this.appProvider.info._enabledExtensions.giftcards)
            this.giftCardProvider.register();
        // ShapeShift
        if (this.appProvider.info._enabledExtensions.shapeshift) {
            this.shapeshiftProvider.setCredentials();
            this.shapeshiftProvider.register();
        }
        // Coinbase
        if (this.appProvider.info._enabledExtensions.coinbase) {
            this.coinbaseProvider.setCredentials();
            this.coinbaseProvider.register();
        }
        // BitPay Card
        if (this.appProvider.info._enabledExtensions.debitcard)
            this.bitPayCardProvider.register();
    }
    incomingDataRedirEvent() {
        this.events.subscribe('IncomingDataRedir', nextView => {
            this.closeScannerFromWithinWallet();
            this.getSelectedTabNav().push(this.pageMap[nextView.name], nextView.params);
        });
    }
    openWallet(wallet, params) {
        // check if modal is already open
        if (this.isWalletModalOpen) {
            this.walletModal.dismiss();
        }
        const page = wallet.isComplete() ? __WEBPACK_IMPORTED_MODULE_44__pages_wallet_tabs_wallet_tabs__["a" /* WalletTabsPage */] : __WEBPACK_IMPORTED_MODULE_27__pages_add_copayers_copayers__["a" /* CopayersPage */];
        this.isWalletModalOpen = true;
        this.walletModal = this.modalCtrl.create(page, Object.assign({}, params, { walletId: wallet.credentials.walletId }), {
            cssClass: 'wallet-details-modal'
        });
        this.walletModal.present();
        this.walletModal.onDidDismiss(() => {
            this.isWalletModalOpen = false;
        });
    }
    scanFromWalletEvent() {
        this.events.subscribe('ScanFromWallet', () => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.getGlobalTabs().select(1);
            yield this.toggleScannerVisibilityFromWithinWallet(true, 300);
        }));
        this.events.subscribe('ExitScan', () => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.closeScannerFromWithinWallet();
        }));
    }
    closeScannerFromWithinWallet() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (!this.getWalletDetailsModal()) {
                return;
            }
            yield this.toggleScannerVisibilityFromWithinWallet(false, 300);
            yield this.getGlobalTabs().select(0);
        });
    }
    toggleScannerVisibilityFromWithinWallet(visible, transitionDuration) {
        const walletDetailsModal = this.getWalletDetailsModal();
        this.renderer.setElementClass(walletDetailsModal, 'scanning', visible);
        return __WEBPACK_IMPORTED_MODULE_8_rxjs__["Observable"].timer(transitionDuration).toPromise();
    }
    getWalletDetailsModal() {
        return document.getElementsByClassName('wallet-details-modal')[0];
    }
    initPushNotifications() {
        this.pushNotificationsProvider.init();
    }
    handleDeepLinks() {
        // Check if app was resume by custom url scheme
        window.handleOpenURL = (url) => {
            this.logger.info('App was resumed by custom url scheme');
            this.handleOpenUrl(url);
        };
        // Check if app was opened by custom url scheme
        const lastUrl = window.handleOpenURL_LastURL || '';
        if (lastUrl && lastUrl !== '') {
            delete window.handleOpenURL_LastURL;
            // Important delay to have all views loaded before process URL
            setTimeout(() => {
                this.logger.info('App was opened by custom url scheme');
                this.handleOpenUrl(lastUrl);
            }, 2000);
        }
    }
    handleOpenUrl(url) {
        if (!this.incomingDataProvider.redir(url)) {
            this.logger.warn('Unknown URL! : ' + url);
        }
    }
    handleDeepLinksElectron() {
        const electron = window.require('electron');
        electron.ipcRenderer.on('open-url-event', (_, url) => {
            this.processUrl(url);
        });
    }
    processUrl(pathData) {
        if (pathData.indexOf('bitcoincash:/') != -1) {
            this.logger.debug('Bitcoin Cash URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf('bitcoincash:/')));
        }
        else if (pathData.indexOf('bitcoin:/') != -1) {
            this.logger.debug('Bitcoin URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf('bitcoin:/')));
        }
        else if (pathData.indexOf(this.appProvider.info.name + '://') != -1) {
            this.logger.debug(this.appProvider.info.name + ' URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf(this.appProvider.info.name + '://')));
        }
        else {
            this.logger.debug('URL found');
            this.handleOpenUrl(pathData);
        }
    }
    isElectronPlatform() {
        const userAgent = navigator && navigator.userAgent
            ? navigator.userAgent.toLowerCase()
            : null;
        if (userAgent && userAgent.indexOf(' electron/') > -1) {
            return true;
        }
        else {
            return false;
        }
    }
    getSelectedTabNav() {
        const globalNav = this.getGlobalTabs().getSelected();
        const walletTabs = this.walletTabsProvider.getTabNav();
        return (walletTabs && walletTabs.getSelected()) || globalNav;
    }
    getGlobalTabs() {
        return this.nav.getActiveChildNavs()[0].viewCtrl.instance.tabs;
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('appNav'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_7_ionic_angular__["n" /* NavController */])
], CopayApp.prototype, "nav", void 0);
CopayApp = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/app/app.html"*/'<ion-nav #appNav [root]="rootPage"></ion-nav>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/app/app.html"*/,
        providers: [__WEBPACK_IMPORTED_MODULE_24__providers_touchid_touchid__["a" /* TouchIdProvider */]]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7_ionic_angular__["d" /* Config */],
        __WEBPACK_IMPORTED_MODULE_7_ionic_angular__["q" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_19__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_5__ionic_native_status_bar__["a" /* StatusBar */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_splash_screen__["a" /* SplashScreen */],
        __WEBPACK_IMPORTED_MODULE_7_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_18__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers__["E" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_25_ionic_image_loader__["b" /* ImageLoaderConfig */],
        __WEBPACK_IMPORTED_MODULE_7_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_13__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_23__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_screen_orientation__["a" /* ScreenOrientation */],
        __WEBPACK_IMPORTED_MODULE_20__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_22__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_9__pages_wallet_tabs_wallet_tabs_provider__["a" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["Renderer"],
        __WEBPACK_IMPORTED_MODULE_6__ionic_native_user_agent__["a" /* UserAgent */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__["a" /* Device */],
        __WEBPACK_IMPORTED_MODULE_17__providers_key_key__["a" /* KeyProvider */]])
], CopayApp);

//# sourceMappingURL=app.component.js.map

/***/ }),

/***/ 147:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmailNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);



// providers




let EmailNotificationsProvider = class EmailNotificationsProvider {
    constructor(configProvider, profileProvider, walletProvider, logger) {
        this.configProvider = configProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.logger = logger;
        this.logger.debug('EmailNotificationsProvider initialized');
    }
    updateEmail(opts) {
        opts = opts || {};
        if (!opts.email)
            return;
        this.configProvider.set({
            emailFor: null,
            emailNotifications: {
                enabled: opts.enabled,
                email: opts.enabled ? opts.email : null
            }
        });
        setTimeout(() => {
            const opts = {
                showHidden: true
            };
            let wallets = this.profileProvider.getWallets(opts);
            this.walletProvider.updateRemotePreferences(wallets);
        }, 1000);
    }
    getEmailIfEnabled(config) {
        config = config ? config : this.configProvider.get();
        if (config.emailNotifications) {
            if (!config.emailNotifications.enabled)
                return;
            if (config.emailNotifications.email)
                return config.emailNotifications.email;
        }
        if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](config.emailFor))
            return;
        // Backward compatibility
        let emails = __WEBPACK_IMPORTED_MODULE_6_lodash__["values"](config.emailFor);
        for (var i = 0; i < emails.length; i++) {
            if (emails[i] !== null && typeof emails[i] !== 'undefined') {
                return emails[i];
            }
        }
    }
    init() {
        let config = this.configProvider.get();
        if (config.emailNotifications && config.emailNotifications.enabled) {
            // If email already set
            if (config.emailNotifications.email)
                return;
            var currentEmail = this.getEmailIfEnabled(config);
            this.updateEmail({
                enabled: currentEmail ? true : false,
                email: currentEmail
            });
        }
    }
};
EmailNotificationsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_5__wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], EmailNotificationsProvider);

//# sourceMappingURL=email-notifications.js.map

/***/ }),

/***/ 1471:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FileStorage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_file__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__istorage__ = __webpack_require__(860);






let FileStorage = class FileStorage {
    constructor(file, log) {
        this.file = file;
        this.log = log;
    }
    init() {
        return new Promise((resolve, reject) => {
            if (this.fs && this.dir)
                return resolve();
            const onSuccess = (fs) => {
                this.log.debug('File system started: ', fs.name, fs.root.name);
                this.fs = fs;
                return this.getDir().then(dir => {
                    if (!dir.nativeURL)
                        return reject();
                    this.dir = dir;
                    this.log.debug('Got main dir:', dir.nativeURL);
                    return resolve();
                });
            };
            const onFailure = (err) => {
                this.log.error('Could not init file system: ' + err.message);
                return Promise.reject(err);
            };
            window.requestFileSystem(1, 0, onSuccess, onFailure);
        });
    }
    // See https://github.com/apache/cordova-plugin-file/#where-to-store-files
    getDir() {
        if (!this.file) {
            return Promise.reject(new Error('Could not write on device storage'));
        }
        const url = this.file.dataDirectory;
        return this.file.resolveDirectoryUrl(url).catch(err => {
            const msg = 'Could not resolve filesystem ' + url;
            this.log.warn(msg, err);
            throw err || new Error(msg);
        });
    }
    parseResult(v) {
        if (!v)
            return null;
        if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](v))
            return v;
        let parsed;
        try {
            parsed = JSON.parse(v);
        }
        catch (e) {
            // TODO parse is not necessary
        }
        return parsed || v;
    }
    readFileEntry(fileEntry) {
        return new Promise((resolve, reject) => {
            fileEntry.file(file => {
                const reader = new FileReader();
                reader.onerror = () => {
                    reader.abort();
                    return reject();
                };
                reader.onloadend = () => {
                    return resolve(this.parseResult(reader.result));
                };
                reader.readAsText(file);
            });
        });
    }
    get(k) {
        return new Promise(resolve => {
            this.init()
                .then(() => {
                this.file
                    .getFile(this.dir, k, { create: false })
                    .then(fileEntry => {
                    if (!fileEntry)
                        return resolve();
                    this.readFileEntry(fileEntry)
                        .then(result => {
                        return resolve(result);
                    })
                        .catch(() => {
                        this.log.error('Problem parsing input file.');
                    });
                })
                    .catch(err => {
                    // Not found
                    if (err.code == 1)
                        return resolve();
                    else
                        throw err;
                });
            })
                .catch(err => {
                this.log.error(err);
            });
        });
    }
    set(k, v) {
        return Promise.resolve(this.init().then(() => {
            this.file.getFile(this.dir, k, { create: true }).then(fileEntry => {
                // Create a FileWriter object for our FileEntry (log.txt).
                return new Promise((resolve, reject) => {
                    fileEntry.createWriter(fileWriter => {
                        fileWriter.onwriteend = () => {
                            this.log.debug('Successful file write...');
                            return resolve();
                        };
                        fileWriter.onerror = e => {
                            this.log.error('Failed file write: ' + e.toString());
                            return reject(e.toString());
                        };
                        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isObject"](v))
                            v = JSON.stringify(v);
                        if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](v))
                            v = v.toString();
                        fileWriter.write(v);
                    });
                });
            });
        }));
    }
    remove(k) {
        return new Promise((resolve, reject) => {
            this.file
                .removeFile(this.dir.nativeURL, k)
                .then(() => {
                this.log.debug(`Storage Key: ${k} removed`);
                resolve();
            })
                .catch(e => {
                reject(e);
            });
        });
    }
    create(k, v) {
        return this.get(k).then(data => {
            if (data)
                throw new __WEBPACK_IMPORTED_MODULE_5__istorage__["a" /* KeyAlreadyExistsError */]();
            this.set(k, v);
        });
    }
};
FileStorage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */]])
], FileStorage);

//# sourceMappingURL=file-storage.js.map

/***/ }),

/***/ 1472:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LocalStorage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__istorage__ = __webpack_require__(860);





let LocalStorage = class LocalStorage {
    constructor(logger) {
        this.logger = logger;
        if (!window.localStorage)
            throw new Error('localstorage not available');
        this.ls = window.localStorage;
    }
    processValue(v) {
        if (!v)
            return null;
        if (!__WEBPACK_IMPORTED_MODULE_2_lodash__["isString"](v))
            return v;
        let parsed;
        try {
            parsed = JSON.parse(v);
        }
        catch (e) {
            // TODO parse is not necessary
        }
        return parsed || v;
    }
    get(k) {
        return new Promise(resolve => {
            let v = this.ls.getItem(k);
            return resolve(this.processValue(v));
        });
    }
    set(k, v) {
        return new Promise(resolve => {
            if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isObject"](v))
                v = JSON.stringify(v);
            if (!__WEBPACK_IMPORTED_MODULE_2_lodash__["isString"](v))
                v = v.toString();
            this.ls.setItem(k, v);
            resolve();
        });
    }
    remove(k) {
        return new Promise(resolve => {
            this.ls.removeItem(k);
            this.logger.debug(`Storage Key: ${k} removed`);
            resolve();
        });
    }
    create(k, v) {
        return this.get(k).then(data => {
            if (data)
                throw new __WEBPACK_IMPORTED_MODULE_4__istorage__["a" /* KeyAlreadyExistsError */]();
            this.set(k, v);
        });
    }
};
LocalStorage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__logger_logger__["a" /* Logger */]])
], LocalStorage);

//# sourceMappingURL=local-storage.js.map

/***/ }),

/***/ 1478:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 148:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TimeProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let TimeProvider = class TimeProvider {
    constructor() { }
    withinSameMonth(time1, time2) {
        if (!time1 || !time2)
            return false;
        let date1 = new Date(time1);
        let date2 = new Date(time2);
        return this.getMonthYear(date1) === this.getMonthYear(date2);
    }
    withinPastDay(time) {
        let now = new Date();
        let date = new Date(time);
        return now.getTime() - date.getTime() < 1000 * 60 * 60 * 24;
    }
    isDateInCurrentMonth(date) {
        let now = new Date();
        return this.getMonthYear(now) === this.getMonthYear(date);
    }
    getMonthYear(date) {
        return `${date.getMonth()}-${date.getFullYear()}`;
    }
};
TimeProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [])
], TimeProvider);

//# sourceMappingURL=time.js.map

/***/ }),

/***/ 1483:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 15:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProfileProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__language_language__ = __webpack_require__(244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__replace_parameters_replace_parameters__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__models_profile_profile_model__ = __webpack_require__(1954);






// providers
















// models

let ProfileProvider = class ProfileProvider {
    constructor(currencyProvider, logger, persistenceProvider, configProvider, replaceParametersProvider, bwcProvider, bwcErrorProvider, platformProvider, appProvider, languageProvider, events, popupProvider, onGoingProcessProvider, translate, txFormatProvider, actionSheetProvider, keyProvider, derivationPathHelperProvider) {
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.configProvider = configProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.bwcProvider = bwcProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.platformProvider = platformProvider;
        this.appProvider = appProvider;
        this.languageProvider = languageProvider;
        this.events = events;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.translate = translate;
        this.txFormatProvider = txFormatProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.keyProvider = keyProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.walletsGroups = {}; // TODO walletGroups Class
        this.wallet = {};
        this.UPDATE_PERIOD = 15;
        this.UPDATE_PERIOD_FAST = 5;
        this.validationLock = false;
        this.errors = this.bwcProvider.getErrors();
        this.throttledBwsEvent = __WEBPACK_IMPORTED_MODULE_4_lodash__["throttle"]((n, wallet) => {
            this.newBwsEvent(n, wallet);
        }, 10000);
    }
    trySetName(wallet, i = 0) {
        const config = this.configProvider.get();
        if (i > 5) {
            // just put the Id is the prev fails
            wallet.linkedEthWalletName = wallet.linkedEthWallet;
            return;
        }
        let linked = this.getWallet(wallet.linkedEthWallet);
        if (linked && linked.credentials) {
            this.logger.debug('Setting linkedEthWalletName:' + wallet.linkedEthWallet);
            wallet.linkedEthWalletName =
                (config.aliasFor && config.aliasFor[linked.id]) ||
                    linked.credentials.walletName;
            return;
        }
        else {
            this.logger.debug('Waiting to set name for linkedEthWalletName:' + wallet.linkedEthWallet);
            return window.setTimeout(() => {
                this.trySetName(wallet, i + 1);
            }, 2000);
        }
    }
    updateWalletFromConfig(wallet) {
        const config = this.configProvider.get();
        const defaults = this.configProvider.getDefaults();
        // this.config.whenAvailable( (config) => { TODO
        wallet.usingCustomBWS =
            config.bwsFor &&
                config.bwsFor[wallet.id] &&
                config.bwsFor[wallet.id] != defaults.bws.url;
        wallet.name =
            (config.aliasFor && config.aliasFor[wallet.id]) ||
                wallet.credentials.walletName;
        wallet.email = config.emailFor && config.emailFor[wallet.id];
        // for token wallets
        wallet.linkedEthWallet = this.currencyProvider.getLinkedEthWallet(wallet.coin, wallet.id);
        if (wallet.linkedEthWallet) {
            this.trySetName(wallet);
        }
    }
    setWalletOrder(walletId, index) {
        this.persistenceProvider.setWalletOrder(walletId, index).then(() => {
            this.logger.debug('Wallet new order stored for ' + walletId + ': ' + index);
        });
        if (this.wallet[walletId])
            this.wallet[walletId]['order'] = index;
    }
    setWalletGroupName(keyId, name) {
        this.persistenceProvider.setWalletGroupName(keyId, name);
        if (this.walletsGroups[keyId])
            this.walletsGroups[keyId].name = name;
    }
    getWalletGroupName(keyId) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const name = yield this.persistenceProvider.getWalletGroupName(keyId);
            return name;
        });
    }
    getWalletOrder(walletId) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const order = yield this.persistenceProvider.getWalletOrder(walletId);
            return order;
        });
    }
    setBackupGroupFlag(keyId, timestamp, migrating) {
        if (!keyId)
            return;
        this.persistenceProvider.setBackupGroupFlag(keyId, timestamp);
        this.logger.debug('Backup flag stored');
        if (!migrating)
            this.walletsGroups[keyId].needsBackup = false;
    }
    setWalletBackup(walletId) {
        this.wallet[walletId].needsBackup = false;
    }
    requiresGroupBackup(keyId) {
        let k = this.keyProvider.getKey(keyId);
        if (!k)
            return false;
        if (!k.mnemonic && !k.mnemonicEncrypted)
            return false;
        return true;
    }
    requiresBackup(wallet) {
        let k = this.keyProvider.getKey(wallet.credentials.keyId);
        if (!k)
            return false;
        if (!k.mnemonic && !k.mnemonicEncrypted)
            return false;
        if (wallet.credentials.network == 'testnet')
            return false;
        return true;
    }
    getBackupInfo(wallet) {
        if (!this.requiresBackup(wallet)) {
            return Promise.resolve({ needsBackup: false });
        }
        return this.persistenceProvider
            .getBackupFlag(wallet.credentials.walletId)
            .then(timestamp => {
            if (timestamp) {
                return Promise.resolve({ needsBackup: false, timestamp });
            }
            return Promise.resolve({ needsBackup: true });
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    getBackupGroupInfo(keyId, wallet) {
        if (!this.requiresGroupBackup(keyId)) {
            return Promise.resolve({ needsBackup: false });
        }
        return this.persistenceProvider
            .getBackupGroupFlag(keyId)
            .then((timestamp) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (timestamp) {
                return Promise.resolve({ needsBackup: false, timestamp });
            }
            else {
                const backupInfo = yield this.getBackupInfo(wallet);
                if (backupInfo && !backupInfo.needsBackup) {
                    this.setBackupGroupFlag(keyId, backupInfo.timestamp, true);
                    return Promise.resolve({
                        needsBackup: false,
                        timestamp: backupInfo.timestamp
                    });
                }
            }
            return Promise.resolve({ needsBackup: true });
        }))
            .catch(err => {
            this.logger.error(err);
        });
    }
    isBalanceHidden(wallet) {
        return new Promise(resolve => {
            this.persistenceProvider
                .getHideBalanceFlag(wallet.credentials.walletId)
                .then(shouldHideBalance => {
                const isHidden = shouldHideBalance && shouldHideBalance.toString() == 'true'
                    ? true
                    : false;
                return resolve(isHidden);
            })
                .catch(err => {
                this.logger.error(err);
            });
        });
    }
    isWalletHidden(wallet) {
        return new Promise(resolve => {
            this.persistenceProvider
                .getHideWalletFlag(wallet.credentials.walletId)
                .then(shouldHideWallet => {
                const isHidden = shouldHideWallet && shouldHideWallet.toString() == 'true'
                    ? true
                    : false;
                return resolve(isHidden);
            })
                .catch(err => {
                this.logger.error(err);
            });
        });
    }
    bindWalletClient(wallet) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const walletId = wallet.credentials.walletId;
            let keyId = wallet.credentials.keyId;
            if (this.wallet[walletId] && this.wallet[walletId].started) {
                this.logger.info('This wallet has been initialized. Skip. ' + walletId);
                return Promise.resolve(false);
            }
            // Workaround to avoid wrong order relatad to async functions
            if (keyId)
                this.walletsGroups[keyId] = {};
            this.wallet[walletId] = {};
            // INIT WALLET VIEWMODEL
            wallet.id = walletId;
            wallet.started = true;
            wallet.network = wallet.credentials.network;
            wallet.copayerId = wallet.credentials.copayerId;
            wallet.m = wallet.credentials.m;
            wallet.n = wallet.credentials.n;
            wallet.coin = wallet.credentials.coin;
            wallet.cachedStatus = {};
            wallet.balanceHidden = yield this.isBalanceHidden(wallet);
            wallet.order = yield this.getWalletOrder(wallet.id);
            wallet.hidden = yield this.isWalletHidden(wallet);
            wallet.canSign = keyId ? true : false;
            wallet.isPrivKeyEncrypted = wallet.canSign
                ? this.keyProvider.isPrivKeyEncrypted(keyId)
                : false;
            wallet.canAddNewAccount = this.checkAccountCreation(wallet, keyId);
            this.updateWalletFromConfig(wallet);
            this.wallet[walletId] = wallet;
            // INIT WALLET GROUP VIEWMODEL
            let groupBackupInfo, needsBackup, order, name, isPrivKeyEncrypted, canSign, isDeletedSeed;
            if (keyId) {
                groupBackupInfo = yield this.getBackupGroupInfo(keyId, wallet);
                needsBackup = groupBackupInfo.needsBackup;
                isPrivKeyEncrypted = this.keyProvider.isPrivKeyEncrypted(keyId);
                canSign = true;
                isDeletedSeed = this.keyProvider.isDeletedSeed(keyId);
                name = yield this.getWalletGroupName(keyId);
                if (!name) {
                    let walletsGroups = __WEBPACK_IMPORTED_MODULE_4_lodash__["cloneDeep"](this.walletsGroups);
                    delete walletsGroups['read-only'];
                    // use wallets name for wallets group name at migration
                    name = `Key ${Object.keys(walletsGroups).indexOf(keyId) + 1}`;
                }
            }
            else {
                keyId = 'read-only';
                needsBackup = false;
                name = 'Read Only Wallets';
                isPrivKeyEncrypted = false;
                canSign = false;
                isDeletedSeed = true;
            }
            wallet.needsBackup = needsBackup;
            wallet.keyId = keyId;
            wallet.walletGroupName = name;
            this.walletsGroups[keyId] = {
                order,
                name,
                isPrivKeyEncrypted,
                needsBackup,
                canSign,
                isDeletedSeed
            };
            let date;
            if (groupBackupInfo && groupBackupInfo.timestamp)
                date = new Date(Number(groupBackupInfo.timestamp));
            this.logger.info(`Binding wallet: ${wallet.id} - Backed up: ${!needsBackup} ${date ? date : ''} - Encrypted: ${wallet.isPrivKeyEncrypted} - Token: ${!!wallet
                .credentials.token}`);
            // If this is a token wallet, no need to initialize the rest
            if (wallet.credentials.token) {
                return Promise.resolve(true);
            }
            wallet.removeAllListeners();
            wallet.on('report', n => {
                this.logger.info('BWC Report:' + n);
            });
            wallet.on('notification', n => {
                if (this.platformProvider.isElectron) {
                    this.showDesktopNotifications(n, wallet);
                }
                if ((n.data.network && n.data.network != wallet.network) ||
                    (n.data.coin && n.data.coin != wallet.coin))
                    return;
                // TODO many NewBlocks notifications...if many blocks
                if (n.type == 'NewBlock' && n.data.network == 'testnet') {
                    this.throttledBwsEvent(n, wallet);
                }
                else {
                    this.newBwsEvent(n, wallet);
                }
            });
            wallet.on('walletCompleted', () => {
                this.logger.debug('Wallet completed');
                this.updateCredentials(JSON.parse(wallet.toString()));
                this.events.publish('Local/WalletUpdate', { walletId: wallet.id });
            });
            wallet.initialize({
                notificationIncludeOwn: true
            }, err => {
                if (err) {
                    this.logger.error('Could not init notifications err:', err);
                    return;
                }
                wallet.setNotificationsInterval(this.UPDATE_PERIOD);
                wallet.openWallet(() => { });
            });
            this.events.subscribe('Local/ConfigUpdate', opts => {
                this.logger.debug('Local/ConfigUpdate handler @profile', opts);
                if (opts.walletId && opts.walletId == wallet.id) {
                    this.logger.debug('Updating wallet from config ' + wallet.id);
                    this.updateWalletFromConfig(wallet);
                }
            });
            return Promise.resolve(true);
        });
    }
    checkAccountCreation(wallet, keyId) {
        /* Allow account creation only for wallets:
        wallet n=1 : BIP44 - P2PKH - BTC o BCH only if it is 145'
        wallet n>1 : BIP48 - P2SH - BTC o BCH only if it is 145'
        wallet n=1 : BIP44 - P2SH - ETH only if it is 60'
        key : !use44forMultisig - !use0forBCH - compliantDerivation - !BIP45
         */
        const key = this.keyProvider.getKey(keyId);
        if (!wallet) {
            return false;
        }
        else if (!key) {
            return false;
        }
        else if (key.use44forMultisig ||
            key.use0forBCH ||
            key.BIP45 ||
            key.compliantDerivation === false) {
            return false;
        }
        else {
            const derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(wallet.credentials.rootPath);
            const coinCode = this.derivationPathHelperProvider.parsePath(wallet.credentials.rootPath).coinCode;
            if (wallet.n == 1 &&
                wallet.credentials.addressType == 'P2PKH' &&
                derivationStrategy == 'BIP44' &&
                (wallet.coin == 'btc' || (wallet.coin == 'bch' && coinCode == "145'"))) {
                return true;
            }
            if (wallet.n > 1 &&
                wallet.credentials.addressType == 'P2SH' &&
                derivationStrategy == 'BIP48' &&
                (wallet.coin == 'btc' || (wallet.coin == 'bch' && coinCode == "145'"))) {
                return true;
            }
            if (wallet.n == 1 &&
                wallet.credentials.addressType == 'P2PKH' &&
                derivationStrategy == 'BIP44' &&
                (wallet.coin == 'eth' && coinCode == "60'")) {
                return true;
            }
            return false;
        }
    }
    setFastRefresh(wallet) {
        this.logger.debug(`Wallet ${wallet.id} set to fast refresh`);
        wallet.setNotificationsInterval(this.UPDATE_PERIOD_FAST);
    }
    setSlowRefresh(wallet) {
        this.logger.debug(`Wallet ${wallet.id} back to slow refresh`);
        wallet.setNotificationsInterval(this.UPDATE_PERIOD);
    }
    showDesktopNotifications(n, wallet) {
        if (!this.configProvider.get().desktopNotificationsEnabled)
            return;
        const creatorId = n && n.data && n.data.creatorId;
        const amount = n && n.data && n.data.amount;
        const walletName = wallet.name;
        let title;
        let body;
        let translatedMsg;
        switch (n.type) {
            case 'NewCopayer':
                if (wallet.copayerId != creatorId) {
                    title = this.translate.instant('New copayer');
                    translatedMsg = this.translate.instant('A new copayer just joined your wallet {{walletName}}.');
                    body = this.replaceParametersProvider.replace(translatedMsg, {
                        walletName
                    });
                }
                break;
            case 'WalletComplete':
                title = this.translate.instant('Wallet complete');
                translatedMsg = this.translate.instant('Your wallet {{walletName}} is complete.');
                body = this.replaceParametersProvider.replace(translatedMsg, {
                    walletName
                });
                break;
            case 'NewTxProposal':
                if (wallet && wallet.m > 1 && wallet.copayerId != creatorId) {
                    title = this.translate.instant('New payment proposal');
                    translatedMsg = this.translate.instant('A new payment proposal has been created in your wallet {{walletName}}.');
                    body = this.replaceParametersProvider.replace(translatedMsg, {
                        walletName
                    });
                }
                break;
            case 'NewIncomingTx':
                title = this.translate.instant('New payment received');
                const amountStr = this.txFormatProvider.formatAmountStr(wallet.coin, amount);
                translatedMsg = this.translate.instant('A payment of {{amountStr}} has been received into your wallet {{walletName}}.');
                body = this.replaceParametersProvider.replace(translatedMsg, {
                    amountStr,
                    walletName
                });
                break;
            case 'TxProposalFinallyRejected':
                title = this.translate.instant('Payment proposal rejected');
                translatedMsg = this.translate.instant('A payment proposal in your wallet {{walletName}} has been rejected.');
                body = this.replaceParametersProvider.replace(translatedMsg, {
                    walletName
                });
                break;
            case 'TxConfirmation':
                title = this.translate.instant('Transaction confirmed');
                translatedMsg = this.translate.instant('The transaction from {{walletName}} that you were waiting for has been confirmed.');
                body = this.replaceParametersProvider.replace(translatedMsg, {
                    walletName
                });
                break;
        }
        if (!body)
            return;
        const OS = this.platformProvider.getOS();
        if (OS && OS.OSName === 'MacOS')
            this.showOsNotifications(title, body);
        else
            this.showInAppNotification(title, body);
    }
    showInAppNotification(title, body) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const infoSheet = this.actionSheetProvider.createInfoSheet('in-app-notification', {
                title,
                body
            });
            yield infoSheet.present();
            yield __WEBPACK_IMPORTED_MODULE_5_rxjs__["Observable"].timer(7000).toPromise();
            infoSheet.dismiss();
        });
    }
    showOsNotifications(title, body) {
        const { ipcRenderer } = window.require('electron');
        ipcRenderer.send('new-notification', {
            title,
            body
        });
    }
    newBwsEvent(n, wallet) {
        this.events.publish('bwsEvent', wallet.id, n.type, n);
    }
    updateCredentials(credentials) {
        this.profile.updateWallet(credentials);
        this.storeProfileIfDirty();
    }
    runValidation(wallet, delay, retryDelay) {
        delay = delay ? delay : 500;
        retryDelay = retryDelay ? retryDelay : 50;
        if (this.validationLock) {
            return setTimeout(() => {
                return this.runValidation(wallet, delay, retryDelay);
            }, retryDelay);
        }
        this.validationLock = true;
        // IOS devices are already checked
        const skipDeviceValidation = this.platformProvider.isIOS ||
            this.profile.isDeviceChecked(this.platformProvider.ua);
        const walletId = wallet.credentials.walletId;
        this.logger.debug(`ValidatingWallet: ${walletId} skip Device: ${skipDeviceValidation}`);
        setTimeout(() => {
            wallet.validateKeyDerivation({
                skipDeviceValidation
            }, (_, isOK) => {
                this.validationLock = false;
                this.logger.debug(`ValidatingWallet End: ${walletId} isOK: ${isOK}`);
                if (isOK) {
                    this.profile.setChecked(this.platformProvider.ua, walletId);
                }
                else {
                    this.logger.warn(`Key Derivation failed for wallet: ${walletId}`);
                    this.persistenceProvider.clearLastAddress(walletId);
                }
                this.storeProfileIfDirty();
            });
        }, delay);
    }
    storeProfileLegacy(oldProfile) {
        this.persistenceProvider
            .storeProfileLegacy(oldProfile)
            .then(() => {
            this.logger.debug('Saved legacy Profile');
        })
            .catch(err => {
            this.logger.error('Could not save legacy Profile', err);
        });
    }
    storeProfileIfDirty() {
        if (!this.profile.dirty) {
            return Promise.resolve();
        }
        return this.persistenceProvider
            .storeProfile(this.profile)
            .then(() => {
            this.logger.debug('Saved modified Profile (Dirty)');
            return Promise.resolve();
        })
            .catch(err => {
            this.logger.error('Could not save Profile (Dirty)', err);
            return Promise.reject(err);
        });
    }
    askToEncryptKey(key) {
        if (!key)
            return Promise.resolve();
        if (key.isPrivKeyEncrypted())
            return Promise.resolve();
        const title = this.translate.instant('Would you like to protect this wallet with a password?');
        const message = this.translate.instant('Encryption can protect your funds if this device is stolen or compromised by malicious software.');
        const okText = this.translate.instant('Yes');
        const cancelText = this.translate.instant('No');
        return this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then(res => {
            if (!res) {
                return this.keyProvider.showWarningNoEncrypt().then(res => {
                    if (res)
                        return Promise.resolve();
                    return this.keyProvider.encryptNewKey(key);
                });
            }
            return this.keyProvider.encryptNewKey(key);
        });
    }
    addAndBindWalletClients(data, opts = { bwsurl: null }) {
        // Encrypt wallet
        this.onGoingProcessProvider.pause();
        return this.askToEncryptKey(data.key).then(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.onGoingProcessProvider.resume();
            const boundWalletClients = [];
            for (const walletClient of data.walletClients) {
                const boundClient = yield this.addAndBindWalletClient(walletClient, {
                    bwsurl: opts.bwsurl,
                    store: false
                });
                boundWalletClients.push(boundClient);
            }
            return this.keyProvider.addKey(data.key).then(() => {
                return this.storeProfileIfDirty()
                    .then(() => {
                    this.events.publish('Local/WalletListChange');
                    return this.checkIfAlreadyExist(boundWalletClients).then(() => {
                        return Promise.resolve(__WEBPACK_IMPORTED_MODULE_4_lodash__["compact"](boundWalletClients));
                    });
                })
                    .catch(err => {
                    return Promise.reject('failed to bind wallets:' + err);
                });
            });
        }));
    }
    checkIfAlreadyExist(walletClients) {
        return new Promise(resolve => {
            const countInArray = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](walletClients, item => item == undefined)
                .length;
            if (countInArray > 0) {
                const msg1 = this.replaceParametersProvider.replace(this.translate.instant('The wallet is already in the app'), { nameCase: this.appProvider.info.nameCase });
                const msg2 = this.replaceParametersProvider.replace(this.translate.instant('{{countInArray}} of your wallets already exist in {{nameCase}}'), {
                    countInArray,
                    nameCase: this.appProvider.info.nameCase
                });
                const msg = countInArray == 1 ? msg1 : msg2;
                const title = this.translate.instant('Error');
                const infoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg, title });
                infoSheet.present();
                infoSheet.onDidDismiss(() => {
                    return resolve();
                });
            }
            else {
                return resolve();
            }
        });
    }
    // Adds and bind a new client to the profile
    addAndBindWalletClient(wallet, opts = { bwsurl: null, store: true }) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (!wallet || !wallet.credentials) {
                return Promise.reject(this.translate.instant('Could not access wallet'));
            }
            const walletId = wallet.credentials.walletId;
            if (!this.profile.addWallet(JSON.parse(wallet.toString()))) {
                return Promise.resolve();
            }
            const skipKeyValidation = this.shouldSkipValidation(walletId);
            if (!skipKeyValidation) {
                this.logger.debug('Trying to runValidation: ' + walletId);
                yield this.runValidation(wallet);
            }
            this.saveBwsUrl(walletId, opts.bwsurl);
            return this.bindWalletClient(wallet).then(() => {
                if (!opts.store) {
                    this.logger.debug('No storing new walletClient');
                    return Promise.resolve(wallet);
                }
                else {
                    this.logger.debug('Storing new walletClient');
                    return this.storeProfileIfDirty().then(() => {
                        this.events.publish('Local/WalletListChange');
                        return Promise.resolve(wallet);
                    });
                }
            });
        });
    }
    saveBwsUrl(walletId, bwsurl = null) {
        const defaults = this.configProvider.getDefaults();
        const bwsFor = {};
        bwsFor[walletId] = bwsurl || defaults.bws.url;
        // Dont save the default
        if (bwsFor[walletId] == defaults.bws.url) {
            return;
        }
        this.configProvider.set({ bwsFor });
    }
    shouldSkipValidation(walletId) {
        return (true ||
            this.profile.isChecked(this.platformProvider.ua, walletId) ||
            this.platformProvider.isIOS); // disabled for now
    }
    setMetaData(wallet, addressBook) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook(wallet.credentials.network)
                .then(localAddressBook => {
                try {
                    localAddressBook = JSON.parse(localAddressBook);
                }
                catch (ex) {
                    this.logger.info('Address Book: JSON.parse not neccesary.', localAddressBook);
                }
                const mergeAddressBook = __WEBPACK_IMPORTED_MODULE_4_lodash__["merge"](addressBook, localAddressBook);
                this.persistenceProvider
                    .setAddressBook(wallet.credentials.network, JSON.stringify(mergeAddressBook))
                    .then(() => {
                    return resolve();
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    importExtendedPrivateKey(xPrivKey, opts) {
        this.logger.info('Importing Wallet xPrivKey');
        opts.xPrivKey = xPrivKey;
        return this.serverAssistedImport(opts).then(data => {
            return this.addAndBindWalletClients(data, {
                bwsurl: opts.bwsurl
            });
        });
    }
    importMnemonic(words, opts) {
        this.logger.info('Importing Wallets Mnemonic');
        words = this.normalizeMnemonic(words);
        opts.words = words;
        return this.serverAssistedImport(opts).then(data => {
            return this.addAndBindWalletClients(data, {
                bwsurl: opts.bwsurl
            });
        });
    }
    importFile(str, opts) {
        return this._importFile(str, opts).then(data => {
            this.onGoingProcessProvider.pause();
            return this.askToEncryptKey(data.key).then(() => {
                this.onGoingProcessProvider.resume();
                return this.keyProvider.addKey(data.key).then(() => {
                    return this.addAndBindWalletClient(data.walletClient, {
                        bwsurl: opts.bwsurl
                    }).then(walletClient => {
                        return this.checkIfAlreadyExist([].concat(walletClient)).then(() => {
                            return Promise.resolve(walletClient);
                        });
                    });
                });
            });
        });
    }
    _importFile(str, opts) {
        return new Promise((resolve, reject) => {
            opts = opts ? opts : {};
            opts['bp_partner'] = this.appProvider.info.name;
            opts['bp_partner_version'] = this.appProvider.info.version;
            this.logger.info('Importing Wallet:', opts);
            const client = this.bwcProvider.getClient(null, opts);
            let credentials;
            let key;
            let addressBook;
            const Key = this.bwcProvider.getKey();
            const data = JSON.parse(str);
            if (data.credentials) {
                try {
                    credentials = data.credentials;
                    if (data.key) {
                        key = Key.fromObj(data.key);
                    }
                    addressBook = data.addressBook;
                }
                catch (err) {
                    this.logger.error(err);
                    return reject(this.translate.instant('Could not import. Check input file.'));
                }
            }
            else {
                // old format ? root = credentials.
                try {
                    // needs to migrate?
                    if (data.xPrivKey && data.xPrivKeyEncrypted) {
                        this.logger.warn('Found both encrypted and decrypted key. Deleting the encrypted version');
                        delete data.xPrivKeyEncrypted;
                        delete data.mnemonicEncrypted;
                    }
                    let migrated = this.bwcProvider.upgradeCredentialsV1(data);
                    credentials = migrated.credentials;
                    key = migrated.key;
                    addressBook = data.addressBook ? data.addressBook : {};
                }
                catch (error) {
                    this.logger.error(error);
                    return reject(this.translate.instant('Could not import. Check input file.'));
                }
            }
            if (!credentials.n) {
                return reject('Backup format not recognized. If you are using a Copay Beta backup and version is older than 0.10, please see: https://github.com/bitpay/copay/issues/4730#issuecomment-244522614');
            }
            client.fromString(JSON.stringify(credentials));
            if (key) {
                this.logger.info(`Wallet ${credentials.walletId} key's extracted`);
            }
            else {
                this.logger.info(`READ-ONLY Wallet ${credentials.walletId} migrated`);
            }
            this.setMetaData(client, addressBook).catch(err => {
                this.logger.warn('Could not set meta data: ', err);
            });
            return resolve({ key, walletClient: client });
        });
    }
    // opts.words opts.xPrivKey
    serverAssistedImport(opts) {
        return new Promise((resolve, reject) => {
            this.bwcProvider.Client.serverAssistedImport(opts, {
                baseUrl: opts.bwsurl // clientOpts
            }, (err, key, walletClients) => {
                if (err) {
                    return reject(err);
                }
                if (walletClients.length === 0) {
                    return reject('WALLET_DOES_NOT_EXIST');
                }
                else {
                    return resolve({ key, walletClients });
                }
            });
        });
    }
    normalizeMnemonic(words) {
        if (!words || !words.indexOf)
            return words;
        // \u3000: A space of non-variable width: used in Chinese, Japanese, Korean
        const isJA = words.indexOf('\u3000') > -1;
        const wordList = words
            .trim()
            .toLowerCase()
            .split(/[\u3000\s]+/);
        return wordList.join(isJA ? '\u3000' : ' ');
    }
    createProfile() {
        this.logger.info('Creating profile');
        this.profile = __WEBPACK_IMPORTED_MODULE_22__models_profile_profile_model__["a" /* Profile */].create();
        this.persistenceProvider.storeNewProfile(this.profile);
    }
    bindProfile(profile) {
        const bindWallets = () => {
            const profileLength = profile.credentials.length;
            if (!profileLength) {
                return Promise.resolve();
            }
            const promises = [];
            return this.upgradeMultipleCredentials(profile).then(() => {
                __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](profile.credentials, credentials => {
                    promises.push(this.bindWallet(credentials));
                });
                return Promise.all(promises).then(() => {
                    this.logger.info(`Bound ${profileLength} wallets`);
                    return Promise.resolve();
                });
            });
        };
        return bindWallets().then(() => {
            return this.isDisclaimerAccepted().catch(() => {
                return Promise.reject(new Error('NONAGREEDDISCLAIMER'));
            });
        });
    }
    upgradeMultipleCredentials(profile) {
        const oldProfile = __WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](profile);
        const migrated = this.bwcProvider.upgradeMultipleCredentialsV1(profile.credentials);
        const newKeys = migrated.keys;
        const newCrededentials = migrated.credentials;
        if (newKeys.length > 0) {
            this.logger.info(`Storing ${newKeys.length} migrated Keys`);
            this.storeProfileLegacy(oldProfile);
            return this.keyProvider.addKeys(newKeys).then(() => {
                profile.credentials = newCrededentials;
                profile.dirty = true;
                return this.storeProfileIfDirty();
            });
        }
        else {
            if (newCrededentials.length > 0) {
                // Only RO wallets.
                this.storeProfileLegacy(oldProfile);
                profile.credentials = newCrededentials;
                profile.dirty = true;
                return this.storeProfileIfDirty();
            }
            return Promise.resolve();
        }
    }
    isDisclaimerAccepted() {
        return new Promise((resolve, reject) => {
            const disclaimerAccepted = this.profile && this.profile.disclaimerAccepted;
            if (disclaimerAccepted)
                return resolve();
            // OLD flag
            this.persistenceProvider.getCopayDisclaimerFlag().then(val => {
                if (val) {
                    this.profile.disclaimerAccepted = true;
                    return resolve();
                }
                else {
                    return reject();
                }
            });
        });
    }
    bindWallet(credentials) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (!credentials.walletId || !credentials.m) {
                return Promise.reject(new Error('bindWallet should receive credentials JSON'));
            }
            // Create the client
            const getBWSURL = (walletId) => {
                const config = this.configProvider.get();
                const defaults = this.configProvider.getDefaults();
                return (config.bwsFor && config.bwsFor[walletId]) || defaults.bws.url;
            };
            const walletClient = this.bwcProvider.getClient(JSON.stringify(credentials), {
                bwsurl: getBWSURL(credentials.walletId),
                bp_partner: this.appProvider.info.name,
                bp_partner_version: this.appProvider.info.version
            });
            const skipKeyValidation = this.shouldSkipValidation(credentials.walletId);
            if (!skipKeyValidation) {
                this.logger.debug('Trying to runValidation: ' + credentials.walletId);
                yield this.runValidation(walletClient, 500);
            }
            return this.bindWalletClient(walletClient);
        });
    }
    getProfileLegacy() {
        return this.persistenceProvider.getProfileLegacy().catch(err => {
            this.logger.info('Error getting old Profile', err);
        });
    }
    removeProfileLegacy() {
        return this.persistenceProvider.removeProfileLegacy().catch(err => {
            this.logger.info('Error getting old Profile', err);
        });
    }
    loadAndBindProfile() {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getProfile()
                .then(profile => {
                if (!profile) {
                    return resolve();
                }
                this.profile = __WEBPACK_IMPORTED_MODULE_22__models_profile_profile_model__["a" /* Profile */].fromObj(profile);
                // Deprecated: storageService.tryToMigrate
                this.logger.info('Profile loaded');
                this.bindProfile(this.profile)
                    .then(() => {
                    return resolve(this.profile);
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    importWithDerivationPath(opts) {
        return new Promise((resolve, reject) => {
            this.logger.info('Importing Wallet with derivation path');
            this._importWithDerivationPath(opts).then(data => {
                // Check if wallet exists
                data.walletClient.openWallet(err => {
                    if (err) {
                        if (err.message.indexOf('not found') > 0) {
                            err = 'WALLET_DOES_NOT_EXIST';
                        }
                        return reject(err);
                    }
                    this.keyProvider.addKey(data.key).then(() => {
                        this.addAndBindWalletClient(data.walletClient, {
                            bwsurl: opts.bwsurl
                        })
                            .then(walletClient => {
                            return this.checkIfAlreadyExist([].concat(walletClient)).then(() => {
                                return resolve(walletClient);
                            });
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    });
                });
            });
        });
    }
    _importWithDerivationPath(opts) {
        const showOpts = __WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](opts);
        if (showOpts.extendedPrivateKey)
            showOpts.extendedPrivateKey = '[hidden]';
        if (showOpts.mnemonic)
            showOpts.mnemonic = '[hidden]';
        this.logger.debug('Importing Wallet:', JSON.stringify(showOpts));
        return this.seedWallet(opts);
    }
    seedWallet(opts) {
        return new Promise((resolve, reject) => {
            opts = opts ? opts : {};
            opts['bp_partner'] = this.appProvider.info.name;
            opts['bp_partner_version'] = this.appProvider.info.version;
            // Token wallet?
            if (opts.pairedWallet) {
                return resolve();
            }
            const walletClient = this.bwcProvider.getClient(null, opts);
            const network = opts.networkName || 'livenet';
            const Key = this.bwcProvider.getKey();
            let key;
            if (opts.mnemonic) {
                try {
                    opts.mnemonic = this.normalizeMnemonic(opts.mnemonic);
                    key = Key.fromMnemonic(opts.mnemonic, {
                        useLegacyCoinType: opts.useLegacyCoinType,
                        useLegacyPurpose: opts.useLegacyPurpose,
                        passphrase: opts.passphrase
                    });
                    walletClient.fromString(key.createCredentials(opts.password, {
                        coin: opts.coin,
                        network,
                        account: opts.account || 0,
                        addressType: opts.addressType,
                        n: opts.n || 1
                    }));
                }
                catch (ex) {
                    this.logger.info('Invalid wallet recovery phrase: ', ex);
                    return reject(this.translate.instant('Could not create: Invalid wallet recovery phrase'));
                }
            }
            else if (opts.extendedPrivateKey) {
                try {
                    key = Key.fromExtendedPrivateKey(opts.extendedPrivateKey, {
                        useLegacyCoinType: opts.useLegacyCoinType,
                        useLegacyPurpose: opts.useLegacyPurpose
                    });
                    walletClient.fromString(key.createCredentials(null, {
                        coin: opts.coin,
                        network,
                        account: opts.account || 0,
                        n: opts.n || 1
                    }));
                }
                catch (ex) {
                    this.logger.warn('Could not get seed from Extended Private Key: ', ex);
                    return reject(this.translate.instant('Could not create using the specified extended private key'));
                }
            }
            else {
                const lang = this.languageProvider.getCurrent();
                try {
                    if (!opts.keyId) {
                        key = Key.create({
                            lang
                        });
                    }
                    else {
                        key = this.keyProvider.getKey(opts.keyId);
                    }
                    walletClient.fromString(key.createCredentials(opts.password, {
                        coin: opts.coin,
                        network,
                        account: opts.account || 0,
                        n: opts.n || 1
                    }));
                }
                catch (e) {
                    this.logger.info('Error creating recovery phrase: ' + e.message);
                    if (e.message.indexOf('language') > 0) {
                        this.logger.info('Using default language for recovery phrase');
                        key = Key.create({});
                        walletClient.fromString(key.createCredentials(opts.password, {
                            coin: opts.coin,
                            network,
                            account: opts.account || 0,
                            n: opts.n || 1
                        }));
                    }
                    else {
                        return reject(e);
                    }
                }
            }
            return resolve({ walletClient, key });
        });
    }
    // Creates a wallet on BWC/BWS and store it
    _createWallet(opts) {
        return new Promise((resolve, reject) => {
            const showOpts = __WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](opts);
            if (showOpts.extendedPrivateKey)
                showOpts.extendedPrivateKey = '[hidden]';
            if (showOpts.mnemonic)
                showOpts.mnemonic = '[hidden]';
            if (showOpts.password)
                showOpts.password = '[hidden]';
            this.logger.debug('Creating Wallet:', JSON.stringify(showOpts));
            setTimeout(() => {
                this.seedWallet(opts)
                    .then(data => {
                    const coin = `[${opts.coin.toUpperCase()}]`;
                    const name = opts.name ||
                        `${this.translate.instant('Personal Wallet')} ${coin}`;
                    const myName = opts.myName || this.translate.instant('me');
                    data.walletClient.createWallet(name, myName, opts.m, opts.n, {
                        network: opts.networkName,
                        singleAddress: opts.singleAddress,
                        walletPrivKey: opts.walletPrivKey,
                        coin: opts.coin
                    }, err => {
                        const copayerRegistered = err instanceof this.errors.COPAYER_REGISTERED;
                        const isSetSeed = opts.mnemonic || opts.extendedPrivateKey;
                        if (err && (!copayerRegistered || isSetSeed)) {
                            const msg = this.bwcErrorProvider.msg(err, this.translate.instant('Error creating wallet'));
                            return reject(msg);
                        }
                        else if (copayerRegistered) {
                            // try with account + 1
                            opts.account = opts.account ? opts.account + 1 : 1;
                            if (opts.account === 20)
                                return reject(this.translate.instant('You reach the limit of twenty wallets from the same coin and network'));
                            return resolve(this._createWallet(opts));
                        }
                        else {
                            // Set default preferences.
                            const config = this.configProvider.get();
                            const prefs = {
                                email: config.emailNotifications.email,
                                language: this.languageProvider.getCurrent(),
                                unit: 'btc' // deprecated
                            };
                            data.walletClient.preferences = __WEBPACK_IMPORTED_MODULE_4_lodash__["assign"](prefs, data.walletClient.preferences);
                            return resolve(data);
                        }
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            }, 50);
        });
    }
    // joins and stores a wallet
    _joinWallet(opts) {
        return new Promise((resolve, reject) => {
            this.logger.info('Joining Wallet...');
            let walletData;
            try {
                walletData = this.bwcProvider.parseSecret(opts.secret);
                // check if exist
                if (__WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.profile.credentials, {
                    walletId: walletData.walletId
                })) {
                    return reject(this.translate.instant('Cannot join the same wallet more that once'));
                }
            }
            catch (ex) {
                this.logger.error(ex);
                return reject(this.translate.instant('Bad wallet invitation'));
            }
            opts.networkName = walletData.network;
            /* TODO: opts.n is just used to determinate if the wallet is multisig (m/48'/xx) or single sig (m/44')
              we should change the name to 'isMultisig'
             */
            opts.n = 2;
            this.logger.debug('Joining Wallet:', opts);
            this.seedWallet(opts)
                .then(data => {
                data.walletClient.joinWallet(opts.secret, opts.myName || 'me', {
                    coin: opts.coin
                }, err => {
                    if (err) {
                        if (err instanceof this.errors.COPAYER_REGISTERED) {
                            // try with account + 1
                            opts.account = opts.account ? opts.account + 1 : 1;
                            if (opts.account === 20)
                                return reject(this.translate.instant('You reach the limit of twenty wallets from the same coin and network'));
                            return resolve(this._joinWallet(opts));
                        }
                        else {
                            const msg = this.bwcErrorProvider.msg(err, this.translate.instant('Could not join wallet'));
                            return reject(msg);
                        }
                    }
                    return resolve(data);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getWallet(walletId) {
        return this.wallet[walletId];
    }
    getWalletGroup(keyId) {
        keyId = keyId ? keyId : 'read-only';
        return this.walletsGroups[keyId];
    }
    deleteWalletClient(wallet) {
        this.logger.info('Deleting Wallet:', wallet.credentials.walletName);
        const walletId = wallet.credentials.walletId;
        wallet.removeAllListeners();
        this.profile.deleteWallet(walletId);
        delete this.wallet[walletId];
        this.persistenceProvider.removeAllWalletData(walletId);
        this.events.publish('Local/WalletListChange');
        return this.storeProfileIfDirty();
    }
    deleteWalletGroup(keyId, wallets) {
        let promises = [];
        wallets.forEach(wallet => {
            promises.push(this.deleteWalletClient(wallet));
        });
        return Promise.all(promises).then(() => {
            this.persistenceProvider.removeAllWalletGroupData(keyId);
            return Promise.resolve();
        });
    }
    getDefaultWalletOpts(coin) {
        const defaults = this.configProvider.getDefaults();
        return {
            name: this.currencyProvider.getCoinName(coin),
            m: 1,
            n: 1,
            myName: null,
            networkName: 'livenet',
            bwsurl: defaults.bws.url,
            singleAddress: this.currencyProvider.isSingleAddress(coin) || false,
            coin
        };
    }
    _createTokenWallet(ethWallet, tokenObj) {
        this.logger.debug(`Creating token wallet ${tokenObj.name} for ${ethWallet.id}:`);
        const tokenCredentials = ethWallet.credentials.getTokenCredentials(tokenObj);
        const walletClient = this.bwcProvider.getClient(null, {
            baseUrl: ethWallet.baseUrl,
            bp_partner: ethWallet.bp_partner,
            bp_partner_version: ethWallet.bp_partner_version
        });
        walletClient.fromObj(tokenCredentials);
        // Add the token info to the ethWallet.
        ethWallet.preferences = ethWallet.preferences || {};
        ethWallet.preferences.tokenAddresses =
            ethWallet.preferences.tokenAddresses || [];
        ethWallet.preferences.tokenAddresses.push(tokenObj.address);
        return walletClient;
    }
    createTokenWallet(ethWallet, token) {
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isString"](token)) {
            let tokens = this.currencyProvider.getAvailableTokens();
            token = tokens.find(x => x.symbol == token);
        }
        const tokenWalletClient = this._createTokenWallet(ethWallet, token);
        return this.addAndBindWalletClient(tokenWalletClient);
    }
    createMultipleWallets(coins, tokens = []) {
        return new Promise((resolve, reject) => {
            if (tokens && tokens.length && coins.indexOf('eth') < 0) {
                reject('No ethereum wallets for tokens');
            }
            const defaultOpts = this.getDefaultWalletOpts(coins[0]);
            this._createWallet(defaultOpts).then(data => {
                const key = data.key;
                const firstWalletData = data;
                this.keyProvider.addKey(key).then(() => {
                    const create2ndWallets = [];
                    coins.slice(1).forEach(coin => {
                        const newOpts = {};
                        Object.assign(newOpts, this.getDefaultWalletOpts(coin));
                        newOpts['keyId'] = key.id; // Add Key
                        create2ndWallets.push(this._createWallet(newOpts));
                    });
                    Promise.all(create2ndWallets)
                        .then(datas => {
                        datas.unshift(firstWalletData);
                        let walletClients = __WEBPACK_IMPORTED_MODULE_4_lodash__["map"](datas, 'walletClient');
                        // Handle tokens
                        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](tokens)) {
                            const ethWalletClient = walletClients.find(wallet => wallet.credentials.coin === 'eth');
                            if (!ethWalletClient)
                                reject('no eth wallet for tokens');
                            let tokenObjs = this.currencyProvider.getAvailableTokens();
                            const tokenClients = tokens.map(token => {
                                token = tokenObjs.find(x => x.symbol == token);
                                return this._createTokenWallet(ethWalletClient, token);
                            });
                            walletClients = walletClients.concat(tokenClients);
                        }
                        this.addAndBindWalletClients({
                            key: firstWalletData.key,
                            walletClients
                        })
                            .then(() => {
                            return resolve(walletClients);
                        })
                            .catch(e => {
                            reject(e);
                        });
                    })
                        .catch(e => {
                        // Remove key
                        this.keyProvider.removeKey(key.id);
                        reject(e);
                    });
                });
            });
        });
    }
    createWallet(opts) {
        return this.keyProvider.handleEncryptedWallet(opts.keyId).then(password => {
            opts.password = password;
            return this._createWallet(opts).then(data => {
                // Encrypt wallet
                this.onGoingProcessProvider.pause();
                return this.askToEncryptKey(data.key).then(() => {
                    this.onGoingProcessProvider.resume();
                    return this.keyProvider.addKey(data.key).then(() => {
                        return this.addAndBindWalletClient(data.walletClient, {
                            bwsurl: opts.bwsurl
                        }).then(walletClient => {
                            return Promise.resolve(walletClient);
                        });
                    });
                });
            });
        });
    }
    joinWallet(opts) {
        return this.keyProvider.handleEncryptedWallet(opts.keyId).then(password => {
            opts.password = password;
            return this._joinWallet(opts).then(data => {
                // Encrypt wallet
                this.onGoingProcessProvider.pause();
                return this.askToEncryptKey(data.key).then(() => {
                    this.onGoingProcessProvider.resume();
                    return this.keyProvider.addKey(data.key).then(() => {
                        return this.addAndBindWalletClient(data.walletClient, {
                            bwsurl: opts.bwsurl
                        }).then(walletClient => {
                            return Promise.resolve(walletClient);
                        });
                    });
                });
            });
        });
    }
    setDisclaimerAccepted() {
        this.profile.acceptDisclaimer();
        return this.storeProfileIfDirty();
    }
    setLastKnownBalance() {
        // Add cached balance async
        __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](__WEBPACK_IMPORTED_MODULE_4_lodash__["values"](this.wallet), x => {
            this.persistenceProvider.getLastKnownBalance(x.id).then(datum => {
                // this.logger.debug("Last known balance for ",x.id,datum);
                datum = datum || {};
                let limit = Math.floor(Date.now() / 1000) - 2 * 60;
                let { balance = null, updatedOn = null } = datum;
                x.lastKnownBalance = balance;
                x.lastKnownBalanceUpdatedOn = updatedOn < limit ? updatedOn : null;
            });
        });
    }
    getWallets(opts) {
        const wallets = [];
        opts = opts || {};
        // workaround to get wallets in the correct order
        Object.keys(this.walletsGroups).forEach(keyId => {
            opts.keyId = keyId;
            wallets.push(this.getWalletsFromGroup(opts));
        });
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["flatten"](wallets);
    }
    getWalletsFromGroup(opts) {
        if (opts && !__WEBPACK_IMPORTED_MODULE_4_lodash__["isObject"](opts))
            throw new Error('bad argument');
        opts = opts || {};
        let ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["values"](this.wallet);
        if (opts.keyId === 'read-only') {
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, x => {
                return !x.credentials.keyId;
            });
        }
        else if (opts.keyId) {
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, x => {
                return x.credentials.keyId == opts.keyId;
            });
        }
        if (opts.coin) {
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, x => {
                return x.credentials.coin == opts.coin;
            });
        }
        if (opts.network) {
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, x => {
                return x.credentials.network == opts.network;
            });
        }
        if (opts.n) {
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, w => {
                return w.credentials.n == opts.n;
            });
        }
        if (opts.m) {
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, w => {
                return w.credentials.m == opts.m;
            });
        }
        if (opts.onlyComplete) {
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, w => {
                return w.isComplete();
            });
        }
        if (opts.minAmount) {
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, w => {
                // IF no cached Status => return true!
                if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](w.cachedStatus))
                    return true;
                return w.cachedStatus.availableBalanceSat > opts.minAmount;
            });
        }
        if (opts.hasFunds) {
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, w => {
                // IF no cached Status => return true!
                if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](w.cachedStatus))
                    return true;
                return w.cachedStatus.availableBalanceSat > 0;
            });
        }
        if (!opts.showHidden) {
            // remove hidden wallets
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, w => {
                return !w.hidden;
            });
        }
        if (opts.canAddNewAccount) {
            ret = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](ret, w => {
                return w.canAddNewAccount;
            });
        }
        if (opts.pairFor) {
            // grab walletIds from current wallet for this token (if any)
            const tokenWalletIds = ret
                .filter(wallet => wallet.coin === opts.pairFor.symbol.toLowerCase())
                .map(wallet => wallet.id);
            ret = ret.filter(wallet => !tokenWalletIds.includes(`${wallet.id}-${opts.pairFor.address}`) &&
                wallet.coin === 'eth');
        }
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["sortBy"](ret, 'order');
    }
    toggleHideBalanceFlag(walletId) {
        this.wallet[walletId].balanceHidden = !this.wallet[walletId].balanceHidden;
        this.persistenceProvider.setHideBalanceFlag(walletId, this.wallet[walletId].balanceHidden);
    }
    toggleHideWalletFlag(walletId) {
        this.wallet[walletId].hidden = !this.wallet[walletId].hidden;
        this.persistenceProvider.setHideWalletFlag(walletId, this.wallet[walletId].hidden);
    }
    getTxps(opts) {
        return new Promise((resolve, reject) => {
            const MAX = 100;
            opts = opts ? opts : {};
            const w = this.getWallets(opts);
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](w)) {
                return reject('No wallets available');
            }
            let txps = [];
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](w, x => {
                if (x.pendingTxps)
                    txps = txps.concat(x.pendingTxps);
            });
            const n = txps.length;
            txps = __WEBPACK_IMPORTED_MODULE_4_lodash__["sortBy"](txps, 'createdOn').reverse();
            txps = __WEBPACK_IMPORTED_MODULE_4_lodash__["compact"](__WEBPACK_IMPORTED_MODULE_4_lodash__["flatten"](txps)).slice(0, opts.limit || MAX);
            return resolve({ txps, n });
        });
    }
    isKeyInUse(keyId) {
        const keyIdIndex = this.profile.credentials.findIndex(c => {
            if (keyId === 'read-only') {
                return !c.keyId;
            }
            else {
                return c.keyId == keyId;
            }
        });
        return keyIdIndex >= 0;
    }
};
ProfileProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_12__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_15__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_17__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_11__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_20__replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_10__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_9__bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_18__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_8__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_14__language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_19__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_16__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_21__tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_7__action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_13__key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */]])
], ProfileProvider);

//# sourceMappingURL=profile.js.map

/***/ }),

/***/ 1503:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1505:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 16:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfigProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);






let ConfigProvider = class ConfigProvider {
    constructor(currencyProvider, logger, persistence) {
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.persistence = persistence;
        this.logger.debug('ConfigProvider initialized');
        this.configDefault = {
            // wallet limits
            limits: {
                totalCopayers: 6,
                mPlusN: 100
            },
            // wallet default config
            wallet: {
                requiredCopayers: 2,
                totalCopayers: 3,
                spendUnconfirmed: false,
                reconnectDelay: 5000,
                idleDurationMin: 4,
                settings: {
                    unitName: 'BTC',
                    unitToSatoshi: 100000000,
                    unitDecimals: 8,
                    unitCode: 'btc',
                    alternativeName: 'US Dollar',
                    alternativeIsoCode: 'USD',
                    defaultLanguage: '',
                    feeLevel: 'normal'
                }
            },
            // Bitcore wallet service URL
            bws: {
                url: 'https://bws.bitpay.com/bws/api'
            },
            download: {
                bitpay: {
                    url: 'https://bitpay.com/wallet'
                },
                copay: {
                    url: 'https://copay.io/#download'
                }
            },
            rateApp: {
                bitpay: {
                    ios: 'https://itunes.apple.com/app/bitpay-secure-bitcoin-wallet/id1149581638',
                    android: 'https://play.google.com/store/apps/details?id=com.bitpay.wallet',
                    wp: ''
                },
                copay: {
                    ios: 'https://itunes.apple.com/app/copay-bitcoin-wallet/id951330296',
                    android: 'https://play.google.com/store/apps/details?id=com.bitpay.copay',
                    wp: ''
                }
            },
            lock: {
                method: null,
                value: null,
                bannedUntil: null
            },
            // External services
            showIntegration: {
                coinbase: false,
                debitcard: true,
                amazon: true,
                mercadolibre: true,
                shapeshift: true,
                giftcards: true
            },
            pushNotificationsEnabled: true,
            desktopNotificationsEnabled: true,
            confirmedTxsNotifications: {
                enabled: true
            },
            productsUpdates: {
                enabled: true
            },
            offersAndPromotions: {
                enabled: true
            },
            emailNotifications: {
                enabled: false,
                email: ''
            },
            log: {
                weight: 3
            },
            blockExplorerUrl: this.currencyProvider.getBlockExplorerUrls(),
            allowMultiplePrimaryWallets: false
        };
    }
    load() {
        return new Promise((resolve, reject) => {
            this.persistence
                .getConfig()
                .then((config) => {
                if (!__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](config)) {
                    this.configCache = __WEBPACK_IMPORTED_MODULE_5_lodash__["clone"](config);
                    this.backwardCompatibility();
                }
                else {
                    this.configCache = __WEBPACK_IMPORTED_MODULE_5_lodash__["clone"](this.configDefault);
                }
                this.logImportantConfig(this.configCache);
                resolve();
            })
                .catch(err => {
                this.logger.error('Error Loading Config');
                reject(err);
            });
        });
    }
    logImportantConfig(config) {
        const spendUnconfirmed = config.wallet.spendUnconfirmed;
        const lockMethod = config && config.lock ? config.lock.method : null;
        this.logger.debug('Config | spendUnconfirmed: ' +
            spendUnconfirmed +
            ' - lockMethod: ' +
            lockMethod);
    }
    /**
     * @param newOpts object or string (JSON)
     */
    set(newOpts) {
        const config = __WEBPACK_IMPORTED_MODULE_5_lodash__["cloneDeep"](this.configDefault);
        if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isString"](newOpts)) {
            newOpts = JSON.parse(newOpts);
        }
        __WEBPACK_IMPORTED_MODULE_5_lodash__["merge"](config, this.configCache, newOpts);
        this.configCache = config;
        this.persistence.storeConfig(this.configCache).then(() => {
            this.logger.info('Config saved');
        });
    }
    get() {
        return this.configCache;
    }
    getDefaults() {
        return this.configDefault;
    }
    backwardCompatibility() {
        // these ifs are to avoid migration problems
        if (this.configCache.bws) {
            this.configCache.bws = this.configDefault.bws;
        }
        if (!this.configCache.wallet) {
            this.configCache.wallet = this.configDefault.wallet;
        }
        if (!this.configCache.wallet.settings.unitCode) {
            this.configCache.wallet.settings.unitCode = this.configDefault.wallet.settings.unitCode;
        }
        if (!this.configCache.showIntegration) {
            this.configCache.showIntegration = this.configDefault.showIntegration;
        }
        else {
            if (this.configCache.showIntegration.giftcards !== false) {
                this.configCache.showIntegration.giftcards = this.configDefault.showIntegration.giftcards;
            }
        }
        if (!this.configCache.pushNotificationsEnabled) {
            this.configCache.pushNotificationsEnabled = this.configDefault.pushNotificationsEnabled;
        }
        if (!this.configCache.desktopNotificationsEnabled) {
            this.configCache.desktopNotificationsEnabled = this.configDefault.desktopNotificationsEnabled;
        }
        if (!this.configCache.emailNotifications) {
            this.configCache.emailNotifications = this.configDefault.emailNotifications;
        }
        if (!this.configCache.lock) {
            this.configCache.lock = this.configDefault.lock;
        }
        if (!this.configCache.confirmedTxsNotifications) {
            this.configCache.confirmedTxsNotifications = this.configDefault.confirmedTxsNotifications;
        }
        if (this.configCache.wallet.settings.unitCode == 'bit') {
            // Convert to BTC. Bits will be disabled
            this.configCache.wallet.settings.unitName = this.configDefault.wallet.settings.unitName;
            this.configCache.wallet.settings.unitToSatoshi = this.configDefault.wallet.settings.unitToSatoshi;
            this.configCache.wallet.settings.unitDecimals = this.configDefault.wallet.settings.unitDecimals;
            this.configCache.wallet.settings.unitCode = this.configDefault.wallet.settings.unitCode;
        }
    }
};
ConfigProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__persistence_persistence__["b" /* PersistenceProvider */]])
], ConfigProvider);

//# sourceMappingURL=config.js.map

/***/ }),

/***/ 1670:
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 1670;

/***/ }),

/***/ 169:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DerivationPathHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let DerivationPathHelperProvider = class DerivationPathHelperProvider {
    constructor() {
        this.defaultBTC = "m/44'/0'/0'";
        this.defaultBCH = "m/44'/145'/0'";
        this.defaultETH = "m/44'/60'/0'";
        this.defaultMultisigBTC = "m/48'/0'/0'";
        this.defaultMultisigBCH = "m/48'/145'/0'";
        this.defaultTestnet = "m/44'/1'/0'";
    }
    parsePath(path) {
        return {
            purpose: path.split('/')[1],
            coinCode: path.split('/')[2],
            account: path.split('/')[3]
        };
    }
    getDerivationStrategy(path) {
        const purpose = this.parsePath(path).purpose;
        let derivationStrategy;
        switch (purpose) {
            case "44'":
                derivationStrategy = 'BIP44';
                break;
            case "45'":
                derivationStrategy = 'BIP45';
                break;
            case "48'":
                derivationStrategy = 'BIP48';
                break;
        }
        return derivationStrategy;
    }
    getNetworkName(path) {
        // BIP45
        const purpose = this.parsePath(path).purpose;
        if (purpose == "45'")
            return 'livenet';
        const coinCode = this.parsePath(path).coinCode;
        let networkName;
        switch (coinCode) {
            case "0'":// for BTC
                networkName = 'livenet';
                break;
            case "1'":// testnet for all coins
                networkName = 'testnet';
                break;
            case "145'":// for BCH
                networkName = 'livenet';
                break;
            case "60'":// for ETH
                networkName = 'livenet';
                break;
        }
        return networkName;
    }
    getAccount(path) {
        // BIP45
        const purpose = this.parsePath(path).purpose;
        if (purpose == "45'")
            return 0;
        const account = this.parsePath(path).account || '';
        const match = account.match(/(\d+)'/);
        if (!match)
            return undefined;
        return +match[1];
    }
    isValidDerivationPathCoin(path, coin) {
        let isValid;
        const coinCode = this.parsePath(path).coinCode;
        // BIP45
        if (path == "m/45'")
            return true;
        switch (coin) {
            case 'btc':
                isValid = ["0'", "1'"].indexOf(coinCode) > -1;
                break;
            case 'bch':
                isValid = ["145'", "0'", "1'"].indexOf(coinCode) > -1;
                break;
            case 'eth':
                isValid = ["60'", "0'", "1'"].indexOf(coinCode) > -1;
                break;
        }
        return isValid;
    }
};
DerivationPathHelperProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [])
], DerivationPathHelperProvider);

//# sourceMappingURL=derivation-path-helper.js.map

/***/ }),

/***/ 170:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IncomingDataProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__paypro_paypro__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__profile_profile__ = __webpack_require__(15);





// providers







let IncomingDataProvider = class IncomingDataProvider {
    constructor(actionSheetProvider, events, bwcProvider, currencyProvider, payproProvider, logger, appProvider, translate, profileProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.events = events;
        this.bwcProvider = bwcProvider;
        this.currencyProvider = currencyProvider;
        this.payproProvider = payproProvider;
        this.logger = logger;
        this.appProvider = appProvider;
        this.translate = translate;
        this.profileProvider = profileProvider;
        this.logger.debug('IncomingDataProvider initialized');
    }
    showMenu(data) {
        const dataMenu = this.actionSheetProvider.createIncomingDataMenu({ data });
        dataMenu.present();
        dataMenu.onDidDismiss(data => this.finishIncomingData(data));
    }
    finishIncomingData(data) {
        let redirTo = null;
        let value = null;
        if (data) {
            redirTo = data.redirTo;
            value = data.value;
        }
        if (redirTo === 'AmountPage') {
            let coin = data.coin ? data.coin : 'btc';
            this.events.publish('finishIncomingDataMenuEvent', {
                redirTo,
                value,
                coin
            });
        }
        else if (redirTo === 'PaperWalletPage') {
            const nextView = {
                name: 'PaperWalletPage',
                params: { privateKey: value }
            };
            this.events.publish('IncomingDataRedir', nextView);
        }
        else {
            this.events.publish('finishIncomingDataMenuEvent', { redirTo, value });
        }
    }
    isValidPayProNonBackwardsCompatible(data) {
        data = this.sanitizeUri(data);
        return !!/^(bitcoin|bitcoincash|bchtest|ethereum)?:\?r=[\w+]/.exec(data);
    }
    isValidBitPayInvoice(data) {
        return !!/^https:\/\/(www.)?(test.)?bitpay.com\/i\/\w+/.exec(data);
    }
    isValidBitcoinUri(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider.getBitcore().URI.isValid(data);
    }
    isValidBitcoinCashUri(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider.getBitcoreCash().URI.isValid(data);
    }
    isValidEthereumUri(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider.getCore().Validation.validateUri('ETH', data);
    }
    isValidBitcoinCashUriWithLegacyAddress(data) {
        data = this.sanitizeUri(data);
        return !!this.bwcProvider
            .getBitcore()
            .URI.isValid(data.replace(/^(bitcoincash:|bchtest:)/, 'bitcoin:'));
    }
    isValidPlainUrl(data) {
        if (this.isValidBitPayInvoice(data)) {
            return false;
        }
        data = this.sanitizeUri(data);
        return !!/^https?:\/\//.test(data);
    }
    isValidBitcoinAddress(data) {
        return !!(this.bwcProvider.getBitcore().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcore().Address.isValid(data, 'testnet'));
    }
    isValidBitcoinCashLegacyAddress(data) {
        return !!(this.bwcProvider.getBitcore().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcore().Address.isValid(data, 'testnet'));
    }
    isValidBitcoinCashAddress(data) {
        return !!(this.bwcProvider.getBitcoreCash().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcoreCash().Address.isValid(data, 'testnet'));
    }
    isValidEthereumAddress(data) {
        return !!this.bwcProvider
            .getCore()
            .Validation.validateAddress('ETH', 'livenet', data);
    }
    isValidCoinbaseUri(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.indexOf(this.appProvider.info.name + '://coinbase') === 0);
    }
    isValidShapeshiftUri(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.indexOf(this.appProvider.info.name + '://shapeshift') === 0);
    }
    isValidBitPayCardUri(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.indexOf('bitpay://bitpay') === 0);
    }
    isValidJoinCode(data) {
        data = this.sanitizeUri(data);
        return !!(data && data.match(/^copay:[0-9A-HJ-NP-Za-km-z]{70,80}$/));
    }
    isValidJoinLegacyCode(data) {
        return !!(data && data.match(/^[0-9A-HJ-NP-Za-km-z]{70,80}$/));
    }
    isValidPrivateKey(data) {
        return !!(data &&
            (data.substring(0, 2) == '6P' || this.checkPrivateKey(data)));
    }
    isValidImportPrivateKey(data) {
        return !!(data &&
            (data.substring(0, 2) == '1|' ||
                data.substring(0, 2) == '2|' ||
                data.substring(0, 2) == '3|'));
    }
    handlePrivateKey(data, redirParams) {
        this.logger.debug('Incoming-data: private key');
        this.showMenu({
            data,
            type: 'privateKey',
            fromHomeCard: redirParams ? redirParams.fromHomeCard : false
        });
    }
    handlePayProNonBackwardsCompatible(data) {
        this.logger.debug('Incoming-data: Payment Protocol with non-backwards-compatible request');
        const url = this.getPayProUrl(data);
        this.handleBitPayInvoice(url);
    }
    handleBitPayInvoice(invoiceUrl) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.logger.debug('Incoming-data: Handling bitpay invoice');
            try {
                const disableLoader = true;
                const details = yield this.payproProvider.getPayProOptions(invoiceUrl, disableLoader);
                const selected = details.paymentOptions.filter(option => option.selected);
                if (selected.length === 1) {
                    // BTC, BCH, ETH Chains
                    const [{ currency }] = selected;
                    this.goToPayPro(invoiceUrl, currency.toLowerCase(), disableLoader);
                }
                else {
                    // If ERC20
                    if (selected.length > 1) {
                        details.paymentOptions = selected;
                    }
                    // No currencies selected
                    const stateParams = {
                        payProOptions: details
                    };
                    let nextView = {
                        name: 'SelectInvoicePage',
                        params: stateParams
                    };
                    this.events.publish('IncomingDataRedir', nextView);
                }
            }
            catch (err) {
                this.events.publish('incomingDataError', err);
                this.logger.error(err);
            }
        });
    }
    handleBitcoinUri(data, redirParams) {
        this.logger.debug('Incoming-data: Bitcoin URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const coin = __WEBPACK_IMPORTED_MODULE_8__currency_currency__["a" /* Coin */].BTC;
        let parsed = this.bwcProvider.getBitcore().URI(data);
        let address = parsed.address ? parsed.address.toString() : '';
        let message = parsed.message;
        let amount = parsed.amount || amountFromRedirParams;
        if (parsed.r)
            this.goToPayPro(data, coin);
        else
            this.goSend(address, amount, message, coin);
    }
    handleBitcoinCashUri(data, redirParams) {
        this.logger.debug('Incoming-data: Bitcoin Cash URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const coin = __WEBPACK_IMPORTED_MODULE_8__currency_currency__["a" /* Coin */].BCH;
        let parsed = this.bwcProvider.getBitcoreCash().URI(data);
        let address = parsed.address ? parsed.address.toString() : '';
        // keep address in original format
        if (parsed.address && data.indexOf(address) < 0) {
            address = parsed.address.toCashAddress();
        }
        let message = parsed.message;
        let amount = parsed.amount || amountFromRedirParams;
        if (parsed.r)
            this.goToPayPro(data, coin);
        else
            this.goSend(address, amount, message, coin);
    }
    handleEthereumUri(data, redirParams) {
        this.logger.debug('Incoming-data: Ethereum URI');
        let amountFromRedirParams = redirParams && redirParams.amount ? redirParams.amount : '';
        const coin = __WEBPACK_IMPORTED_MODULE_8__currency_currency__["a" /* Coin */].ETH;
        const value = /[\?\&]value=(\d+([\,\.]\d+)?)/i;
        const gasPrice = /[\?\&]gasPrice=(\d+([\,\.]\d+)?)/i;
        let parsedAmount;
        let requiredFeeParam;
        if (value.exec(data)) {
            parsedAmount = value.exec(data)[1];
        }
        if (gasPrice.exec(data)) {
            requiredFeeParam = gasPrice.exec(data)[1];
        }
        const address = this.extractAddress(data);
        const message = '';
        const amount = parsedAmount || amountFromRedirParams;
        if (amount) {
            this.goSend(address, amount, message, coin, requiredFeeParam);
        }
        else {
            this.handleEthereumAddress(address, redirParams);
        }
    }
    handleBitcoinCashUriLegacyAddress(data) {
        this.logger.debug('Incoming-data: Bitcoin Cash URI with legacy address');
        const coin = __WEBPACK_IMPORTED_MODULE_8__currency_currency__["a" /* Coin */].BCH;
        let parsed = this.bwcProvider
            .getBitcore()
            .URI(data.replace(/^(bitcoincash:|bchtest:)/, 'bitcoin:'));
        let oldAddr = parsed.address ? parsed.address.toString() : '';
        if (!oldAddr)
            this.logger.error('Could not parse Bitcoin Cash legacy address');
        let a = this.bwcProvider
            .getBitcore()
            .Address(oldAddr)
            .toObject();
        let address = this.bwcProvider
            .getBitcoreCash()
            .Address.fromObject(a)
            .toString();
        let message = parsed.message;
        let amount = parsed.amount ? parsed.amount : '';
        // Translate address
        this.logger.warn('Legacy Bitcoin Address transalated to: ' + address);
        if (parsed.r)
            this.goToPayPro(data, coin);
        else
            this.goSend(address, amount, message, coin);
    }
    handlePlainUrl(data) {
        this.logger.debug('Incoming-data: Plain URL');
        data = this.sanitizeUri(data);
        this.showMenu({
            data,
            type: 'url'
        });
    }
    handlePlainBitcoinAddress(data, redirParams) {
        this.logger.debug('Incoming-data: Bitcoin plain address');
        const coin = __WEBPACK_IMPORTED_MODULE_8__currency_currency__["a" /* Coin */].BTC;
        if (redirParams && redirParams.activePage === 'ScanPage') {
            this.showMenu({
                data,
                type: 'bitcoinAddress',
                coin
            });
        }
        else if (redirParams && redirParams.amount) {
            this.goSend(data, redirParams.amount, '', coin);
        }
        else {
            this.goToAmountPage(data, coin);
        }
    }
    handlePlainBitcoinCashAddress(data, redirParams) {
        this.logger.debug('Incoming-data: Bitcoin Cash plain address');
        const coin = __WEBPACK_IMPORTED_MODULE_8__currency_currency__["a" /* Coin */].BCH;
        if (redirParams && redirParams.activePage === 'ScanPage') {
            this.showMenu({
                data,
                type: 'bitcoinAddress',
                coin
            });
        }
        else if (redirParams && redirParams.amount) {
            this.goSend(data, redirParams.amount, '', coin);
        }
        else {
            this.goToAmountPage(data, coin);
        }
    }
    handleEthereumAddress(data, redirParams) {
        this.logger.debug('Incoming-data: Ethereum address');
        const coin = __WEBPACK_IMPORTED_MODULE_8__currency_currency__["a" /* Coin */].ETH;
        if (redirParams && redirParams.activePage === 'ScanPage') {
            this.showMenu({
                data,
                type: 'ethereumAddress',
                coin
            });
        }
        else if (redirParams && redirParams.amount) {
            this.goSend(data, redirParams.amount, '', coin);
        }
        else {
            this.goToAmountPage(data, coin);
        }
    }
    goToImportByPrivateKey(data) {
        this.logger.debug('Incoming-data (redirect): QR code export feature');
        let stateParams = { code: data };
        let nextView = {
            name: 'ImportWalletPage',
            params: stateParams
        };
        this.events.publish('IncomingDataRedir', nextView);
    }
    goToJoinWallet(data) {
        this.logger.debug('Incoming-data (redirect): Code to join to a wallet');
        let nextView, stateParams;
        const opts = {
            showHidden: true,
            canAddNewAccount: true
        };
        const wallets = this.profileProvider.getWallets(opts);
        const nrKeys = __WEBPACK_IMPORTED_MODULE_4_lodash__["values"](__WEBPACK_IMPORTED_MODULE_4_lodash__["groupBy"](wallets, 'keyId')).length;
        if (nrKeys === 0) {
            stateParams = { url: data };
            nextView = {
                name: 'JoinWalletPage',
                params: stateParams
            };
        }
        else if (nrKeys != 1) {
            stateParams = { url: data, isJoin: true };
            nextView = {
                name: 'AddWalletPage',
                params: stateParams
            };
        }
        else if (nrKeys === 1) {
            stateParams = { keyId: wallets[0].credentials.keyId, url: data };
            nextView = {
                name: 'JoinWalletPage',
                params: stateParams
            };
        }
        if (this.isValidJoinCode(data) || this.isValidJoinLegacyCode(data)) {
            this.events.publish('IncomingDataRedir', nextView);
        }
        else {
            this.logger.error('Incoming-data: Invalid code to join to a wallet');
        }
    }
    goToBitPayCard(data) {
        this.logger.debug('Incoming-data (redirect): BitPay Card URL');
        // Disable BitPay Card
        if (!this.appProvider.info._enabledExtensions.debitcard) {
            this.logger.warn('BitPay Card has been disabled for this build');
            return;
        }
        let secret = this.getParameterByName('secret', data);
        let email = this.getParameterByName('email', data);
        let otp = this.getParameterByName('otp', data);
        let reason = this.getParameterByName('r', data);
        switch (reason) {
            default:
            case '0':
                /* For BitPay card binding */
                let stateParams = { secret, email, otp };
                let nextView = {
                    name: 'BitPayCardIntroPage',
                    params: stateParams
                };
                this.events.publish('IncomingDataRedir', nextView);
                break;
        }
    }
    goToCoinbase(data) {
        this.logger.debug('Incoming-data (redirect): Coinbase URL');
        let code = this.getParameterByName('code', data);
        let stateParams = { code };
        let nextView = {
            name: 'CoinbasePage',
            params: stateParams
        };
        this.events.publish('IncomingDataRedir', nextView);
    }
    goToShapeshift(data) {
        this.logger.debug('Incoming-data (redirect): ShapeShift URL');
        let code = this.getParameterByName('code', data);
        let stateParams = { code };
        let nextView = {
            name: 'ShapeshiftPage',
            params: stateParams
        };
        this.events.publish('IncomingDataRedir', nextView);
    }
    redir(data, redirParams) {
        //  Handling of a bitpay invoice url
        if (this.isValidBitPayInvoice(data)) {
            this.handleBitPayInvoice(data);
            return true;
            // Payment Protocol with non-backwards-compatible request
        }
        else if (this.isValidPayProNonBackwardsCompatible(data)) {
            this.handlePayProNonBackwardsCompatible(data);
            return true;
            // Bitcoin  URI
        }
        else if (this.isValidBitcoinUri(data)) {
            this.handleBitcoinUri(data, redirParams);
            return true;
            // Bitcoin Cash URI
        }
        else if (this.isValidBitcoinCashUri(data)) {
            this.handleBitcoinCashUri(data, redirParams);
            return true;
            // Ethereum URI
        }
        else if (this.isValidEthereumUri(data)) {
            this.handleEthereumUri(data, redirParams);
            return true;
            // Bitcoin Cash URI using Bitcoin Core legacy address
        }
        else if (this.isValidBitcoinCashUriWithLegacyAddress(data)) {
            this.handleBitcoinCashUriLegacyAddress(data);
            return true;
            // Plain URL
        }
        else if (this.isValidPlainUrl(data)) {
            this.handlePlainUrl(data);
            return true;
            // Plain Address (Bitcoin)
        }
        else if (this.isValidBitcoinAddress(data)) {
            this.handlePlainBitcoinAddress(data, redirParams);
            return true;
            // Plain Address (Bitcoin Cash)
        }
        else if (this.isValidBitcoinCashAddress(data)) {
            this.handlePlainBitcoinCashAddress(data, redirParams);
            return true;
            // Address (Ethereum)
        }
        else if (this.isValidEthereumAddress(data)) {
            this.handleEthereumAddress(data, redirParams);
            return true;
            // Coinbase
        }
        else if (this.isValidCoinbaseUri(data)) {
            this.goToCoinbase(data);
            return true;
            // ShapeShift
        }
        else if (this.isValidShapeshiftUri(data)) {
            this.goToShapeshift(data);
            return true;
            // BitPayCard Authentication
        }
        else if (this.isValidBitPayCardUri(data)) {
            this.goToBitPayCard(data);
            return true;
            // Join
        }
        else if (this.isValidJoinCode(data) || this.isValidJoinLegacyCode(data)) {
            this.goToJoinWallet(data);
            return true;
            // Check Private Key
        }
        else if (this.isValidPrivateKey(data)) {
            this.handlePrivateKey(data, redirParams);
            return true;
            // Import Private Key
        }
        else if (this.isValidImportPrivateKey(data)) {
            this.goToImportByPrivateKey(data);
            return true;
            // Anything else
        }
        else {
            if (redirParams && redirParams.activePage === 'ScanPage') {
                this.logger.debug('Incoming-data: Plain text');
                this.showMenu({
                    data,
                    type: 'text'
                });
                return true;
            }
            else {
                this.logger.warn('Incoming-data: Unknown information');
                return false;
            }
        }
    }
    parseData(data) {
        if (!data)
            return;
        if (this.isValidBitPayInvoice(data)) {
            return {
                data,
                type: 'InvoiceUri',
                title: this.translate.instant('Invoice URL')
            };
        }
        else if (this.isValidPayProNonBackwardsCompatible(data)) {
            return {
                data,
                type: 'PayPro',
                title: this.translate.instant('Payment URL')
            };
            // Bitcoin  URI
        }
        else if (this.isValidBitcoinUri(data)) {
            return {
                data,
                type: 'BitcoinUri',
                title: this.translate.instant('Bitcoin URI')
            };
            // Bitcoin Cash URI
        }
        else if (this.isValidBitcoinCashUri(data)) {
            return {
                data,
                type: 'BitcoinCashUri',
                title: this.translate.instant('Bitcoin Cash URI')
            };
            // Ethereum URI
        }
        else if (this.isValidEthereumUri(data)) {
            return {
                data,
                type: 'EthereumUri',
                title: this.translate.instant('Ethereum URI')
            };
            // Bitcoin Cash URI using Bitcoin Core legacy address
        }
        else if (this.isValidBitcoinCashUriWithLegacyAddress(data)) {
            return {
                data,
                type: 'BitcoinCashUri',
                title: this.translate.instant('Bitcoin Cash URI')
            };
            // Plain URL
        }
        else if (this.isValidPlainUrl(data)) {
            return {
                data,
                type: 'PlainUrl',
                title: this.translate.instant('Plain URL')
            };
            // Plain Address (Bitcoin)
        }
        else if (this.isValidBitcoinAddress(data)) {
            return {
                data,
                type: 'BitcoinAddress',
                title: this.translate.instant('Bitcoin Address')
            };
            // Plain Address (Bitcoin Cash)
        }
        else if (this.isValidBitcoinCashAddress(data)) {
            return {
                data,
                type: 'BitcoinCashAddress',
                title: this.translate.instant('Bitcoin Cash Address')
            };
            // Plain Address (Ethereum)
        }
        else if (this.isValidEthereumAddress(data)) {
            return {
                data,
                type: 'EthereumAddress',
                title: this.translate.instant('Ethereum Address')
            };
            // Coinbase
        }
        else if (this.isValidCoinbaseUri(data)) {
            return {
                data,
                type: 'Coinbase',
                title: 'Coinbase URI'
            };
            // BitPayCard Authentication
        }
        else if (this.isValidBitPayCardUri(data)) {
            return {
                data,
                type: 'BitPayCard',
                title: this.translate.instant('BitPay Card URI')
            };
            // Join
        }
        else if (this.isValidJoinCode(data) || this.isValidJoinLegacyCode(data)) {
            return {
                data,
                type: 'JoinWallet',
                title: this.translate.instant('Invitation Code')
            };
            // Check Private Key
        }
        else if (this.isValidPrivateKey(data)) {
            return {
                data,
                type: 'PrivateKey',
                title: this.translate.instant('Private Key')
            };
            // Import Private Key
        }
        else if (this.isValidImportPrivateKey(data)) {
            return {
                data,
                type: 'ImportPrivateKey',
                title: this.translate.instant('Import Words')
            };
            // Anything else
        }
        else {
            return;
        }
    }
    extractAddress(data) {
        const address = data.replace(/^[a-z]+:/i, '').replace(/\?.*/, '');
        const params = /([\?\&]+[a-z]+=(\d+([\,\.]\d+)?))+/i;
        return address.replace(params, '');
    }
    sanitizeUri(data) {
        // Fixes when a region uses comma to separate decimals
        let regex = /[\?\&]amount=(\d+([\,\.]\d+)?)/i;
        let match = regex.exec(data);
        if (!match || match.length === 0) {
            return data;
        }
        let value = match[0].replace(',', '.');
        let newUri = data.replace(regex, value);
        // mobile devices, uris like copay://xxx
        newUri.replace('://', ':');
        return newUri;
    }
    getPayProUrl(data) {
        return decodeURIComponent(data.replace(/(bitcoin|bitcoincash|ethereum)?:\?r=/, ''));
    }
    getParameterByName(name, url) {
        if (!url)
            return undefined;
        name = name.replace(/[\[\]]/g, '\\$&');
        let regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'), results = regex.exec(url);
        if (!results)
            return null;
        if (!results[2])
            return '';
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }
    checkPrivateKey(privateKey) {
        // Check if it is a Transaction id to prevent errors
        let isPK = this.checkRegex(privateKey);
        if (!isPK)
            return false;
        try {
            this.bwcProvider.getBitcore().PrivateKey(privateKey, 'livenet');
        }
        catch (err) {
            return false;
        }
        return true;
    }
    checkRegex(data) {
        let PKregex = new RegExp(/^[5KL][1-9A-HJ-NP-Za-km-z]{50,51}$/);
        return !!PKregex.exec(data);
    }
    goSend(addr, amount, message, coin, requiredFeeRate) {
        if (amount) {
            let stateParams = {
                amount,
                toAddress: addr,
                description: message,
                coin,
                requiredFeeRate
            };
            let nextView = {
                name: 'ConfirmPage',
                params: stateParams
            };
            this.events.publish('IncomingDataRedir', nextView);
        }
        else {
            let stateParams = {
                toAddress: addr,
                description: message,
                coin
            };
            let nextView = {
                name: 'AmountPage',
                params: stateParams
            };
            this.events.publish('IncomingDataRedir', nextView);
        }
    }
    goToAmountPage(toAddress, coin) {
        let stateParams = {
            toAddress,
            coin
        };
        let nextView = {
            name: 'AmountPage',
            params: stateParams
        };
        this.events.publish('IncomingDataRedir', nextView);
    }
    goToPayPro(url, coin, disableLoader) {
        this.payproProvider
            .getPayProDetails(url, coin, disableLoader)
            .then(details => {
            this.handlePayPro(details, url, coin);
        })
            .catch(err => {
            this.events.publish('incomingDataError', err);
            this.logger.error(err);
        });
    }
    handlePayPro(payProDetails, url, coin) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (!payProDetails) {
                this.logger.error('No wallets available');
                const error = this.translate.instant('No wallets available');
                this.events.publish('incomingDataError', error);
                return;
            }
            let requiredFeeRate;
            if (payProDetails.requiredFeeRate) {
                requiredFeeRate = !this.currencyProvider.isUtxoCoin(coin)
                    ? payProDetails.requiredFeeRate
                    : Math.ceil(payProDetails.requiredFeeRate * 1024);
            }
            try {
                const disableLoader = true;
                const { paymentOptions } = yield this.payproProvider.getPayProOptions(url, disableLoader);
                const { estimatedAmount } = paymentOptions.find(option => option.currency.toLowerCase() === coin);
                const stateParams = {
                    amount: estimatedAmount,
                    toAddress: payProDetails.instructions[0].toAddress,
                    description: payProDetails.memo,
                    data: payProDetails.instructions[0].data,
                    paypro: payProDetails,
                    coin,
                    network: payProDetails.network,
                    payProUrl: url,
                    requiredFeeRate
                };
                const nextView = {
                    name: 'ConfirmPage',
                    params: stateParams
                };
                this.events.publish('IncomingDataRedir', nextView);
            }
            catch (err) {
                this.events.publish('incomingDataError', err);
                this.logger.error(err);
            }
        });
    }
};
IncomingDataProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_7__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_8__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_10__paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_9__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_11__profile_profile__["a" /* ProfileProvider */]])
], IncomingDataProvider);

//# sourceMappingURL=incoming-data.js.map

/***/ }),

/***/ 171:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PayproProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__on_going_process_on_going_process__ = __webpack_require__(34);



// providers



let PayproProvider = class PayproProvider {
    constructor(logger, bwcProvider, currencyProvider, onGoingProcessProvider) {
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.currencyProvider = currencyProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger.debug('PayproProvider initialized');
    }
    getPayProOptions(paymentUrl, disableLoader) {
        const bwc = this.bwcProvider.getPayProV2();
        const options = {
            paymentUrl
        };
        if (!disableLoader) {
            this.onGoingProcessProvider.set('fetchingPayProOptions');
        }
        return bwc.getPaymentOptions(options).then(payProOptions => {
            if (!disableLoader)
                this.onGoingProcessProvider.clear();
            return payProOptions;
        });
    }
    getPayProDetails(paymentUrl, coin, disableLoader) {
        const bwc = this.bwcProvider.getPayProV2();
        const chain = this.currencyProvider.getChain(coin).toUpperCase();
        const options = {
            paymentUrl,
            chain,
            currency: coin.toUpperCase()
        };
        if (!disableLoader) {
            this.onGoingProcessProvider.set('fetchingPayPro');
        }
        return bwc.selectPaymentOption(options).then(payProDetails => {
            if (!disableLoader)
                this.onGoingProcessProvider.clear();
            return payProDetails;
        });
    }
};
PayproProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_4__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_5__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */]])
], PayproProvider);

//# sourceMappingURL=paypro.js.map

/***/ }),

/***/ 172:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__fee_fee__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__home_integrations_home_integrations__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_lodash__);





// providers







let CoinbaseProvider = class CoinbaseProvider {
    constructor(http, logger, persistenceProvider, platformProvider, homeIntegrationsProvider, configProvider, feeProvider, appProvider, events) {
        this.http = http;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.platformProvider = platformProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.configProvider = configProvider;
        this.feeProvider = feeProvider;
        this.appProvider = appProvider;
        this.events = events;
        this.init = __WEBPACK_IMPORTED_MODULE_11_lodash__["throttle"](cb => {
            if (__WEBPACK_IMPORTED_MODULE_11_lodash__["isEmpty"](this.credentials.CLIENT_ID)) {
                return cb('Coinbase is Disabled. Missing credentials.');
            }
            this.logger.debug('Trying to initialize Coinbase...');
            this.getStoredToken(accessToken => {
                if (!accessToken) {
                    this.logger.debug('Coinbase not linked');
                    return cb();
                }
                this.logger.debug('Coinbase already has Token.');
                this._getMainAccountId(accessToken, (err, accountId) => {
                    if (err) {
                        if (!err.errors)
                            return cb(err);
                        if (err.errors && !__WEBPACK_IMPORTED_MODULE_11_lodash__["isArray"](err.errors))
                            return cb(err);
                        let expiredToken;
                        for (let i = 0; i < err.errors.length; i++) {
                            if (err.errors[i].id == 'expired_token')
                                expiredToken = true;
                        }
                        if (expiredToken) {
                            this.logger.debug('Token Expired. Refresh and get new Token.');
                            this.persistenceProvider
                                .getCoinbaseRefreshToken(this.credentials.NETWORK)
                                .then(refreshToken => {
                                this._refreshToken(refreshToken, (err, newToken) => {
                                    if (err)
                                        return cb(err);
                                    this._getMainAccountId(newToken, (err, accountId) => {
                                        if (err)
                                            return cb(err);
                                        return cb(null, {
                                            accessToken: newToken,
                                            accountId
                                        });
                                    });
                                });
                            })
                                .catch(err => {
                                return cb(err);
                            });
                        }
                        else {
                            return cb(err);
                        }
                    }
                    else {
                        return cb(null, {
                            accessToken,
                            accountId
                        });
                    }
                });
            });
        }, 10000);
        this.updatePendingTransactions = __WEBPACK_IMPORTED_MODULE_11_lodash__["throttle"](() => {
            this.logger.debug('Updating coinbase pending transactions...');
            var pendingTransactions = {
                data: {}
            };
            this.getPendingTransactions(pendingTransactions);
        }, 20000);
        this.logger.debug('Coinbase initialized');
        this.credentials = {};
        this.isCordova = this.platformProvider.isCordova;
        this.priceSensitivity = [
            {
                value: 0.5,
                name: '0.5%'
            },
            {
                value: 1,
                name: '1%'
            },
            {
                value: 2,
                name: '2%'
            },
            {
                value: 5,
                name: '5%'
            },
            {
                value: 10,
                name: '10%'
            }
        ];
        this.selectedPriceSensitivity = this.priceSensitivity[1];
        this.events.subscribe('bwsEvent', (_, type, n) => {
            if (type == 'NewBlock' && n && n.data && n.data.network == 'livenet') {
                this.isActive(isActive => {
                    // Update Coinbase
                    if (isActive)
                        this.updatePendingTransactions();
                });
            }
        });
    }
    setCredentials() {
        if (!this.appProvider.servicesInfo ||
            !this.appProvider.servicesInfo.coinbase) {
            return;
        }
        var coinbase = this.appProvider.servicesInfo.coinbase;
        /*
         * Development: 'testnet'
         * Production: 'livenet'
         */
        this.credentials.NETWORK = 'livenet';
        // Coinbase permissions
        this.credentials.SCOPE =
            '' +
                'wallet:accounts:read,' +
                'wallet:addresses:read,' +
                'wallet:addresses:create,' +
                'wallet:user:read,' +
                'wallet:user:email,' +
                'wallet:buys:read,' +
                'wallet:buys:create,' +
                'wallet:sells:read,' +
                'wallet:sells:create,' +
                'wallet:transactions:read,' +
                'wallet:transactions:send,' +
                'wallet:transactions:send:bypass-2fa,' +
                'wallet:payment-methods:read';
        this.credentials.REDIRECT_URI = this.isCordova
            ? coinbase.redirect_uri.mobile
            : coinbase.redirect_uri.desktop;
        if (this.credentials.NETWORK == 'testnet') {
            this.credentials.HOST = coinbase.sandbox.host;
            this.credentials.API = coinbase.sandbox.api;
            this.credentials.CLIENT_ID = coinbase.sandbox.client_id;
            this.credentials.CLIENT_SECRET = coinbase.sandbox.client_secret;
        }
        else {
            this.credentials.HOST = coinbase.production.host;
            this.credentials.API = coinbase.production.api;
            this.credentials.CLIENT_ID = coinbase.production.client_id;
            this.credentials.CLIENT_SECRET = coinbase.production.client_secret;
        }
        // Force to use specific version
        this.credentials.API_VERSION = '2017-10-31';
    }
    _afterTokenReceived(data, cb) {
        if (data && data.access_token && data.refresh_token) {
            this.persistenceProvider.setCoinbaseToken(this.credentials.NETWORK, data.access_token);
            this.persistenceProvider.setCoinbaseRefreshToken(this.credentials.NETWORK, data.refresh_token);
            this.homeIntegrationsProvider.updateLink('coinbase', data.access_token); // Name, Token
            return cb(null, data.access_token);
        }
        else {
            return cb('Could not get the access token');
        }
    }
    getErrorsAsString(data) {
        let errData;
        try {
            if (data && data.errors)
                errData = data.errors;
            else if (data && data.error)
                errData = data.error_description;
            else
                return JSON.stringify(data);
            if (!__WEBPACK_IMPORTED_MODULE_11_lodash__["isArray"](errData)) {
                errData = errData && errData.message ? errData.message : errData;
                return errData;
            }
            if (__WEBPACK_IMPORTED_MODULE_11_lodash__["isArray"](errData)) {
                var errStr = '';
                for (var i = 0; i < errData.length; i++) {
                    errStr = errStr + errData[i].message + '. ';
                }
                return errStr;
            }
            return JSON.stringify(errData);
        }
        catch (e) {
            this.logger.error(e);
            return e;
        }
    }
    getNetwork() {
        return this.credentials.NETWORK;
    }
    getStoredToken(cb) {
        this.persistenceProvider
            .getCoinbaseToken(this.credentials.NETWORK)
            .then(accessToken => {
            if (!accessToken)
                return cb();
            return cb(accessToken);
        })
            .catch(_ => {
            return cb();
        });
    }
    getAvailableCurrency() {
        // Only "USD" (US bank account)
        return 'USD';
    }
    checkEnoughFundsForFee(amount, cb) {
        this._getNetAmount(amount, (err, reducedAmount) => {
            if (err)
                return cb(err);
            // Check if transaction has enough funds to transfer bitcoin from Coinbase to Copay
            if (reducedAmount < 0) {
                return cb('Not enough funds for fee');
            }
            return cb();
        });
    }
    getSignupUrl() {
        return this.credentials.HOST + '/signup';
    }
    getSupportUrl() {
        return 'https://support.coinbase.com/';
    }
    getOauthCodeUrl() {
        return (this.credentials.HOST +
            '/oauth/authorize?response_type=code&client_id=' +
            this.credentials.CLIENT_ID +
            '&redirect_uri=' +
            this.credentials.REDIRECT_URI +
            '&state=SECURE_RANDOM&scope=' +
            this.credentials.SCOPE +
            '&meta[send_limit_amount]=1000&meta[send_limit_currency]=USD&meta[send_limit_period]=day');
    }
    _getNetAmount(amount, cb) {
        // Fee Normal for a single transaction (450 bytes)
        var txNormalFeeKB = 450 / 1000;
        this.feeProvider
            .getFeeRate('btc', 'livenet', 'normal')
            .then(feePerKb => {
            var feeBTC = ((feePerKb * txNormalFeeKB) / 100000000).toFixed(8);
            return cb(null, amount - parseInt(feeBTC, 10), parseInt(feeBTC, 10));
        })
            .catch(() => {
            return cb('Could not get fee rate');
        });
    }
    getToken(code, cb) {
        let url = this.credentials.HOST + '/oauth/token';
        let data = {
            grant_type: 'authorization_code',
            code,
            client_id: this.credentials.CLIENT_ID,
            client_secret: this.credentials.CLIENT_SECRET,
            redirect_uri: this.credentials.REDIRECT_URI
        };
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json'
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: GET Access Token: SUCCESS');
            // Show pending task from the UI
            this._afterTokenReceived(data, cb);
        }, data => {
            this.logger.error('Coinbase: GET Access Token: ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    _refreshToken(refreshToken, cb) {
        let url = this.credentials.HOST + '/oauth/token';
        let data = {
            grant_type: 'refresh_token',
            client_id: this.credentials.CLIENT_ID,
            client_secret: this.credentials.CLIENT_SECRET,
            redirect_uri: this.credentials.REDIRECT_URI,
            refresh_token: refreshToken
        };
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json'
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Refresh Access Token SUCCESS');
            this._afterTokenReceived(data, cb);
        }, data => {
            this.logger.error('Coinbase: Refresh Access Token ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    _getMainAccountId(accessToken, cb) {
        this.getAccounts(accessToken, (err, a) => {
            if (err)
                return cb(err);
            var data = a.data;
            for (var i = 0; i < data.length; i++) {
                if (data[i].primary &&
                    data[i].type == 'wallet' &&
                    data[i].currency &&
                    data[i].currency.code == 'BTC') {
                    return cb(null, data[i].id);
                }
            }
            this.logout();
            return cb('Your primary account should be a BTC WALLET. Set your wallet account as primary and try again');
        });
    }
    getAccounts(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2' + '/accounts';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Get Accounts SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Get Accounts ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    logout() {
        this.persistenceProvider.removeCoinbaseToken(this.credentials.NETWORK);
        this.persistenceProvider.removeCoinbaseRefreshToken(this.credentials.NETWORK);
        this.persistenceProvider.removeCoinbaseTxs(this.credentials.NETWORK);
        this.homeIntegrationsProvider.updateLink('coinbase', null); // Name, Token
    }
    isActive(cb) {
        if (__WEBPACK_IMPORTED_MODULE_11_lodash__["isEmpty"](this.credentials.CLIENT_ID))
            return cb(false);
        this.persistenceProvider
            .getCoinbaseToken(this.credentials.NETWORK)
            .then(accessToken => {
            return cb(!!accessToken);
        });
    }
    getAccount(token, _, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2/accounts/';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Get Account SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Get Account ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getAuthorizationInformation(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2/user/auth';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Authorization Information SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Authorization Information ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getCurrentUser(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2/user';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Get Current User SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Get Current User ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getBuyOrder(token, accountId, buyId, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/buys/' + buyId;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Buy Info SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Buy Info ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getTransaction(token, accountId, transactionId, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API +
            '/v2/accounts/' +
            accountId +
            '/transactions/' +
            transactionId;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Transaction SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Transaction ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getAddressTransactions(token, accountId, addressId, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API +
            '/v2/accounts/' +
            accountId +
            '/addresses/' +
            addressId +
            '/transactions';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Address Transactions SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Address Transactions ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getTransactions(token, accountId, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/transactions';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Transactions SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Transactions ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    paginationTransactions(token, Url, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + Url;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Pagination Transactions SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Pagination Transactions ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    sellPrice(token, currency, cb) {
        let url = this.credentials.API + '/v2/prices/sell?currency=' + currency;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Sell Price SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Sell Price ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    buyPrice(token, currency, cb) {
        let url = this.credentials.API + '/v2/prices/buy?currency=' + currency;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Buy Price: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Buy Price ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getPaymentMethods(token, cb) {
        let url = this.credentials.API + '/v2/payment-methods';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Get Payment Methods SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Get Payment Methods ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getPaymentMethod(token, paymentMethodId, cb) {
        let url = this.credentials.API + '/v2/payment-methods/' + paymentMethodId;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Get Payment Method SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Get Payment Method ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    sellRequest(token, accountId, dataSrc, cb) {
        let data = {
            amount: dataSrc.amount,
            currency: dataSrc.currency,
            payment_method: dataSrc.payment_method || null,
            commit: dataSrc.commit || false,
            quote: dataSrc.quote || false
        };
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/sells';
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Sell Request SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Sell Request ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    sellCommit(token, accountId, sellId, cb) {
        let url = this.credentials.API +
            '/v2/accounts/' +
            accountId +
            '/sells/' +
            sellId +
            '/commit';
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, null, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Sell Commit SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Sell Commit ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    buyRequest(token, accountId, dataSrc, cb) {
        let data = {
            amount: dataSrc.amount,
            currency: dataSrc.currency,
            payment_method: dataSrc.payment_method || null,
            commit: dataSrc.commit || false,
            quote: dataSrc.quote || false
        };
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/buys';
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Buy Request SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Buy Request ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    buyCommit(token, accountId, buyId, cb) {
        let url = this.credentials.API +
            '/v2/accounts/' +
            accountId +
            '/buys/' +
            buyId +
            '/commit';
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, null, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Buy Commit SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Buy Commit ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    createAddress(token, accountId, dataSrc, cb) {
        let data = {
            name: dataSrc.name
        };
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/addresses';
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Create Address SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Create Address ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    sendTo(token, accountId, dataSrc, cb) {
        let data = {
            type: 'send',
            to: dataSrc.to,
            amount: dataSrc.amount,
            currency: dataSrc.currency,
            description: dataSrc.description
        };
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/transactions';
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Create Address SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Create Address ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    // Pending transactions
    savePendingTransaction(ctx, opts, cb) {
        this._savePendingTransaction(ctx, opts, cb);
    }
    _savePendingTransaction(ctx, opts, cb) {
        this.persistenceProvider
            .getCoinbaseTxs(this.credentials.NETWORK)
            .then(oldTxs => {
            if (__WEBPACK_IMPORTED_MODULE_11_lodash__["isString"](oldTxs)) {
                oldTxs = JSON.parse(oldTxs);
            }
            if (__WEBPACK_IMPORTED_MODULE_11_lodash__["isString"](ctx)) {
                ctx = JSON.parse(ctx);
            }
            var tx = oldTxs || {};
            tx[ctx.id] = ctx;
            if (opts && (opts.error || opts.status)) {
                tx[ctx.id] = __WEBPACK_IMPORTED_MODULE_11_lodash__["assign"](tx[ctx.id], opts);
            }
            if (opts && opts.remove) {
                delete tx[ctx.id];
            }
            tx = JSON.stringify(tx);
            this.persistenceProvider.setCoinbaseTxs(this.credentials.NETWORK, tx);
            return cb();
        });
    }
    getPendingTransactions(coinbasePendingTransactions) {
        this.persistenceProvider
            .getCoinbaseTxs(this.credentials.NETWORK)
            .then(txs => {
            txs = txs ? JSON.parse(txs) : {};
            coinbasePendingTransactions.data = __WEBPACK_IMPORTED_MODULE_11_lodash__["isEmpty"](txs) ? null : txs;
            this.init((err, data) => {
                if (err || __WEBPACK_IMPORTED_MODULE_11_lodash__["isEmpty"](data)) {
                    if (err)
                        this.logger.error(err);
                    return;
                }
                var accessToken = data.accessToken;
                var accountId = data.accountId;
                __WEBPACK_IMPORTED_MODULE_11_lodash__["forEach"](coinbasePendingTransactions.data, (dataFromStorage, txId) => {
                    if ((dataFromStorage.type == 'sell' &&
                        dataFromStorage.status == 'completed') ||
                        (dataFromStorage.type == 'buy' &&
                            dataFromStorage.status == 'completed') ||
                        dataFromStorage.status == 'error' ||
                        (dataFromStorage.type == 'send' &&
                            dataFromStorage.status == 'completed'))
                        return;
                    this.getTransaction(accessToken, accountId, txId, (err, tx) => {
                        if (err || __WEBPACK_IMPORTED_MODULE_11_lodash__["isEmpty"](tx) || (tx.data && tx.data.error)) {
                            this._savePendingTransaction(dataFromStorage, {
                                status: 'error',
                                error: tx.data && tx.data.error ? tx.data.error : err
                            }, err => {
                                if (err)
                                    this.logger.debug(err);
                                this._updateTxs(coinbasePendingTransactions);
                            });
                            return;
                        }
                        this._updateCoinbasePendingTransactions(dataFromStorage /* , tx.data */);
                        coinbasePendingTransactions.data[txId] = dataFromStorage;
                        if (tx.data.type == 'send' &&
                            tx.data.status == 'completed' &&
                            tx.data.from) {
                            this.sellPrice(accessToken, dataFromStorage.sell_price_currency, (err, s) => {
                                if (err) {
                                    this._savePendingTransaction(dataFromStorage, {
                                        status: 'error',
                                        error: err
                                    }, err => {
                                        if (err)
                                            this.logger.debug(err);
                                        this._updateTxs(coinbasePendingTransactions);
                                    });
                                    return;
                                }
                                var newSellPrice = s.data.amount;
                                var variance = Math.abs(((newSellPrice - dataFromStorage.sell_price_amount) /
                                    dataFromStorage.sell_price_amount) *
                                    100);
                                if (variance < dataFromStorage.price_sensitivity.value) {
                                    this._sellPending(dataFromStorage, accessToken, accountId, coinbasePendingTransactions);
                                }
                                else {
                                    this._savePendingTransaction(dataFromStorage, {
                                        status: 'error',
                                        error: {
                                            errors: [
                                                {
                                                    message: 'Price falls over the selected percentage'
                                                }
                                            ]
                                        }
                                    }, err => {
                                        if (err)
                                            this.logger.debug(err);
                                        this._updateTxs(coinbasePendingTransactions);
                                    });
                                }
                            });
                        }
                        else if (tx.data.type == 'buy' &&
                            tx.data.status == 'completed' &&
                            tx.data.buy) {
                            this._sendToWallet(dataFromStorage, accessToken, accountId, coinbasePendingTransactions);
                        }
                        else {
                            this._savePendingTransaction(dataFromStorage, {}, err => {
                                if (err)
                                    this.logger.debug(err);
                                this._updateTxs(coinbasePendingTransactions);
                            });
                        }
                    });
                });
            });
        });
    }
    _updateCoinbasePendingTransactions(obj /*, */) {
        for (var i = 1; i < arguments.length; i++) {
            for (var prop in arguments[i]) {
                var val = arguments[i][prop];
                if (typeof val == 'object')
                    this._updateCoinbasePendingTransactions(obj[prop] /* , val */);
                else
                    obj[prop] = val ? val : obj[prop];
            }
        }
        return obj;
    }
    _updateTxs(coinbasePendingTransactions) {
        this.persistenceProvider
            .getCoinbaseTxs(this.credentials.NETWORK)
            .then(txs => {
            txs = txs ? JSON.parse(txs) : {};
            coinbasePendingTransactions.data = __WEBPACK_IMPORTED_MODULE_11_lodash__["isEmpty"](txs) ? null : txs;
        });
    }
    _sellPending(tx, accessToken, accountId, coinbasePendingTransactions) {
        var data = tx.amount;
        data['payment_method'] = tx.payment_method || null;
        data['commit'] = true;
        this.sellRequest(accessToken, accountId, data, (err, res) => {
            if (err) {
                this._savePendingTransaction(tx, {
                    status: 'error',
                    error: err
                }, err => {
                    if (err)
                        this.logger.debug(err);
                    this._updateTxs(coinbasePendingTransactions);
                });
            }
            else {
                if (res.data && !res.data.transaction) {
                    this._savePendingTransaction(tx, {
                        status: 'error',
                        error: {
                            errors: [{ message: 'Sell order: transaction not found.' }]
                        }
                    }, err => {
                        if (err)
                            this.logger.debug(err);
                        this._updateTxs(coinbasePendingTransactions);
                    });
                    return;
                }
                this.getTransaction(accessToken, accountId, res.data.transaction.id, (err, updatedTx) => {
                    if (err) {
                        this._savePendingTransaction(tx, {
                            status: 'error',
                            error: err
                        }, err => {
                            if (err)
                                this.logger.error(err);
                            this._updateTxs(coinbasePendingTransactions);
                        });
                        return;
                    }
                    this._savePendingTransaction(tx, {
                        remove: true
                    }, () => {
                        this._savePendingTransaction(updatedTx.data, {}, err => {
                            if (err)
                                this.logger.debug(err);
                            this._updateTxs(coinbasePendingTransactions);
                        });
                    });
                });
            }
        });
    }
    _sendToWallet(tx, accessToken, accountId, coinbasePendingTransactions) {
        if (!tx)
            return;
        var desc = this.appProvider.info.nameCase + ' Wallet';
        this._getNetAmount(tx.amount.amount, (err, amountBTC, feeBTC) => {
            if (err) {
                this._savePendingTransaction(tx, {
                    status: 'error',
                    error: { errors: [{ message: err }] }
                }, err => {
                    if (err)
                        this.logger.debug(err);
                    this._updateTxs(coinbasePendingTransactions);
                });
                return;
            }
            var data = {
                to: tx.toAddr,
                amount: amountBTC,
                currency: tx.amount.currency,
                description: desc,
                fee: feeBTC
            };
            this.sendTo(accessToken, accountId, data, (err, res) => {
                if (err) {
                    this._savePendingTransaction(tx, {
                        status: 'error',
                        error: err
                    }, err => {
                        if (err)
                            this.logger.debug(err);
                        this._updateTxs(coinbasePendingTransactions);
                    });
                }
                else {
                    if (res.data && !res.data.id) {
                        this._savePendingTransaction(tx, {
                            status: 'error',
                            error: {
                                errors: [
                                    { message: 'Transactions not found in Coinbase.com' }
                                ]
                            }
                        }, err => {
                            if (err)
                                this.logger.debug(err);
                            this._updateTxs(coinbasePendingTransactions);
                        });
                        return;
                    }
                    this.getTransaction(accessToken, accountId, res.data.id, (err, sendTx) => {
                        if (err) {
                            this._savePendingTransaction(tx, {
                                status: 'error',
                                error: err
                            }, err => {
                                if (err)
                                    this.logger.error(err);
                                this._updateTxs(coinbasePendingTransactions);
                            });
                            return;
                        }
                        this._savePendingTransaction(tx, {
                            remove: true
                        }, err => {
                            if (err)
                                this.logger.error(err);
                            this._savePendingTransaction(sendTx.data, {}, err => {
                                if (err)
                                    this.logger.debug(err);
                                this._updateTxs(coinbasePendingTransactions);
                            });
                        });
                    });
                }
            });
        });
    }
    register() {
        this.isActive(isActive => {
            this.homeIntegrationsProvider.register({
                name: 'coinbase',
                title: 'Coinbase',
                icon: 'assets/img/coinbase/coinbase-icon.png',
                logo: 'assets/img/coinbase/coinbase-logo-white.svg',
                background: '#0667d0',
                location: '33 Countries',
                page: 'CoinbasePage',
                show: !!this.configProvider.get().showIntegration['coinbase'],
                linked: isActive
            });
        });
    }
};
CoinbaseProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_10__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_8__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_5__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */]])
], CoinbaseProvider);

//# sourceMappingURL=coinbase.js.map

/***/ }),

/***/ 173:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TouchIdErrors */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TouchIdProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_android_fingerprint_auth__ = __webpack_require__(849);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_touch_id__ = __webpack_require__(852);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__platform_platform__ = __webpack_require__(12);




// Providers




var TouchIdErrors;
(function (TouchIdErrors) {
    TouchIdErrors["fingerprintCancelled"] = "FINGERPRINT_CANCELLED";
})(TouchIdErrors || (TouchIdErrors = {}));
let TouchIdProvider = class TouchIdProvider {
    constructor(app, touchId, androidFingerprintAuth, platform, config, logger) {
        this.app = app;
        this.touchId = touchId;
        this.androidFingerprintAuth = androidFingerprintAuth;
        this.platform = platform;
        this.config = config;
        this.logger = logger;
    }
    isAvailable() {
        return new Promise(resolve => {
            if (this.platform.isCordova && this.platform.isAndroid) {
                this.checkAndroid().then(isAvailable => {
                    return resolve(isAvailable);
                });
            }
            else if (this.platform.isCordova && this.platform.isIOS) {
                this.checkIOS().then(isAvailable => {
                    return resolve(isAvailable);
                });
            }
            else {
                return resolve(false);
            }
        });
    }
    checkIOS() {
        return new Promise(resolve => {
            this.touchId.isAvailable().then(() => {
                return resolve(true);
            }, () => {
                this.logger.warn('(iOS) Biometric ID is not available');
                return resolve(false);
            });
        });
    }
    checkAndroid() {
        return new Promise(resolve => {
            this.androidFingerprintAuth
                .isAvailable()
                .then(res => {
                if (res.isAvailable)
                    return resolve(true);
                else {
                    this.logger.warn('Biometric ID is not available');
                    return resolve(false);
                }
            })
                .catch(() => {
                this.logger.warn('(Android) Biometric ID is not available for this device');
                return resolve(false);
            });
        });
    }
    verifyIOSFingerprint() {
        return this.touchId
            .verifyFingerprint('Request Biometric Authentication')
            .then(() => {
            this.logger.debug('Successfully authenticated');
        })
            .catch(err => {
            if (err && (err.code == -2 || err.code == -128))
                err.message = TouchIdErrors.fingerprintCancelled;
            throw err;
        });
    }
    verifyAndroidFingerprint() {
        return this.androidFingerprintAuth
            .encrypt({ clientId: this.app.info.nameCase })
            .then(result => {
            if (result.withFingerprint) {
                this.logger.debug('Successfully authenticated');
            }
            else if (result.withBackup) {
                this.logger.debug('Successfully authenticated with backup password!');
            }
            else
                this.logger.warn("Didn't authenticate!");
        })
            .catch(error => {
            const err = new Error(error);
            if (error === TouchIdErrors.fingerprintCancelled) {
                this.logger.debug('(Android) Biometric ID authentication cancelled');
                err.message = TouchIdErrors.fingerprintCancelled;
            }
            else {
                this.logger.warn('Could not get Biometric ID Authenticated', error);
            }
            throw err;
        });
    }
    check() {
        if (this.platform.isIOS)
            return this.verifyIOSFingerprint();
        if (this.platform.isAndroid)
            return this.verifyAndroidFingerprint();
        return undefined;
    }
    isNeeded(wallet) {
        let config = this.config.get();
        config.touchIdFor = config.touchIdFor || {};
        return config.touchIdFor[wallet.credentials.walletId];
    }
    checkWallet(wallet) {
        return this.isAvailable().then((isAvailable) => {
            if (!isAvailable)
                return undefined;
            if (this.isNeeded(wallet))
                return this.check();
            return undefined;
        });
    }
};
TouchIdProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_touch_id__["a" /* TouchID */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_android_fingerprint_auth__["a" /* AndroidFingerprintAuth */],
        __WEBPACK_IMPORTED_MODULE_7__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */]])
], TouchIdProvider);

//# sourceMappingURL=touchid.js.map

/***/ }),

/***/ 174:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__home_integrations_home_integrations__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__http_requests_http_requests__ = __webpack_require__(977);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__ = __webpack_require__(39);





// providers





let ShapeshiftProvider = class ShapeshiftProvider {
    constructor(appProvider, homeIntegrationsProvider, httpNative, logger, configProvider, persistenceProvider) {
        this.appProvider = appProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.httpNative = httpNative;
        this.logger = logger;
        this.configProvider = configProvider;
        this.persistenceProvider = persistenceProvider;
        this.init = __WEBPACK_IMPORTED_MODULE_3_lodash__["throttle"](cb => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.credentials.CLIENT_ID)) {
                return cb('ShapeShift is Disabled. Missing credentials.');
            }
            this.logger.debug('Trying to initialize ShapeShift...');
            this.getStoredToken(accessToken => {
                if (!accessToken) {
                    this.logger.debug('ShapeShift not linked');
                    return cb();
                }
                this.logger.debug('ShapeShift already has Token.');
                this.getAccessTokenDetails(accessToken, (err, data) => {
                    if (err) {
                        this.logout(accessToken);
                        return cb(err);
                    }
                    if (data.user.verificationStatus == 'NONE') {
                        return cb('unverified_account');
                    }
                    else {
                        return cb(null, {
                            accessToken
                        });
                    }
                });
            });
        }, 10000);
        this.logger.debug('ShapeshiftProvider Provider initialized');
        this.credentials = {};
    }
    setCredentials() {
        // (Mandatory) Affiliate PUBLIC KEY, for volume tracking, affiliate payments, split-shifts, etc.
        if (!this.appProvider.servicesInfo ||
            !this.appProvider.servicesInfo.shapeshift) {
            return;
        }
        const shapeshift = this.appProvider.servicesInfo.shapeshift;
        /*
         * Development: 'testnet'
         * Production: 'livenet'
         */
        this.credentials.NETWORK = 'livenet';
        this.credentials.API_URL =
            this.credentials.NETWORK === 'testnet'
                ? ''
                : // CORS: cors.shapeshift.io
                    'https://shapeshift.io';
        this.credentials.REDIRECT_URI = shapeshift.production.redirect_uri;
        this.credentials.HOST = shapeshift.production.host;
        this.credentials.API = shapeshift.production.api;
        this.credentials.CLIENT_ID = shapeshift.production.client_id;
        this.credentials.CLIENT_SECRET = shapeshift.production.client_secret;
        this.credentials.API_KEY = shapeshift.api_key || null;
    }
    getNetwork() {
        return this.credentials.NETWORK;
    }
    shift(data, cb) {
        const dataSrc = {
            withdrawal: data.withdrawal,
            pair: data.pair,
            returnAddress: data.returnAddress,
            apiKey: this.credentials.API_KEY
        };
        const url = this.credentials.API_URL + '/shift';
        const headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + data.token
        };
        this.httpNative.post(url, dataSrc, headers).subscribe(data => {
            this.logger.info('Shapeshift SHIFT: SUCCESS');
            return cb(null, data);
        }, data => {
            const error = this.parseError(data);
            this.logger.error('Shapeshift SHIFT ERROR: ' + error);
            return cb(error);
        });
    }
    sendamount(data, cb) {
        const dataSrc = {
            withdrawal: data.withdrawal,
            pair: data.pair,
            returnAddress: data.returnAddress,
            apiKey: this.credentials.API_KEY,
            depositAmount: data.depositAmount
        };
        const url = this.credentials.API_URL + '/sendamount';
        const headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + data.token
        };
        this.httpNative.post(url, dataSrc, headers).subscribe(data => {
            this.logger.info('Shapeshift SENDAMOUNT: SUCCESS');
            return cb(data.error, data.success);
        }, data => {
            const error = this.parseError(data);
            this.logger.error('Shapeshift SENDAMOUNT ERROR: ' + error);
            return cb(error);
        });
    }
    saveShapeshift(data, opts, cb) {
        const network = this.getNetwork();
        this.persistenceProvider
            .getShapeshift(network)
            .then(oldData => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](oldData)) {
                oldData = JSON.parse(oldData);
            }
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](data)) {
                data = JSON.parse(data);
            }
            let inv = oldData ? oldData : {};
            inv[data.address] = data;
            if (opts && (opts.error || opts.status)) {
                inv[data.address] = __WEBPACK_IMPORTED_MODULE_3_lodash__["assign"](inv[data.address], opts);
            }
            if (opts && opts.remove) {
                delete inv[data.address];
            }
            inv = JSON.stringify(inv);
            this.persistenceProvider.setShapeshift(network, inv);
            return cb(null);
        })
            .catch(err => {
            return cb(err);
        });
    }
    getShapeshift(cb) {
        const network = this.getNetwork();
        this.persistenceProvider
            .getShapeshift(network)
            .then(ss => {
            return cb(null, ss);
        })
            .catch(err => {
            return cb(err, null);
        });
    }
    getRate(pair, cb) {
        this.httpNative.get(this.credentials.API_URL + '/rate/' + pair).subscribe(data => {
            this.logger.info('Shapeshift PAIR: SUCCESS');
            return cb(null, data);
        }, data => {
            const error = this.parseError(data);
            this.logger.error('Shapeshift PAIR ERROR: ' + error);
            return cb(data);
        });
    }
    getLimit(pair, cb) {
        this.httpNative.get(this.credentials.API_URL + '/limit/' + pair).subscribe(data => {
            this.logger.info('Shapeshift LIMIT: SUCCESS');
            return cb(null, data);
        }, data => {
            const error = this.parseError(data);
            this.logger.error('Shapeshift LIMIT ERROR: ' + error);
            return cb(data);
        });
    }
    getMarketInfo(pair, cb) {
        this.httpNative
            .get(this.credentials.API_URL + '/marketinfo/' + pair)
            .subscribe(data => {
            this.logger.info('Shapeshift MARKET INFO: SUCCESS');
            return cb(null, data);
        }, data => {
            const error = this.parseError(data);
            this.logger.error('Shapeshift MARKET INFO ERROR: ', error);
            return cb(data);
        });
    }
    getStatus(addr, token, cb) {
        const headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        };
        this.httpNative
            .get(this.credentials.API_URL + '/txStat/' + addr, null, headers)
            .subscribe(data => {
            this.logger.info('Shapeshift STATUS: SUCCESS');
            return cb(null, data);
        }, data => {
            const error = this.parseError(data);
            this.logger.error('Shapeshift STATUS ERROR: ' + error);
            return cb(data.error);
        });
    }
    isActive(cb) {
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.credentials.CLIENT_ID))
            return cb(false);
        this.persistenceProvider
            .getShapeshiftToken(this.credentials.NETWORK)
            .then(accessToken => {
            return cb(!!accessToken);
        });
    }
    register() {
        this.isActive(isActive => {
            this.homeIntegrationsProvider.register({
                name: 'shapeshift',
                title: 'ShapeShift',
                icon: 'assets/img/shapeshift/icon-shapeshift.svg',
                logo: 'assets/img/shapeshift/logo-white-shapeshift.svg',
                background: 'linear-gradient(to bottom,rgba(13,23,44,1) 0,rgba(16,29,58,1) 100%)',
                page: 'ShapeshiftPage',
                show: !!this.configProvider.get().showIntegration['shapeshift'],
                linked: isActive
            });
        });
    }
    getOauthCodeUrl() {
        return (this.credentials.HOST +
            '/oauth/authorize?response_type=code&scope=users:read&client_id=' +
            this.credentials.CLIENT_ID +
            '&redirect_uri=' +
            this.credentials.REDIRECT_URI);
    }
    getSignupUrl() {
        return this.credentials.HOST + '/signup';
    }
    getStoredToken(cb) {
        this.persistenceProvider
            .getShapeshiftToken(this.credentials.NETWORK)
            .then(accessToken => {
            if (!accessToken)
                return cb();
            return cb(accessToken);
        })
            .catch(() => {
            return cb();
        });
    }
    getToken(code, cb) {
        const url = this.credentials.HOST + '/oauth/token';
        const data = {
            grant_type: 'authorization_code',
            code,
            client_id: this.credentials.CLIENT_ID,
            client_secret: this.credentials.CLIENT_SECRET,
            redirect_uri: this.credentials.REDIRECT_URI
        };
        const headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json'
        };
        this.httpNative.post(url, data, headers).subscribe(data => {
            this.logger.info('ShapeShift: GET Access Token: SUCCESS');
            // Show pending task from the UI
            this._afterTokenReceived(data, cb);
        }, data => {
            const error = this.parseError(data);
            this.logger.error('ShapeShift: GET Access Token: ERROR ' + data.status + '. ' + error);
            return cb(error);
        });
    }
    _afterTokenReceived(data, cb) {
        if (data && data.access_token) {
            this.persistenceProvider.setShapeshiftToken(this.credentials.NETWORK, data.access_token);
            this.homeIntegrationsProvider.updateLink('shapeshift', data.access_token); // Name, Token
            return cb(null, data.access_token);
        }
        else {
            return cb('Could not get the access token');
        }
    }
    getAccessTokenDetails(token, cb) {
        if (!token)
            return cb('Invalid Token');
        const url = this.credentials.HOST + '/oauth/token/details';
        const headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        };
        this.httpNative.get(url, null, headers).subscribe(data => {
            this.logger.info('ShapeShift: Get Access Token Details SUCCESS');
            return cb(null, data);
        }, data => {
            const error = this.parseError(data);
            this.logger.error('ShapeShift: Get Access Token Details ERROR ' +
                data.status +
                '. ' +
                error);
            return cb(data.error);
        });
    }
    getAccount(token, cb) {
        if (!token)
            return cb('Invalid Token');
        const url = this.credentials.HOST + '/api/v1/users/me';
        const headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        };
        this.httpNative.get(url, null, headers).subscribe(data => {
            this.logger.info('ShapeShift: Get Account SUCCESS');
            return cb(null, data);
        }, data => {
            const error = this.parseError(data);
            this.logger.error('ShapeShift: Get Account ERROR ' + data.status + '. ' + error);
            return cb(data.error);
        });
    }
    revokeAccessToken(token) {
        const url = this.credentials.HOST + '/oauth/token/revoke';
        const data = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["d" /* HttpParams */]().set('token', token);
        const headers = {
            'Content-Type': 'application/x-www-form-urlencoded',
            Authorization: 'Basic ' +
                btoa(this.credentials.CLIENT_ID + ':' + this.credentials.CLIENT_SECRET)
        };
        this.httpNative.post(url, data, headers).subscribe(() => {
            this.logger.info('ShapeShift: Revoke Access Token SUCCESS');
        }, data => {
            const error = this.parseError(data);
            this.logger.warn('ShapeShift: Revoke Access Token ERROR ' + data.status + '. ' + error);
        });
    }
    logout(token) {
        this.revokeAccessToken(token);
        this.persistenceProvider.removeShapeshiftToken(this.credentials.NETWORK);
        this.homeIntegrationsProvider.updateLink('shapeshift', null); // Name, Token
    }
    parseError(err) {
        if (!err)
            return 'Unknow Error';
        if (!err.error)
            return err.message ? err.message : 'Unknow Error';
        const parsedError = err.error.error_description
            ? err.error.error_description
            : err.error.error && err.error.error.message
                ? err.error.error.message
                : err.error;
        return parsedError;
    }
};
ShapeshiftProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_7__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_8__http_requests_http_requests__["a" /* HttpRequestsProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["b" /* PersistenceProvider */]])
], ShapeshiftProvider);

//# sourceMappingURL=shapeshift.js.map

/***/ }),

/***/ 175:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TabsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__home_home__ = __webpack_require__(982);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__scan_scan__ = __webpack_require__(247);




let TabsPage = class TabsPage {
    constructor() {
        this.homeRoot = __WEBPACK_IMPORTED_MODULE_2__home_home__["a" /* HomePage */];
        this.scanRoot = __WEBPACK_IMPORTED_MODULE_3__scan_scan__["a" /* ScanPage */];
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('tabs'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], TabsPage.prototype, "tabs", void 0);
TabsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/tabs/tabs.html"*/'<ion-tabs #tabs class="hide-tabbar">\n  <ion-tab [root]="homeRoot" tabTitle="{{\'Home\'|translate}}" tabIcon="tab-home"></ion-tab>\n  <ion-tab [root]="scanRoot" tabTitle="{{\'Scan\'|translate}}" tabIcon="tab-scan"></ion-tab>\n</ion-tabs>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/tabs/tabs.html"*/
    })
], TabsPage);

//# sourceMappingURL=tabs.js.map

/***/ }),

/***/ 176:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletTabsChild; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__wallet_tabs_provider__ = __webpack_require__(90);





let WalletTabsChild = class WalletTabsChild {
    constructor(navCtrl, profileProvider, walletTabsProvider) {
        this.navCtrl = navCtrl;
        this.profileProvider = profileProvider;
        this.walletTabsProvider = walletTabsProvider;
    }
    ngOnInit() {
        this.wallets = this.profileProvider.getWallets();
        this.wallet = this.getParentWallet();
    }
    close() {
        return this.getParentTabs().dismiss();
    }
    getParentTabs() {
        const navParent = this.navCtrl.parent;
        return navParent && navParent.viewCtrl;
    }
    getParentWallet() {
        const tabs = this.getParentTabs();
        const walletId = tabs && tabs.instance && tabs.instance.walletId;
        return this.profileProvider.getWallet(walletId);
    }
    isWithinWalletTabs() {
        const tabs = this.getParentTabs();
        const tabsInstance = tabs && tabs.instance;
        return tabsInstance && tabsInstance.walletTabs ? true : false;
    }
};
WalletTabsChild = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({ template: '' }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__wallet_tabs_provider__["a" /* WalletTabsProvider */]])
], WalletTabsChild);

//# sourceMappingURL=wallet-tabs-child.js.map

/***/ }),

/***/ 18:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PopupProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);





let PopupProvider = class PopupProvider {
    constructor(alertCtrl, logger, translate) {
        this.alertCtrl = alertCtrl;
        this.logger = logger;
        this.translate = translate;
    }
    ionicAlert(title, subTitle, okText) {
        return new Promise(resolve => {
            let alert = this.alertCtrl.create({
                title,
                subTitle,
                enableBackdropDismiss: false,
                buttons: [
                    {
                        text: okText ? okText : this.translate.instant('Ok'),
                        handler: () => {
                            this.logger.info('Ok clicked');
                            resolve();
                        }
                    }
                ]
            });
            alert.present();
        });
    }
    ionicConfirm(title, message, okText, cancelText) {
        return new Promise(resolve => {
            let confirm = this.alertCtrl.create({
                title,
                message,
                buttons: [
                    {
                        text: cancelText ? cancelText : this.translate.instant('Cancel'),
                        handler: () => {
                            this.logger.info('Disagree clicked');
                            resolve(false);
                        }
                    },
                    {
                        text: okText ? okText : this.translate.instant('Ok'),
                        handler: () => {
                            this.logger.info('Agree clicked');
                            resolve(true);
                        }
                    }
                ],
                enableBackdropDismiss: false
            });
            confirm.present();
        });
    }
    ionicPrompt(title, message, opts, okText, cancelText) {
        return new Promise(resolve => {
            let defaultText = opts && opts.defaultText ? opts.defaultText : null;
            let placeholder = opts && opts.placeholder ? opts.placeholder : null;
            let inputType = opts && opts.type ? opts.type : 'text';
            let cssClass = opts && opts.useDanger ? 'alertDanger' : null;
            let enableBackdropDismiss = !!(opts && opts.enableBackdropDismiss);
            let prompt = this.alertCtrl.create({
                title,
                message,
                cssClass,
                enableBackdropDismiss,
                inputs: [
                    {
                        value: defaultText,
                        placeholder,
                        type: inputType
                    }
                ],
                buttons: [
                    {
                        text: cancelText ? cancelText : this.translate.instant('Cancel'),
                        handler: () => {
                            this.logger.info('Cancel clicked');
                            resolve(null);
                        }
                    },
                    {
                        text: okText ? okText : this.translate.instant('Ok'),
                        handler: data => {
                            this.logger.info('Saved clicked');
                            resolve(data[0]);
                        }
                    }
                ]
            });
            prompt.present();
        });
    }
};
PopupProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["b" /* AlertController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], PopupProvider);

//# sourceMappingURL=popup.js.map

/***/ }),

/***/ 1815:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 195:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClipboardProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_clipboard__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_electron_electron__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__incoming_data_incoming_data__ = __webpack_require__(170);



// providers




let ClipboardProvider = class ClipboardProvider {
    constructor(platformProvider, logger, clipboard, electronProvider, incomingDataProvider) {
        this.platformProvider = platformProvider;
        this.logger = logger;
        this.clipboard = clipboard;
        this.electronProvider = electronProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.logger.debug('ClipboardProvider initialized');
        this.isCordova = this.platformProvider.isCordova;
        this.isElectron = this.platformProvider.isElectron;
    }
    getData() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (this.isCordova) {
                return this.clipboard.paste();
            }
            else if (this.isElectron) {
                return this.electronProvider.readFromClipboard();
            }
            else {
                return Promise.reject('Not supported for this device');
            }
        });
    }
    copy(value) {
        if (this.isCordova) {
            this.clipboard.copy(value);
        }
        else if (this.isElectron) {
            this.electronProvider.writeToClipboard(value);
        }
        else {
            throw new Error('Copied to Clipboard using a Web Browser.');
        }
    }
    clear() {
        if (this.isCordova) {
            this.clipboard.copy(null);
        }
        else if (this.isElectron) {
            this.electronProvider.clearClipboard();
        }
    }
    clearClipboardIfValidData(typeArray) {
        this.getData()
            .then(data => {
            const validDataFromClipboard = this.incomingDataProvider.parseData(data);
            if (validDataFromClipboard &&
                typeArray.indexOf(validDataFromClipboard.type) != -1) {
                this.logger.info('Cleaning clipboard data: done');
                this.clear(); // clear clipboard data if exist
            }
        })
            .catch(err => {
            this.logger.debug('Cleaning clipboard data: ', err);
        });
    }
};
ClipboardProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_clipboard__["a" /* Clipboard */],
        __WEBPACK_IMPORTED_MODULE_3__providers_electron_electron__["a" /* ElectronProvider */],
        __WEBPACK_IMPORTED_MODULE_6__incoming_data_incoming_data__["a" /* IncomingDataProvider */]])
], ClipboardProvider);

//# sourceMappingURL=clipboard.js.map

/***/ }),

/***/ 1954:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class Profile {
    constructor() {
        this.version = '2.0.0';
    }
    static create() {
        let x = new Profile();
        x.createdOn = Date.now();
        x.credentials = [];
        x.disclaimerAccepted = false;
        x.checked = {};
        return x;
    }
    static fromObj(obj) {
        if (!obj || typeof obj != 'object') {
            throw new Error('Wrong params at Profile.fromObj: ' + obj);
        }
        let x = new Profile();
        x.createdOn = obj.createdOn;
        x.credentials = obj.credentials || [];
        x.disclaimerAccepted = obj.disclaimerAccepted || false;
        x.checked = obj.checked || {};
        x.checkedUA = obj.checkedUA;
        if (x.credentials[0] && typeof x.credentials[0] != 'object')
            throw new Error('credentials should be an array of objects');
        return x;
    }
    hasWallet(walletId) {
        for (let i in this.credentials) {
            let c = this.credentials[i];
            if (c.walletId == walletId)
                return true;
        }
        return false;
    }
    isChecked(ua, walletId) {
        return !!(this.checkedUA == ua && this.checked[walletId]);
    }
    isDeviceChecked(ua) {
        return this.checkedUA == ua;
    }
    setChecked(ua, walletId) {
        if (this.checkedUA != ua) {
            this.checkedUA = ua;
            this.checked = {};
        }
        this.checked[walletId] = true;
        this.dirty = true;
    }
    addWallet(credentials) {
        if (!credentials.walletId)
            throw new Error('credentials must have .walletId');
        if (this.hasWallet(credentials.walletId))
            return false;
        this.credentials.push(credentials);
        this.dirty = true;
        return true;
    }
    updateWallet(credentials) {
        if (!credentials.walletId)
            throw new Error('credentials must have .walletId');
        if (!this.hasWallet(credentials.walletId))
            return false;
        this.credentials = this.credentials.map(c => {
            if (c.walletId != credentials.walletId) {
                return c;
            }
            else {
                return credentials;
            }
        });
        this.dirty = true;
        return true;
    }
    deleteWallet(walletId) {
        if (!this.hasWallet(walletId))
            return false;
        this.credentials = this.credentials.filter(c => {
            return c.walletId != walletId;
        });
        this.dirty = true;
        return true;
    }
    acceptDisclaimer() {
        this.disclaimerAccepted = true;
        this.dirty = true;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Profile;

//# sourceMappingURL=profile.model.js.map

/***/ }),

/***/ 1958:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = promiseSerial;
function promiseSerial(tasks) {
    return tasks.reduce((promise, currentTask) => promise.then(result => currentTask().then(Array.prototype.concat.bind(result))), Promise.resolve([]));
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 1977:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1978:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1980:
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 1980;

/***/ }),

/***/ 1984:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PriceProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers__ = __webpack_require__(35);







let PriceProvider = class PriceProvider {
    constructor(httpClient, logger, configProvider) {
        this.httpClient = httpClient;
        this.logger = logger;
        this.configProvider = configProvider;
        this.lastDates = 6;
        this.logger.debug('PriceProvider initialized');
        const defaults = this.configProvider.getDefaults();
        this.bwsURL = defaults.bws.url;
    }
    getHistoricalBitcoinPrice(isoCode, coin) {
        let observableBatch = [];
        this.historicalDates = [];
        this.setDates();
        __WEBPACK_IMPORTED_MODULE_3_lodash__["forEach"](this.historicalDates, date => {
            observableBatch.push(this.httpClient.get(`${this.bwsURL}/v1/fiatrates/${isoCode}?coin=${coin}&ts=${date}`));
        });
        return __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__["Observable"].forkJoin(observableBatch);
    }
    getCurrentBitcoinPrice(isoCode, coin) {
        return this.httpClient.get(`${this.bwsURL}/v1/fiatrates/${isoCode}?coin=${coin}`);
    }
    setDates() {
        for (let i = 0; i <= this.lastDates; i++) {
            if (i == 0) {
                this.historicalDates.push(__WEBPACK_IMPORTED_MODULE_4_moment__().unix() * 1000);
            }
            else {
                const today = __WEBPACK_IMPORTED_MODULE_4_moment__().set({
                    hour: 15,
                    minute: 0,
                    second: 0,
                    millisecond: 0
                });
                this.historicalDates.push(today.subtract(i, 'day').unix() * 1000);
            }
        }
    }
};
PriceProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["N" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["q" /* ConfigProvider */]])
], PriceProvider);

//# sourceMappingURL=price.js.map

/***/ }),

/***/ 1985:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClaimCodeType; });
var ClaimCodeType;
(function (ClaimCodeType) {
    ClaimCodeType["barcode"] = "barcode";
    ClaimCodeType["code"] = "code";
    ClaimCodeType["link"] = "link";
})(ClaimCodeType || (ClaimCodeType = {}));
//# sourceMappingURL=gift-card.types.js.map

/***/ }),

/***/ 1986:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CardListItemComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_gift_card_gift_card__ = __webpack_require__(86);



let CardListItemComponent = class CardListItemComponent {
    constructor(giftCardProvider) {
        this.giftCardProvider = giftCardProvider;
        this.type = 'catalog';
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.cardConfig = this.config
                ? this.config
                : yield this.giftCardProvider.getCardConfig(this.card.name);
            this.currency =
                (this.card && this.card.currency) || this.cardConfig.currency;
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], CardListItemComponent.prototype, "card", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], CardListItemComponent.prototype, "type", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], CardListItemComponent.prototype, "config", void 0);
CardListItemComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'card-list-item',
        template: `
    <button ion-item class="card-list-item">
      <ion-icon item-start>
        <img-loader
          class="card-list-item__icon"
          [ngClass]="{ archived: card?.archived && type === 'purchased' }"
          [src]="cardConfig?.icon"
          [fallbackAsPlaceholder]="true"
          [fallbackUrl]="giftCardProvider.fallbackIcon"
        ></img-loader>
      </ion-icon>
      <ion-label>
        <div *ngIf="type === 'purchased'">
          <div class="card-list-item__label">
            {{ card.amount | formatCurrency: card.currency }}
          </div>
          <ion-note class="card-list-item__note">{{
            card.date | amTimeAgo
          }}</ion-note>
        </div>
        <div *ngIf="(type === 'catalog' || type === 'settings') && cardConfig">
          <div
            class="card-list-item__label ellipsis"
            [ngClass]="{ 'no-margin-bottom': type === 'settings' }"
          >
            {{ cardConfig.displayName }}
          </div>
          <ion-note
            class="card-list-item__note"
            *ngIf="!cardConfig.supportedAmounts && type === 'catalog'"
          >
            {{ cardConfig.minAmount | formatCurrency: currency:0 }} 
            {{ cardConfig.maxAmount | formatCurrency: currency:0 }}
          </ion-note>
          <ion-note
            class="card-list-item__note ellipsis"
            *ngIf="cardConfig.supportedAmounts && type === 'catalog'"
          >
            <span
              *ngFor="
                let amount of cardConfig.supportedAmounts;
                let last = last
              "
            >
              {{ amount | formatCurrency: currency:'minimal'
              }}<span *ngIf="!last">,</span>
            </span>
          </ion-note>
        </div>
      </ion-label>
    </button>
  `
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_gift_card_gift_card__["a" /* GiftCardProvider */]])
], CardListItemComponent);

//# sourceMappingURL=card-list-item.js.map

/***/ }),

/***/ 1987:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class AddressValidator {
    constructor(addressProvider) {
        AddressValidator.addressProvider = addressProvider;
    }
    isValid(control) {
        return AddressValidator.addressProvider.isValid(control.value)
            ? null
            : { 'Invalid Address': true };
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AddressValidator;

//# sourceMappingURL=address.js.map

/***/ }),

/***/ 1988:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class EmailValidator {
    constructor(cnf, eml) {
        EmailValidator.cnf = cnf;
        EmailValidator.eml = eml;
    }
    isValid(control) {
        let config = EmailValidator.cnf.get();
        let latestEmail = EmailValidator.eml.getEmailIfEnabled(config);
        let validEmail = /^[a-zA-Z0-9.!#$%&*+=?^_{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/.test(control.value);
        if (validEmail && control.value != latestEmail) {
            return null;
        }
        return {
            'Invalid Email': true
        };
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EmailValidator;

//# sourceMappingURL=email.js.map

/***/ }),

/***/ 1990:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pages_add_wallet_add_wallet__ = __webpack_require__(320);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pages_add_add__ = __webpack_require__(324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__pages_add_copayers_copayers__ = __webpack_require__(1027);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pages_add_create_wallet_create_wallet__ = __webpack_require__(321);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pages_add_import_wallet_import_wallet__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pages_add_join_wallet_join_wallet__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__pages_add_select_currency_select_currency__ = __webpack_require__(326);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__pages_backup_backup_game_backup_game__ = __webpack_require__(1015);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__pages_backup_backup_key_backup_key__ = __webpack_require__(334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__pages_feedback_send_feedback_send_feedback__ = __webpack_require__(470);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__pages_finish_finish__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__pages_onboarding_collect_email_collect_email__ = __webpack_require__(1991);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__pages_onboarding_disclaimer_disclaimer__ = __webpack_require__(475);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__pages_onboarding_onboarding__ = __webpack_require__(1030);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__pages_paper_wallet_paper_wallet__ = __webpack_require__(467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__pages_slide_to_accept_slide_to_accept__ = __webpack_require__(1992);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__pages_tabs_tabs__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__pages_tx_details_tx_details__ = __webpack_require__(1031);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__pages_txp_details_txp_details__ = __webpack_require__(1039);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__pages_wallet_details_search_tx_modal_search_tx_modal__ = __webpack_require__(1032);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__pages_wallet_details_wallet_balance_wallet_balance__ = __webpack_require__(1033);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__pages_wallet_details_wallet_details__ = __webpack_require__(476);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__pages_wallet_tabs_wallet_tabs__ = __webpack_require__(1034);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__pages_integrations_invoice_select_invoice_select_invoice__ = __webpack_require__(1029);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__pages_integrations_coinbase_buy_coinbase_buy_coinbase__ = __webpack_require__(985);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__pages_integrations_coinbase_coinbase__ = __webpack_require__(248);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__pages_integrations_coinbase_coinbase_settings_coinbase_settings__ = __webpack_require__(997);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__pages_integrations_coinbase_coinbase_tx_details_coinbase_tx_details__ = __webpack_require__(986);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__pages_integrations_coinbase_sell_coinbase_sell_coinbase__ = __webpack_require__(987);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__pages_integrations_shapeshift_shapeshift__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__pages_integrations_shapeshift_shapeshift_confirm_shapeshift_confirm__ = __webpack_require__(991);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__pages_integrations_shapeshift_shapeshift_details_shapeshift_details__ = __webpack_require__(992);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__pages_integrations_shapeshift_shapeshift_settings_shapeshift_settings__ = __webpack_require__(1000);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__pages_integrations_shapeshift_shapeshift_shift_shapeshift_shift__ = __webpack_require__(993);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__pages_integrations_bitpay_card_bitpay_card__ = __webpack_require__(327);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__pages_integrations_bitpay_card_bitpay_card_home_bitpay_card_home__ = __webpack_require__(1993);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__pages_integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__pages_integrations_bitpay_card_bitpay_card_topup_bitpay_card_topup__ = __webpack_require__(984);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__pages_integrations_bitpay_card_bitpay_settings_bitpay_settings__ = __webpack_require__(996);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__pages_includes_card_item_card_item__ = __webpack_require__(1994);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__pages_includes_coin_selector_coin_selector__ = __webpack_require__(983);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__pages_includes_create_new_wallet_create_new_wallet__ = __webpack_require__(1995);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__pages_includes_eth_live_card_eth_live_card__ = __webpack_require__(1996);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__pages_includes_feedback_card_feedback_card__ = __webpack_require__(1997);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__pages_includes_gravatar_gravatar__ = __webpack_require__(1998);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__pages_includes_multiple_outputs_multiple_outputs__ = __webpack_require__(1999);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__pages_includes_survey_card_survey_card__ = __webpack_require__(2000);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__pages_includes_txp_txp__ = __webpack_require__(2001);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__pages_home_home__ = __webpack_require__(982);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__pages_receive_receive__ = __webpack_require__(1035);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__pages_scan_scan__ = __webpack_require__(247);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__pages_send_send__ = __webpack_require__(1036);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__pages_settings_settings__ = __webpack_require__(995);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__pages_home_proposals_proposals__ = __webpack_require__(474);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__pages_fingerprint_fingerprint__ = __webpack_require__(1028);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__pages_pin_pin__ = __webpack_require__(2002);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__pages_settings_about_about__ = __webpack_require__(1001);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__pages_settings_about_session_log_session_log__ = __webpack_require__(1002);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__pages_settings_addressbook_add_add__ = __webpack_require__(333);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__pages_settings_addressbook_addressbook__ = __webpack_require__(1003);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__pages_settings_addressbook_view_view__ = __webpack_require__(1004);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__pages_settings_advanced_advanced__ = __webpack_require__(1005);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__pages_settings_alt_currency_alt_currency__ = __webpack_require__(1008);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__pages_settings_fee_policy_fee_policy__ = __webpack_require__(1009);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__pages_settings_language_language__ = __webpack_require__(1010);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_65__pages_settings_lock_lock__ = __webpack_require__(1011);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_66__pages_settings_notifications_notifications__ = __webpack_require__(1012);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_67__pages_settings_share_share__ = __webpack_require__(1013);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_68__pages_settings_wallet_group_settings_wallet_group_delete_wallet_group_delete__ = __webpack_require__(1024);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_69__pages_settings_wallet_group_settings_wallet_group_extended_private_key_wallet_group_extended_private_key__ = __webpack_require__(1025);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_70__pages_settings_wallet_group_settings_wallet_group_name_wallet_group_name__ = __webpack_require__(1016);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_71__pages_settings_wallet_group_settings_wallet_group_onboarding_wallet_group_onboarding__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_72__pages_settings_wallet_group_settings_wallet_group_qr_export_wallet_group_qr_export__ = __webpack_require__(1026);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_73__pages_settings_wallet_group_settings_wallet_group_settings__ = __webpack_require__(1014);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_74__pages_settings_wallet_settings_wallet_delete_wallet_delete__ = __webpack_require__(1017);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_75__pages_settings_wallet_settings_wallet_name_wallet_name__ = __webpack_require__(1018);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_76__pages_settings_wallet_settings_wallet_settings__ = __webpack_require__(471);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_77__settings_advanced_wallet_recover_page_wallet_mnemonic_recover_page_wallet_mnemonic_recover_page__ = __webpack_require__(1007);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_78__settings_advanced_wallet_recover_page_wallet_recover_page__ = __webpack_require__(1006);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_79__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_all_addresses_all_addresses__ = __webpack_require__(1019);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_80__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_wallet_addresses__ = __webpack_require__(472);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_81__pages_settings_wallet_settings_wallet_settings_advanced_wallet_duplicate_wallet_duplicate__ = __webpack_require__(1020);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_82__pages_settings_wallet_settings_wallet_settings_advanced_wallet_export_wallet_export__ = __webpack_require__(473);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_83__pages_settings_wallet_settings_wallet_settings_advanced_wallet_information_wallet_information__ = __webpack_require__(1021);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_84__pages_settings_wallet_settings_wallet_settings_advanced_wallet_service_url_wallet_service_url__ = __webpack_require__(1022);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_85__pages_settings_wallet_settings_wallet_settings_advanced_wallet_transaction_history_wallet_transaction_history__ = __webpack_require__(1023);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_86__pages_send_amount_amount__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_87__pages_send_choose_fee_level_choose_fee_level__ = __webpack_require__(988);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_88__pages_send_confirm_confirm__ = __webpack_require__(249);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_89__pages_send_multi_send_multi_send__ = __webpack_require__(1037);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_90__pages_send_transfer_to_modal_transfer_to_modal__ = __webpack_require__(1038);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_91__pages_send_transfer_to_transfer_to__ = __webpack_require__(2005);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_92__pages_receive_custom_amount_custom_amount__ = __webpack_require__(994);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_93__templates_wide_header_page_wide_header_page__ = __webpack_require__(1040);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_94__wallet_tabs_wallet_tabs_child__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_95__integrations_gift_cards_card_catalog_card_catalog__ = __webpack_require__(1041);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_96__integrations_gift_cards_gift_cards__ = __webpack_require__(2006);
/* Pages */























// Integrations: Invoice

// Integrations: Coinbase





// Integrations: ShapeShift





// Integrations: BitPayCard





/*Includes */









/* Tabs */





/* Home */

/* Settings */














/* Wallet Group Settings */






/* Wallet Settings */





/* Wallet Advanced Settings */







/* Send */






/* Receive */





const PAGES = [
    __WEBPACK_IMPORTED_MODULE_1__pages_add_add__["a" /* AddPage */],
    __WEBPACK_IMPORTED_MODULE_0__pages_add_wallet_add_wallet__["a" /* AddWalletPage */],
    __WEBPACK_IMPORTED_MODULE_86__pages_send_amount_amount__["a" /* AmountPage */],
    __WEBPACK_IMPORTED_MODULE_59__pages_settings_addressbook_addressbook__["a" /* AddressbookPage */],
    __WEBPACK_IMPORTED_MODULE_58__pages_settings_addressbook_add_add__["a" /* AddressbookAddPage */],
    __WEBPACK_IMPORTED_MODULE_60__pages_settings_addressbook_view_view__["a" /* AddressbookViewPage */],
    __WEBPACK_IMPORTED_MODULE_56__pages_settings_about_about__["a" /* AboutPage */],
    __WEBPACK_IMPORTED_MODULE_61__pages_settings_advanced_advanced__["a" /* AdvancedPage */],
    __WEBPACK_IMPORTED_MODULE_79__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_all_addresses_all_addresses__["a" /* AllAddressesPage */],
    __WEBPACK_IMPORTED_MODULE_62__pages_settings_alt_currency_alt_currency__["a" /* AltCurrencyPage */],
    __WEBPACK_IMPORTED_MODULE_35__pages_integrations_bitpay_card_bitpay_card_home_bitpay_card_home__["a" /* BitPayCardHome */],
    __WEBPACK_IMPORTED_MODULE_36__pages_integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__["a" /* BitPayCardIntroPage */],
    __WEBPACK_IMPORTED_MODULE_34__pages_integrations_bitpay_card_bitpay_card__["a" /* BitPayCardPage */],
    __WEBPACK_IMPORTED_MODULE_38__pages_integrations_bitpay_card_bitpay_settings_bitpay_settings__["a" /* BitPaySettingsPage */],
    __WEBPACK_IMPORTED_MODULE_37__pages_integrations_bitpay_card_bitpay_card_topup_bitpay_card_topup__["a" /* BitPayCardTopUpPage */],
    __WEBPACK_IMPORTED_MODULE_24__pages_integrations_coinbase_buy_coinbase_buy_coinbase__["a" /* BuyCoinbasePage */],
    __WEBPACK_IMPORTED_MODULE_95__integrations_gift_cards_card_catalog_card_catalog__["a" /* CardCatalogPage */],
    __WEBPACK_IMPORTED_MODULE_87__pages_send_choose_fee_level_choose_fee_level__["a" /* ChooseFeeLevelPage */],
    __WEBPACK_IMPORTED_MODULE_3__pages_add_create_wallet_create_wallet__["a" /* CreateWalletPage */],
    __WEBPACK_IMPORTED_MODULE_41__pages_includes_create_new_wallet_create_new_wallet__["a" /* CreateNewWalletPage */],
    __WEBPACK_IMPORTED_MODULE_25__pages_integrations_coinbase_coinbase__["a" /* CoinbasePage */],
    __WEBPACK_IMPORTED_MODULE_27__pages_integrations_coinbase_coinbase_tx_details_coinbase_tx_details__["a" /* CoinbaseTxDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_2__pages_add_copayers_copayers__["a" /* CopayersPage */],
    __WEBPACK_IMPORTED_MODULE_42__pages_includes_eth_live_card_eth_live_card__["a" /* EthLiveCardPage */],
    __WEBPACK_IMPORTED_MODULE_43__pages_includes_feedback_card_feedback_card__["a" /* FeedbackCardPage */],
    __WEBPACK_IMPORTED_MODULE_67__pages_settings_share_share__["a" /* SharePage */],
    __WEBPACK_IMPORTED_MODULE_4__pages_add_import_wallet_import_wallet__["a" /* ImportWalletPage */],
    __WEBPACK_IMPORTED_MODULE_5__pages_add_join_wallet_join_wallet__["a" /* JoinWalletPage */],
    __WEBPACK_IMPORTED_MODULE_7__pages_backup_backup_game_backup_game__["a" /* BackupGamePage */],
    __WEBPACK_IMPORTED_MODULE_8__pages_backup_backup_key_backup_key__["a" /* BackupKeyPage */],
    __WEBPACK_IMPORTED_MODULE_88__pages_send_confirm_confirm__["a" /* ConfirmPage */],
    __WEBPACK_IMPORTED_MODULE_89__pages_send_multi_send_multi_send__["a" /* MultiSendPage */],
    __WEBPACK_IMPORTED_MODULE_90__pages_send_transfer_to_modal_transfer_to_modal__["a" /* TransferToModalPage */],
    __WEBPACK_IMPORTED_MODULE_91__pages_send_transfer_to_transfer_to__["a" /* TransferToPage */],
    __WEBPACK_IMPORTED_MODULE_92__pages_receive_custom_amount_custom_amount__["a" /* CustomAmountPage */],
    __WEBPACK_IMPORTED_MODULE_12__pages_onboarding_disclaimer_disclaimer__["a" /* DisclaimerPage */],
    __WEBPACK_IMPORTED_MODULE_11__pages_onboarding_collect_email_collect_email__["a" /* CollectEmailPage */],
    ...__WEBPACK_IMPORTED_MODULE_96__integrations_gift_cards_gift_cards__["a" /* GIFT_CARD_PAGES */],
    __WEBPACK_IMPORTED_MODULE_44__pages_includes_gravatar_gravatar__["a" /* GravatarPage */],
    __WEBPACK_IMPORTED_MODULE_54__pages_fingerprint_fingerprint__["a" /* FingerprintModalPage */],
    __WEBPACK_IMPORTED_MODULE_48__pages_home_home__["a" /* HomePage */],
    __WEBPACK_IMPORTED_MODULE_64__pages_settings_language_language__["a" /* LanguagePage */],
    __WEBPACK_IMPORTED_MODULE_65__pages_settings_lock_lock__["a" /* LockPage */],
    __WEBPACK_IMPORTED_MODULE_45__pages_includes_multiple_outputs_multiple_outputs__["a" /* MultipleOutputsPage */],
    __WEBPACK_IMPORTED_MODULE_13__pages_onboarding_onboarding__["a" /* OnboardingPage */],
    __WEBPACK_IMPORTED_MODULE_14__pages_paper_wallet_paper_wallet__["a" /* PaperWalletPage */],
    ...__WEBPACK_IMPORTED_MODULE_55__pages_pin_pin__["a" /* PIN_COMPONENTS */],
    __WEBPACK_IMPORTED_MODULE_53__pages_home_proposals_proposals__["a" /* ProposalsPage */],
    __WEBPACK_IMPORTED_MODULE_49__pages_receive_receive__["a" /* ReceivePage */],
    __WEBPACK_IMPORTED_MODULE_50__pages_scan_scan__["a" /* ScanPage */],
    __WEBPACK_IMPORTED_MODULE_51__pages_send_send__["a" /* SendPage */],
    __WEBPACK_IMPORTED_MODULE_52__pages_settings_settings__["a" /* SettingsPage */],
    __WEBPACK_IMPORTED_MODULE_28__pages_integrations_coinbase_sell_coinbase_sell_coinbase__["a" /* SellCoinbasePage */],
    __WEBPACK_IMPORTED_MODULE_6__pages_add_select_currency_select_currency__["a" /* SelectCurrencyPage */],
    __WEBPACK_IMPORTED_MODULE_23__pages_integrations_invoice_select_invoice_select_invoice__["a" /* SelectInvoicePage */],
    __WEBPACK_IMPORTED_MODULE_26__pages_integrations_coinbase_coinbase_settings_coinbase_settings__["a" /* CoinbaseSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_30__pages_integrations_shapeshift_shapeshift_confirm_shapeshift_confirm__["a" /* ShapeshiftConfirmPage */],
    __WEBPACK_IMPORTED_MODULE_31__pages_integrations_shapeshift_shapeshift_details_shapeshift_details__["a" /* ShapeshiftDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_32__pages_integrations_shapeshift_shapeshift_settings_shapeshift_settings__["a" /* ShapeshiftSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_29__pages_integrations_shapeshift_shapeshift__["a" /* ShapeshiftPage */],
    __WEBPACK_IMPORTED_MODULE_33__pages_integrations_shapeshift_shapeshift_shift_shapeshift_shift__["a" /* ShapeshiftShiftPage */],
    __WEBPACK_IMPORTED_MODULE_66__pages_settings_notifications_notifications__["a" /* NotificationsPage */],
    __WEBPACK_IMPORTED_MODULE_63__pages_settings_fee_policy_fee_policy__["a" /* FeePolicyPage */],
    __WEBPACK_IMPORTED_MODULE_19__pages_wallet_details_search_tx_modal_search_tx_modal__["a" /* SearchTxModalPage */],
    __WEBPACK_IMPORTED_MODULE_57__pages_settings_about_session_log_session_log__["a" /* SessionLogPage */],
    __WEBPACK_IMPORTED_MODULE_9__pages_feedback_send_feedback_send_feedback__["a" /* SendFeedbackPage */],
    __WEBPACK_IMPORTED_MODULE_46__pages_includes_survey_card_survey_card__["a" /* SurveyCardPage */],
    __WEBPACK_IMPORTED_MODULE_10__pages_finish_finish__["a" /* FinishModalPage */],
    __WEBPACK_IMPORTED_MODULE_16__pages_tabs_tabs__["a" /* TabsPage */],
    __WEBPACK_IMPORTED_MODULE_18__pages_txp_details_txp_details__["a" /* TxpDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_17__pages_tx_details_tx_details__["a" /* TxDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_47__pages_includes_txp_txp__["a" /* TxpPage */],
    __WEBPACK_IMPORTED_MODULE_76__pages_settings_wallet_settings_wallet_settings__["a" /* WalletSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_74__pages_settings_wallet_settings_wallet_delete_wallet_delete__["a" /* WalletDeletePage */],
    __WEBPACK_IMPORTED_MODULE_75__pages_settings_wallet_settings_wallet_name_wallet_name__["a" /* WalletNamePage */],
    __WEBPACK_IMPORTED_MODULE_83__pages_settings_wallet_settings_wallet_settings_advanced_wallet_information_wallet_information__["a" /* WalletInformationPage */],
    __WEBPACK_IMPORTED_MODULE_80__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_wallet_addresses__["a" /* WalletAddressesPage */],
    __WEBPACK_IMPORTED_MODULE_82__pages_settings_wallet_settings_wallet_settings_advanced_wallet_export_wallet_export__["a" /* WalletExportPage */],
    __WEBPACK_IMPORTED_MODULE_84__pages_settings_wallet_settings_wallet_settings_advanced_wallet_service_url_wallet_service_url__["a" /* WalletServiceUrlPage */],
    __WEBPACK_IMPORTED_MODULE_85__pages_settings_wallet_settings_wallet_settings_advanced_wallet_transaction_history_wallet_transaction_history__["a" /* WalletTransactionHistoryPage */],
    __WEBPACK_IMPORTED_MODULE_81__pages_settings_wallet_settings_wallet_settings_advanced_wallet_duplicate_wallet_duplicate__["a" /* WalletDuplicatePage */],
    __WEBPACK_IMPORTED_MODULE_69__pages_settings_wallet_group_settings_wallet_group_extended_private_key_wallet_group_extended_private_key__["a" /* WalletGroupExtendedPrivateKeyPage */],
    __WEBPACK_IMPORTED_MODULE_68__pages_settings_wallet_group_settings_wallet_group_delete_wallet_group_delete__["a" /* WalletGroupDeletePage */],
    __WEBPACK_IMPORTED_MODULE_72__pages_settings_wallet_group_settings_wallet_group_qr_export_wallet_group_qr_export__["a" /* WalletGroupQrExportPage */],
    __WEBPACK_IMPORTED_MODULE_73__pages_settings_wallet_group_settings_wallet_group_settings__["a" /* WalletGroupSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_70__pages_settings_wallet_group_settings_wallet_group_name_wallet_group_name__["a" /* WalletGroupNamePage */],
    __WEBPACK_IMPORTED_MODULE_71__pages_settings_wallet_group_settings_wallet_group_onboarding_wallet_group_onboarding__["a" /* WalletGroupOnboardingPage */],
    __WEBPACK_IMPORTED_MODULE_21__pages_wallet_details_wallet_details__["a" /* WalletDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_78__settings_advanced_wallet_recover_page_wallet_recover_page__["a" /* WalletRecoverPage */],
    __WEBPACK_IMPORTED_MODULE_77__settings_advanced_wallet_recover_page_wallet_mnemonic_recover_page_wallet_mnemonic_recover_page__["a" /* WalletMnemonicRecoverPage */],
    __WEBPACK_IMPORTED_MODULE_94__wallet_tabs_wallet_tabs_child__["a" /* WalletTabsChild */],
    __WEBPACK_IMPORTED_MODULE_22__pages_wallet_tabs_wallet_tabs__["a" /* WalletTabsPage */],
    __WEBPACK_IMPORTED_MODULE_20__pages_wallet_details_wallet_balance_wallet_balance__["a" /* WalletBalancePage */],
    __WEBPACK_IMPORTED_MODULE_93__templates_wide_header_page_wide_header_page__["a" /* WideHeaderPage */],
    __WEBPACK_IMPORTED_MODULE_39__pages_includes_card_item_card_item__["a" /* CardItemPage */],
    __WEBPACK_IMPORTED_MODULE_40__pages_includes_coin_selector_coin_selector__["a" /* CoinSelectorPage */],
    __WEBPACK_IMPORTED_MODULE_15__pages_slide_to_accept_slide_to_accept__["a" /* SlideToAcceptPage */]
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PAGES;

//# sourceMappingURL=pages.js.map

/***/ }),

/***/ 1991:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CollectEmailPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_device__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_email_notifications_email_notifications__ = __webpack_require__(147);





// native

// providers


// pages

let CollectEmailPage = class CollectEmailPage {
    constructor(logger, fb, appProvider, http, emailProvider, device, platformProvider) {
        this.logger = logger;
        this.fb = fb;
        this.appProvider = appProvider;
        this.http = http;
        this.emailProvider = emailProvider;
        this.device = device;
        this.platformProvider = platformProvider;
        const regex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        this.emailForm = this.fb.group({
            email: [null, [__WEBPACK_IMPORTED_MODULE_3__angular_forms__["f" /* Validators */].required, __WEBPACK_IMPORTED_MODULE_3__angular_forms__["f" /* Validators */].pattern(regex)]],
            accept: [false]
        });
        this.showConfirmForm = false;
        // Get more info: https://mashe.hawksey.info/2014/07/google-sheets-as-a-database-insert-with-apps-script-using-postget-methods-with-ajax-example/
        this.URL =
            this.appProvider.servicesInfo &&
                this.appProvider.servicesInfo.emailSheetURL
                ? this.appProvider.servicesInfo.emailSheetURL
                : null;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CollectEmailPage');
    }
    showConfirm() {
        this.showConfirmForm = !this.showConfirmForm;
    }
    save() {
        const opts = {
            enabled: true,
            email: this.emailForm.value.email
        };
        // Confirm for notifications
        this.emailProvider.updateEmail(opts);
        // Confirm to get news and updates from BitPay
        if (this.emailForm.value.accept)
            this.collectEmail();
    }
    collectEmail() {
        if (!this.URL)
            return;
        let version;
        let platform;
        if (this.platformProvider.isElectron) {
            version = this.platformProvider
                .getDeviceInfo()
                .match(/(Electron[\/]\d+(\.\d)*)/i)[0]; // getDeviceInfo example: 5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Copay/5.1.0 Chrome/66.0.3359.181 Electron/3.0.8 Safari/537.36
            platform =
                this.platformProvider.getOS() && this.platformProvider.getOS().OSName;
        }
        else {
            version = this.device.version || 'Unknown version';
            platform = this.device.platform || 'Unknown platform';
        }
        const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
        });
        const urlSearchParams = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["d" /* HttpParams */]()
            .set('App', this.appProvider.info.nameCase)
            .set('Email', this.emailForm.value.email)
            .set('AppVersion', this.appProvider.info.version)
            .set('Platform', platform)
            .set('DeviceVersion', version);
        this.http
            .post(this.URL, null, {
            params: urlSearchParams,
            headers
        })
            .subscribe(() => {
            this.logger.info('SUCCESS: Email collected');
        }, () => {
            this.logger.error('ERROR: Could not collect email');
        });
    }
};
CollectEmailPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Component"])({
        selector: 'page-collect-email',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/onboarding/collect-email/collect-email.html"*/'<ion-header no-border>\n  <ion-navbar hideBackButton="true">\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="fixed">\n    <h3 class="title" translate>Notifications by email</h3>\n    <div *ngIf="!showConfirmForm">\n      <img src=\'assets/img/app/onboarding/push-notifications.svg\' width="200" />\n    </div>\n  </div>\n</ion-content>\n\n<ion-footer no-border>\n  <div class="email-form" *ngIf="!showConfirmForm">\n    <p class="description" translate>Where would you like to receive email notifications about payments?</p>\n    <form [formGroup]="emailForm" (ngSubmit)="showConfirm()">\n      <ion-item>\n        <ion-input type="email" formControlName="email" placeholder="{{\'Email\' | translate}}"></ion-input>\n      </ion-item>\n\n      <ion-item no-lines>\n        <ion-label>{{\'Get news and updates from BitPay\' | translate}}</ion-label>\n        <ion-checkbox formControlName="accept" checked="false"></ion-checkbox>\n      </ion-item>\n      <button ion-button class="button-standard" type="submit" [disabled]="!emailForm.valid">\n        {{\'Continue\' | translate}}\n      </button>\n    </form>\n    <button ion-button clear class="button-standard btn-transparent primary-color" (click)="skip()">\n      {{\'Skip\' | translate}}\n    </button>\n  </div>\n\n  <div class="email-form" *ngIf="showConfirmForm">\n    <div>\n      <p translate>Is this email address correct?</p>\n      <p>{{ emailForm.value.email }}</p>\n    </div>\n    <button ion-button class="button-standard" (click)="save()">\n      {{\'Confirm\' | translate}}\n    </button>\n    <button ion-button class="button-standard btn-transparent primary-color" (click)="showConfirm()">\n      {{\'Edit\' | translate}}\n    </button>\n  </div>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/onboarding/collect-email/collect-email.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_8__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_5__ionic_native_device__["a" /* Device */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */]])
], CollectEmailPage);

//# sourceMappingURL=collect-email.js.map

/***/ }),

/***/ 1992:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SlideToAcceptPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);



let SlideToAcceptPage = class SlideToAcceptPage {
    constructor(navCtrl, navParams, renderer) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.renderer = renderer;
        this.slideDone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
        this.isPressed = false;
        this.delta = 8;
        this.done = false;
        this.isDisabled = false;
        this.isConfirm = false;
        this.animation = false;
    }
    set disabled(disabled) {
        this.isDisabled = disabled !== undefined ? disabled : false;
    }
    get disabled() {
        return this.isDisabled;
    }
    set slideButtonDone(done) {
        this.done = done !== undefined ? done : false;
    }
    get slideButtonDone() {
        return this.done;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.htmlButtonElem = this.buttonElement.nativeElement;
            this.htmlContainerElem = this.containerElement.nativeElement;
            let buttonConstraints = this.htmlButtonElem.getBoundingClientRect();
            this.origin = {
                left: buttonConstraints.left,
                top: buttonConstraints.top,
                width: buttonConstraints.width
            };
            this.containerWidth = this.htmlContainerElem.clientWidth;
            const subtract = this.containerWidth < 800 ? 75 : 200;
            this.xMax = this.containerWidth - subtract;
        }, 0);
    }
    activateButton(event) {
        this.isPressed = true;
        if (typeof event.touches != 'undefined') {
            this.clickPosition = event.touches[0].pageX;
        }
    }
    dragButton(event) {
        if (typeof event.touches != 'undefined') {
            let xTranslate = event.touches[0].pageX;
            let xDisplacement = this.isPressed ? xTranslate - this.clickPosition : 0;
            // Adjust displacement to consider the delta value
            xDisplacement -= this.delta;
            // Use resource inexpensive translation to perform the sliding
            let posCss = {
                transform: 'translateX(' + xDisplacement + 'px)',
                '-webkit-transform': 'translateX(' + xDisplacement + 'px)'
            };
            // Move the element while the drag position is less than xMax
            // -delta/2 is a necessary adjustment
            if (xDisplacement >= 0 &&
                xDisplacement <
                    this.containerWidth - (this.origin.width * 15) / 100 + 30 &&
                this.isPressed) {
                // Set element styles
                this.renderer.setElementStyle(this.htmlButtonElem, 'transform', posCss['transform']);
                this.renderer.setElementStyle(this.htmlButtonElem, '-webkit-transform', posCss['-webkit-transform']);
            }
            // If the max displacement position is reached
            this.slideButtonDone =
                xDisplacement >= this.xMax - this.delta / 2 ? true : false;
        }
    }
    resetButton() {
        // Only reset if button sliding is not done yet
        if (!this.slideButtonDone || this.isDisabled) {
            this.isConfirm = false;
            // Reset state variables
            // Resets button position
            let posCss = {
                transform: 'translateX(0px)',
                '-webkit-transform': 'translateX(0px)'
            };
            this.renderer.setElementStyle(this.htmlButtonElem, 'transform', posCss['transform']);
            this.renderer.setElementStyle(this.htmlButtonElem, '-webkit-transform', posCss['-webkit-transform']);
            this.ngAfterViewInit();
        }
        else if (this.slideButtonDone && !this.isDisabled) {
            this.isConfirm = true;
            this.slideButtonDone = false;
            this.slideDone.emit(true);
        }
    }
    isConfirmed(boolean) {
        if (!boolean) {
            this.resetButton();
        }
    }
    toggleAnimation() {
        if (this.isDisabled)
            return;
        this.animation = true;
        setTimeout(() => {
            this.animation = false;
        }, 300);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], SlideToAcceptPage.prototype, "slideDone", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], SlideToAcceptPage.prototype, "buttonText", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Boolean),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Boolean])
], SlideToAcceptPage.prototype, "disabled", null);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Boolean),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Boolean])
], SlideToAcceptPage.prototype, "slideButtonDone", null);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton', { read: __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"] }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"])
], SlideToAcceptPage.prototype, "buttonElement", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButtonContainer'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"])
], SlideToAcceptPage.prototype, "containerElement", void 0);
SlideToAcceptPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-slide-to-accept',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/slide-to-accept/slide-to-accept.html"*/'<div #slideButtonContainer class="slide__listener" no-margin no-padding>\n  <button class="button-slider" [ngClass]="{\'animation\': animation}" #slideButton ion-button icon-right large (touchstart)="activateButton($event)" (touchmove)="dragButton($event)" (touchend)="resetButton()" [disabled]="isDisabled" *ngIf="!isConfirm">\n    <div class="slide__bitcoin" [ngStyle]="bitcoinStyle">\n      <img src="assets/img/icon-bitcoin-white.svg">\n    </div>\n  </button>\n  <div class="slide__button-text" (touchstart)="toggleAnimation()" (touchmove)="toggleAnimation()" [ngStyle]="textStyle" *ngIf="!isConfirm">\n    <span class="justify">{{buttonText}}</span>\n  </div>\n  <div class="slide__arrow " *ngIf="!isConfirm">\n    <img src="assets/img/icon-arrow-right.svg">\n  </div>\n  <div class="slide__status-text" [ngClass]="{\'enter\': isConfirm}" *ngIf="isConfirm">\n    <ion-spinner *ngIf="isConfirm"></ion-spinner>\n  </div>\n</div>\n'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/slide-to-accept/slide-to-accept.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["Renderer"]])
], SlideToAcceptPage);

//# sourceMappingURL=slide-to-accept.js.map

/***/ }),

/***/ 1993:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayCardHome; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__ = __webpack_require__(250);



// Providers

// Pages

let BitPayCardHome = class BitPayCardHome {
    constructor(appProvider, navCtrl) {
        this.appProvider = appProvider;
        this.navCtrl = navCtrl;
        this.disableArchiveAnimation = true; // Removes flicker on iOS when returning to home tab
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.appName = this.appProvider.info.userVisibleName;
        });
    }
    goToBitPayCardIntroPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__["a" /* BitPayCardIntroPage */]);
    }
};
BitPayCardHome = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'bitpay-card-home',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/bitpay-card/bitpay-card-home/bitpay-card-home.html"*/'<action-card>\n  <div action-card-header>\n    <div class="bitpay-card-header">\n      <div class="bitpay-card-image">\n        <img src="assets/img/bitpay-card/bitpay-card.png">\n      </div>\n    </div>\n  </div>\n  <div action-card-title translate>Get a BitPay Card</div>\n  <div action-card-body translate>\n    Load dollars onto your BitPay Card using your bitcoin wallet. Shop anywhere that accepts Visa\n  </div>\n  <div action-card-button translate (click)="goToBitPayCardIntroPage()" tappable>\n    Get Started\n  </div>\n</action-card>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/bitpay-card/bitpay-card-home/bitpay-card-home.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers__["g" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */]])
], BitPayCardHome);

//# sourceMappingURL=bitpay-card-home.js.map

/***/ }),

/***/ 1994:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CardItemPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_time_time__ = __webpack_require__(148);



let CardItemPage = class CardItemPage {
    constructor(timeProvider) {
        this.timeProvider = timeProvider;
        this.sent = false;
        this.received = false;
        this.pending = false;
    }
    set card(card) {
        this._card = card;
        if (card.pending) {
            this.pending = true;
        }
        else if (card.price.toString().indexOf('-') > -1) {
            this.sent = true;
        }
        else {
            this.received = true;
        }
    }
    get card() {
        return this._card;
    }
    set currency(c) {
        this._currency = c;
    }
    get currency() {
        return this._currency;
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Object])
], CardItemPage.prototype, "card", null);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Object])
], CardItemPage.prototype, "currency", null);
CardItemPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-card-item',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/includes/card-item/card-item.html"*/'<ion-item *ngIf="card">\n  <ion-icon class="card-icon" item-start>\n    <div class="houston">\n      <img src="assets/img/mcc-icons/{{card.icon}}.svg" class="svg" />\n    </div>\n  </ion-icon>\n  <h4 text-wrap>\n    {{card.merchant.name || \'Unknown Merchant\'}}\n    <span *ngIf="card.pending && card.transactionId" translate>\n      View Confirmation Status\n    </span>\n  </h4>\n  <p class="merchant">\n    {{card.merchant.location}}\n  </p>\n  <ion-note class="amount" item-end text-end>\n    <div [ngClass]="{\'amount--sent\': sent, \'amount--received\': received, \'amount--pending\': pending}" id="price">\n      {{card.price | number:\'1.2-2\' }} {{currency}}\n    </div>\n    <div class="date">\n      {{card.date}}\n    </div>\n  </ion-note>\n</ion-item>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/includes/card-item/card-item.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_time_time__["a" /* TimeProvider */]])
], CardItemPage);

//# sourceMappingURL=card-item.js.map

/***/ }),

/***/ 1995:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CreateNewWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__add_select_currency_select_currency__ = __webpack_require__(326);



// Pages

let CreateNewWalletPage = class CreateNewWalletPage {
    constructor(navCtrl) {
        this.navCtrl = navCtrl;
    }
    goToAddWalletPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_3__add_select_currency_select_currency__["a" /* SelectCurrencyPage */], {
            isOnboardingFlow: true,
            isZeroState: true
        });
    }
};
CreateNewWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'create-new-wallet',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/includes/create-new-wallet/create-new-wallet.html"*/'<action-card>\n  <div action-card-header>\n    <img src="assets/img/onboarding-card.png" />\n  </div>\n  <div action-card-button translate (click)="goToAddWalletPage()" tappable>\n    Get Started\n  </div>\n</action-card>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/includes/create-new-wallet/create-new-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */]])
], CreateNewWalletPage);

//# sourceMappingURL=create-new-wallet.js.map

/***/ }),

/***/ 1996:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EthLiveCardPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers__ = __webpack_require__(35);


// Providers

let EthLiveCardPage = class EthLiveCardPage {
    constructor(logger, persistenceProvider) {
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.addEthClicked = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
        this.showEthLiveCard = false;
    }
    setShowEthLiveCard(value) {
        this.showEthLiveCard = value;
    }
    hideCard() {
        this.showEthLiveCard = false;
        this.logger.debug('ETH live card dismissed.');
        this.persistenceProvider.setEthLiveCardFlag();
    }
    goToAddWalletFlow() {
        this.addEthClicked.next();
        this.hideCard();
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], EthLiveCardPage.prototype, "addEthClicked", void 0);
EthLiveCardPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-eth-live-card',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/includes/eth-live-card/eth-live-card.html"*/'<action-card *ngIf="showEthLiveCard">\n  <div action-card-header>\n    <div class="icon-right">\n      <button ion-button clear icon-only item-end color="grey" (click)="hideCard()">\n        <ion-icon name="close"></ion-icon>\n      </button>\n    </div>\n    <div class="eth-live-img">\n      <img src="assets/img/eth-live-icon.svg">\n    </div>\n  </div>\n  <div action-card-title>Start Using ETH Now</div>\n  <div action-card-body>Big news! Now you can use Ether (ETH) in the BitPay App. Create your first Ethereum wallet today.</div>\n  <div action-card-button (click)="goToAddWalletFlow()" tappable>\n    <span class="eth-live-btn">Add ETH Wallet</span>\n  </div>\n</action-card>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/includes/eth-live-card/eth-live-card.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers__["N" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__providers__["Q" /* PersistenceProvider */]])
], EthLiveCardPage);

//# sourceMappingURL=eth-live-card.js.map

/***/ }),

/***/ 1997:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeedbackCardPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_replace_parameters_replace_parameters__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__pages_feedback_send_feedback_send_feedback__ = __webpack_require__(470);





// providers



// pages

let FeedbackCardPage = class FeedbackCardPage {
    constructor(appProvider, navCtrl, logger, persistenceProvider, translate, replaceParametersProvider) {
        this.appProvider = appProvider;
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.replaceParametersProvider = replaceParametersProvider;
        this.score = 0;
        this.isShowRateCard = false;
    }
    setShowRateCard(value) {
        this.isShowRateCard = value;
        if (this.isShowRateCard) {
            let appName = this.appProvider.info.nameCase;
            this.feedbackCardTitle = this.replaceParametersProvider.replace(this.translate.instant('How satisfied are you with {{appName}} wallet?'), { appName });
        }
    }
    hideCard() {
        this.isShowRateCard = false;
        this.logger.debug('Feedback card dismissed.');
        this.persistenceProvider.getFeedbackInfo().then(info => {
            let feedbackInfo = info;
            feedbackInfo.sent = true;
            this.persistenceProvider.setFeedbackInfo(feedbackInfo);
        });
    }
    setScore(score) {
        this.score = score;
        switch (this.score) {
            case 1:
                this.button_title = this.translate.instant("I'm disappointed");
                break;
            case 2:
                this.button_title = this.translate.instant("I'm satisfied");
                break;
            case 3:
                this.button_title = this.translate.instant("I'm very happy");
                break;
        }
    }
    goFeedbackFlow() {
        this.hideCard();
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__pages_feedback_send_feedback_send_feedback__["a" /* SendFeedbackPage */], {
            score: this.score,
            fromCard: true
        });
    }
};
FeedbackCardPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-feedback-card',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/includes/feedback-card/feedback-card.html"*/'<ion-card *ngIf="isShowRateCard">\n  <ion-card-header class="feedback-header">\n    <ion-row>\n      <button ion-button clear icon-only item-end color="grey" (click)="hideCard()">\n        <ion-icon name="close"></ion-icon>\n      </button>\n    </ion-row>\n  </ion-card-header>\n  <ion-card-content>\n    <div class="title" translate>Give us feedback</div>\n    <div class="subtitle">{{feedbackCardTitle}}</div>\n    <ion-list>\n      <ion-row class="icons-row">\n        <ion-col col-20>\n          <ion-icon class="icon-svg" (click)="setScore(1)">\n            <img [ngClass]="{\'opacity-low\': score > 0 && score != 1}" src="assets/img/disappointed-face.svg" />\n          </ion-icon>\n        </ion-col>\n        <ion-col col-20>\n          <ion-icon class="icon-svg" (click)="setScore(2)">\n            <img [ngClass]="{\'opacity-low\': score > 0 && score != 2}" src="assets/img/satisfied-face.svg" />\n          </ion-icon>\n        </ion-col>\n        <ion-col col-20>\n          <ion-icon class="icon-svg" (click)="setScore(3)">\n            <img [ngClass]="{\'opacity-low\': score > 0 && score != 3}" src="assets/img/happy-face.svg" />\n          </ion-icon>\n        </ion-col>\n      </ion-row>\n      <button ion-button class="button-standard" (click)="goFeedbackFlow()" *ngIf="button_title">\n        <span>{{button_title}}</span>\n      </button>\n    </ion-list>\n  </ion-card-content>\n</ion-card>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/includes/feedback-card/feedback-card.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_7__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */]])
], FeedbackCardPage);

//# sourceMappingURL=feedback-card.js.map

/***/ }),

/***/ 1998:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GravatarPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let GravatarPage = class GravatarPage {
    constructor() { }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], GravatarPage.prototype, "email", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], GravatarPage.prototype, "name", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Number)
], GravatarPage.prototype, "height", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Number)
], GravatarPage.prototype, "width", void 0);
GravatarPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'gravatar',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/includes/gravatar/gravatar.html"*/'<img class="gravatar" alt="{{ name }}" height="{{ height }}" width="{{ width }}" src="assets/img/contact-placeholder.svg">'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/includes/gravatar/gravatar.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [])
], GravatarPage);

//# sourceMappingURL=gravatar.js.map

/***/ }),

/***/ 1999:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MultipleOutputsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_address_book_address_book__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_address_address__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_wallet_wallet__ = __webpack_require__(32);



// Providers




let MultipleOutputsPage = class MultipleOutputsPage {
    constructor(addressBookProvider, addressProvider, logger, walletProvider) {
        this.addressBookProvider = addressBookProvider;
        this.addressProvider = addressProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.showMultiplesOutputs = false;
    }
    set tx(tx) {
        this._tx = tx;
        this.tx.outputs.forEach(output => {
            const outputAddr = output.toAddress ? output.toAddress : output.address;
            this.coin = this._tx.coin
                ? this._tx.coin
                : this.addressProvider.getCoinAndNetwork(outputAddr, this._tx.network)
                    .coin;
            const addressToShow = this.walletProvider.getAddressView(this.coin, this._tx.network, outputAddr);
            output.addressToShow =
                addressToShow == 'false' ? 'Unparsed address' : addressToShow;
        });
        this.contact();
    }
    get tx() {
        return this._tx;
    }
    contact() {
        const addr = this._tx.toAddress;
        this.addressBookProvider
            .get(addr)
            .then(ab => {
            if (ab) {
                const name = __WEBPACK_IMPORTED_MODULE_2_lodash__["isObject"](ab) ? ab.name : ab;
                this.contactName = name;
            }
        })
            .catch(err => {
            this.logger.warn(err);
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Object])
], MultipleOutputsPage.prototype, "tx", null);
MultipleOutputsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-multiple-outputs',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/includes/multiple-outputs/multiple-outputs.html"*/'<ion-item class="container-to" (click)="showMultiplesOutputs = !showMultiplesOutputs">\n  <span translate>To</span>\n  <div class="wallet">\n    <div class="address-coppied">\n      <div class="text-address">\n        <img class="coin-img-{{coin}}" *ngIf="tx.hasMultiplesOutputs || (!tx.hasMultiplesOutputs && tx.customData?.service != \'debitcard\')" src="assets/img/icon-{{coin}}-small.svg" alt="Coin">\n        <img *ngIf="!tx.hasMultiplesOutputs && tx.customData?.service == \'debitcard\'" src="assets/img/icon-card.svg" class="debit-card">\n        <span class="address-divider"></span>\n      </div>\n\n      <div class="ellipsis" *ngIf="!tx.hasMultiplesOutputs" copy-to-clipboard="{{ tx.outputs[0].addressToShow ? tx.outputs[0].addressToShow : tx.outputs[0].address }}">\n        <span *ngIf="!contactName">{{ tx.outputs[0].addressToShow ? tx.outputs[0].addressToShow : tx.outputs[0].address }}</span>\n        <span *ngIf="contactName">{{ contactName }}</span>\n      </div>\n\n      <div *ngIf="tx.hasMultiplesOutputs">\n        <span>\n          <span translate>Multiple recipients: </span>\n          <span>{{tx.recipientCount}}</span>\n        </span>\n      </div>\n    </div>\n\n    <div class="last-item" *ngIf="tx.hasMultiplesOutputs" item-end>\n      <button ion-button clear color="grey" icon-only>\n        <ion-icon *ngIf="showMultiplesOutputs" name="ios-arrow-up-outline"></ion-icon>\n        <ion-icon *ngIf="!showMultiplesOutputs" name="ios-arrow-down-outline"></ion-icon>\n      </button>\n    </div>\n  </div>\n</ion-item>\n\n<ion-list detail-none *ngIf="tx.hasMultiplesOutputs && showMultiplesOutputs">\n  <ion-item *ngFor="let output of tx.outputs" copy-to-clipboard="{{output.toAddress ? output.toAddress : output.address}}">\n    <div item-left>\n      <h2>\n        <span translate>To</span>:\n      </h2>\n      <h3>\n        <span translate>Amount</span>:\n      </h3>\n      <p class="output-note" *ngIf="output.message">\n        <span translate>Note</span>:\n      </p>\n    </div>\n    <ion-note item-right text-end col-11>\n      <span class="output-note ellipsis">{{output.addressToShow || output.toAddress || output.address}}</span>\n      <span class="output-note ellipsis">{{output.amountStr}}\n        <span *ngIf="output.alternativeAmountStr">({{output.alternativeAmountStr}})</span>\n      </span>\n      <p class="output-note" *ngIf="output.message">\n        <span class="ellipsis">{{output.message}}</span>\n      </p>\n    </ion-note>\n  </ion-item>\n</ion-list>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/includes/multiple-outputs/multiple-outputs.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_wallet_wallet__["a" /* WalletProvider */]])
], MultipleOutputsPage);

//# sourceMappingURL=multiple-outputs.js.map

/***/ }),

/***/ 2000:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SurveyCardPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers__ = __webpack_require__(35);


// Providers

let SurveyCardPage = class SurveyCardPage {
    constructor(externalLinkProvider, logger, persistenceProvider) {
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.showSurveyCard = false;
    }
    setShowSurveyCard(value) {
        this.showSurveyCard = value;
    }
    hideCard() {
        this.showSurveyCard = false;
        this.logger.debug('Survey card dismissed.');
        this.persistenceProvider.setSurveyFlag();
    }
    openSurveyInBrowser() {
        this.hideCard();
        this.externalLinkProvider.open('https://bitpayux.typeform.com/to/z81Jp7');
    }
};
SurveyCardPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-survey-card',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/includes/survey-card/survey-card.html"*/'<action-card *ngIf="showSurveyCard">\n  <div action-card-header item-end class="icon-right">\n    <button ion-button clear icon-only item-end color="grey" (click)="hideCard()">\n      <ion-icon name="close"></ion-icon>\n    </button>\n  </div>\n  <div action-card-title>Got a minute?</div>\n  <div action-card-body>Anonymously take a brief 2 minute survey in order to help us improve the experience.</div>\n  <div action-card-button (click)="openSurveyInBrowser()" tappable>\n    <span class="survey-button">Take Survey</span>\n  </div>\n</action-card>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/includes/survey-card/survey-card.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers__["y" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers__["N" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__providers__["Q" /* PersistenceProvider */]])
], SurveyCardPage);

//# sourceMappingURL=survey-card.js.map

/***/ }),

/***/ 2001:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxpPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_time_time__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__txp_details_txp_details__ = __webpack_require__(1039);





let TxpPage = class TxpPage {
    constructor(timeProvider, modalCtrl) {
        this.timeProvider = timeProvider;
        this.modalCtrl = modalCtrl;
    }
    set tx(tx) {
        this._tx = tx;
    }
    get tx() {
        return this._tx;
    }
    set addressbook(addressbook) {
        this._addressbook = addressbook;
    }
    get addressbook() {
        return this._addressbook;
    }
    set noOpenModal(noOpenModal) {
        this._noOpenModal = noOpenModal;
    }
    get noOpenModal() {
        return this._noOpenModal;
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
    openTxpModal(txp) {
        if (this._noOpenModal)
            return;
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_4__txp_details_txp_details__["a" /* TxpDetailsPage */], { tx: txp }, { showBackdrop: false, enableBackdropDismiss: false });
        modal.present();
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Object])
], TxpPage.prototype, "tx", null);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Object])
], TxpPage.prototype, "addressbook", null);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Object])
], TxpPage.prototype, "noOpenModal", null);
TxpPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-txp',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/includes/txp/txp.html"*/'<button ion-item class="proposal-container" (click)="openTxpModal(tx)">\n  <div *ngIf="!tx.merchant" class="proposal-title">\n    <span *ngIf="tx.message">{{tx.message}}</span>\n    <span *ngIf="!tx.message && tx.toAddress && addressbook[tx.toAddress]">{{addressbook[tx.toAddress].name || addressbook[tx.toAddress]}}</span>\n    <span *ngIf="!tx.message && tx.toAddress && !addressbook[tx.toAddress]" translate>Sending</span>\n  </div>\n  <div class="proposal-subtitle">\n    <span *ngIf="tx.merchant" class="item-subtitle">\n      <span *ngIf="tx.merchant.pr.ca">\n        <ion-icon class="fi-lock"></ion-icon>{{tx.merchant.domain}}\n      </span>\n      <span *ngIf="!tx.merchant.pr.ca">\n        <ion-icon class="fion-icon-unlock"></ion-icon>{{tx.merchant.domain}}\n      </span>\n    </span>\n    <div class="item-subtitle">\n      <span *ngIf="tx.creatorName">\n        <span translate>Created by</span>\n        <span>{{tx.creatorName}}</span>\n      </span>\n    </div>\n  </div>\n\n  <ion-note item-right>\n    <div class="amount">\n      <span *ngIf="tx.action == \'sent\'"></span>\n      <span *ngIf="tx.action == \'invalid\'" translate>(possible double spend)</span>\n      <span *ngIf="tx.action != \'invalid\'">{{tx.amountStr}}</span>\n    </div>\n    <div class="date">\n      <time *ngIf="tx.createdOn && createdWithinPastDay(tx.createdOn * 1000)">{{tx.createdOn * 1000 | amTimeAgo}}</time>\n      <time *ngIf="tx.createdOn && !createdWithinPastDay(tx.createdOn * 1000)">{{tx.createdOn * 1000 | amDateFormat:\'MMM D, YYYY\'}}</time>\n    </div>\n  </ion-note>\n</button>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/includes/txp/txp.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* ModalController */]])
], TxpPage);

//# sourceMappingURL=txp.js.map

/***/ }),

/***/ 2002:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pin_dots_pin_dots_component__ = __webpack_require__(2003);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pin_modal_pin_modal__ = __webpack_require__(332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__pin_pad_pin_pad_component__ = __webpack_require__(2004);



const PIN_COMPONENTS = [__WEBPACK_IMPORTED_MODULE_1__pin_modal_pin_modal__["a" /* PinModalPage */], __WEBPACK_IMPORTED_MODULE_0__pin_dots_pin_dots_component__["a" /* PinDots */], __WEBPACK_IMPORTED_MODULE_2__pin_pad_pin_pad_component__["a" /* PinPad */]];
/* harmony export (immutable) */ __webpack_exports__["a"] = PIN_COMPONENTS;

//# sourceMappingURL=pin.js.map

/***/ }),

/***/ 2003:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PinDots; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__directives_animate_animate__ = __webpack_require__(469);



let PinDots = class PinDots {
    constructor() {
        this.dotArray = new Array(4);
    }
    ngOnChanges(changes) {
        const pinChanges = changes.pin;
        if (!pinChanges) {
            return;
        }
        const currentValue = pinChanges.currentValue;
        const previousValue = pinChanges.previousValue;
        if (!currentValue.length || currentValue.length < previousValue.length) {
            return;
        }
        this.pulseDot(currentValue.length - 1);
    }
    isFilled(limit) {
        return this.pin && this.pin.length >= limit;
    }
    pulseDot(dotIndex) {
        const dot = this.dots.toArray()[dotIndex];
        dot.animate('pulse');
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], PinDots.prototype, "pin", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChildren"])(__WEBPACK_IMPORTED_MODULE_2__directives_animate_animate__["a" /* Animate */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["QueryList"])
], PinDots.prototype, "dots", void 0);
PinDots = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'pin-dots',
        template: `
    <div
      *ngFor="let dot of dotArray; index as i"
      class="circle"
      [ngClass]="{ filled: isFilled(i + 1) }"
      animate
    ></div>
  `
    })
], PinDots);

//# sourceMappingURL=pin-dots.component.js.map

/***/ }),

/***/ 2004:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PinPad; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__);




let PinPad = class PinPad {
    constructor() {
        this.integersOnly = false;
        this.showSendMax = false;
        this.keystrokeSubject = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__["Subject"]();
        this.keystroke = this.keystrokeSubject.asObservable();
        this.buttonRows = [
            [
                {
                    value: '1',
                    letters: ''
                },
                {
                    value: '2',
                    letters: 'ABC'
                },
                {
                    value: '3',
                    letters: 'DEF'
                }
            ],
            [
                {
                    value: '4',
                    letters: 'GHI'
                },
                {
                    value: '5',
                    letters: 'JKL'
                },
                {
                    value: '6',
                    letters: 'MNO'
                }
            ],
            [
                {
                    value: '7',
                    letters: 'PQRS'
                },
                {
                    value: '8',
                    letters: 'TUV'
                },
                {
                    value: '9',
                    letters: 'WXYZ'
                }
            ],
            [
                {
                    value: '.',
                    letters: ''
                },
                {
                    value: '0',
                    letters: ''
                },
                {
                    value: 'delete',
                    letters: ''
                }
            ]
        ];
    }
    onKeystroke(value) {
        if (this.isValueDisabled(value)) {
            return;
        }
        this.keystrokeSubject.next(value);
    }
    isValueDisabled(value) {
        return value === '.' && this.integersOnly;
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Boolean)
], PinPad.prototype, "integersOnly", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Boolean)
], PinPad.prototype, "showSendMax", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], PinPad.prototype, "type", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__["Observable"])
], PinPad.prototype, "keystroke", void 0);
PinPad = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'pin-pad',
        template: `
    <ion-row *ngFor="let row of buttonRows">
      <ion-col
        *ngFor="let button of row"
        (click)="onKeystroke(button.value)"
        [ngClass]="{ disabled: isValueDisabled(button.value) }"
        tappable
      >
        <div class="buttons-container" [ngSwitch]="button.value">
          <span *ngSwitchCase="'delete'">
            <img *ngIf="type === 'pin'" src="assets/img/tail-left.svg" />
            <img
              class="amount-delete"
              *ngIf="type === 'amount'"
              src="assets/img/icon-delete.svg"
            />
          </span>
          <span *ngSwitchCase="'.'">
            <span *ngIf="type === 'amount'">.</span>
          </span>
          <span
            *ngSwitchCase="'0'"
            class="key-wrapper"
            [ngClass]="{ 'swap-key': type === 'amount' && showSendMax }"
          >
            <span class="send-max" translate>Send Max</span> <span>0</span>
          </span>
          <span *ngSwitchDefault>{{ button.value }}</span>
        </div>
        <div class="letters" *ngIf="type === 'pin'">{{ button.letters }}</div>
      </ion-col>
    </ion-row>
  `
    })
], PinPad);

//# sourceMappingURL=pin-pad.component.js.map

/***/ }),

/***/ 2005:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TransferToPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_address_address__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__amount_amount__ = __webpack_require__(102);




// Providers







// Pages

let TransferToPage = class TransferToPage {
    constructor(currencyProvider, navCtrl, navParams, profileProvider, walletProvider, addressBookProvider, logger, popupProvider, addressProvider) {
        this.currencyProvider = currencyProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.addressBookProvider = addressBookProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.addressProvider = addressProvider;
        this.search = '';
        this.wallets = {};
        this.hasWallets = {};
        this.walletList = {};
        this.contactsList = [];
        this.filteredContactsList = [];
        this.filteredWallets = [];
        this.CONTACTS_SHOW_LIMIT = 10;
        this.currentContactsPage = 0;
        this.availableCoins = this.currencyProvider.getAvailableCoins();
        for (const coin of this.availableCoins) {
            this.wallets[coin] = this.profileProvider.getWallets({ coin });
            this.hasWallets[coin] = !__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.wallets[coin]);
        }
    }
    set wallet(wallet) {
        this._wallet = this.navParams.data.wallet
            ? this.navParams.data.wallet
            : wallet;
        for (const coin of this.availableCoins) {
            this.walletList[coin] = this.getWalletsList(coin);
        }
        this.updateContactsList();
    }
    get wallet() {
        return this._wallet;
    }
    set searchInput(search) {
        this.search = search;
        this.processInput();
    }
    get searchInput() {
        return this.search;
    }
    set useAsModal(useAsModal) {
        this._useAsModal = useAsModal;
    }
    get useAsModal() {
        return this._useAsModal;
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    getWalletsList(coin) {
        return this.hasWallets[coin]
            ? this.getRelevantWallets(this.wallets[coin])
            : [];
    }
    getRelevantWallets(rawWallets) {
        return rawWallets
            .map(wallet => this.flattenWallet(wallet))
            .filter(wallet => this.filterIrrelevantRecipients(wallet));
    }
    updateContactsList() {
        this.addressBookProvider.list().then(ab => {
            this.hasContacts = __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](ab) ? false : true;
            if (!this.hasContacts)
                return;
            let contactsList = [];
            __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](ab, (v, k) => {
                const addrData = this.addressProvider.getCoinAndNetwork(k);
                contactsList.push({
                    name: __WEBPACK_IMPORTED_MODULE_3_lodash__["isObject"](v) ? v.name : v,
                    address: k,
                    network: addrData.network,
                    email: __WEBPACK_IMPORTED_MODULE_3_lodash__["isObject"](v) ? v.email : null,
                    recipientType: 'contact',
                    coin: addrData.coin,
                    getAddress: () => Promise.resolve(k)
                });
            });
            contactsList = __WEBPACK_IMPORTED_MODULE_3_lodash__["orderBy"](contactsList, 'name');
            this.contactsList = contactsList.filter(c => this.filterIrrelevantRecipients(c));
            let shortContactsList = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](this.contactsList.slice(0, (this.currentContactsPage + 1) * this.CONTACTS_SHOW_LIMIT));
            this.filteredContactsList = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](shortContactsList);
            this.contactsShowMore =
                this.contactsList.length > shortContactsList.length;
        });
    }
    flattenWallet(wallet) {
        return {
            color: wallet.color,
            name: wallet.name,
            recipientType: 'wallet',
            coin: wallet.coin,
            network: wallet.network,
            m: wallet.credentials.m,
            n: wallet.credentials.n,
            isComplete: wallet.isComplete(),
            needsBackup: wallet.needsBackup,
            getAddress: () => this.walletProvider.getAddress(wallet, false)
        };
    }
    filterIrrelevantRecipients(recipient) {
        return this._wallet
            ? this._wallet.coin === recipient.coin &&
                this._wallet.network === recipient.network
            : true;
    }
    showMore() {
        this.currentContactsPage++;
        this.updateContactsList();
    }
    processInput() {
        if (this.search && this.search.trim() != '') {
            this.searchWallets();
            this.searchContacts();
            this.hasContactsOrWallets =
                this.filteredContactsList.length === 0 &&
                    this.filteredWallets.length === 0
                    ? false
                    : true;
        }
        else {
            this.updateContactsList();
            this.filteredWallets = [];
        }
    }
    searchWallets() {
        for (const coin of this.availableCoins) {
            if (this.hasWallets[coin] && this._wallet.coin === coin) {
                this.filteredWallets = this.walletList[coin].filter(wallet => {
                    return __WEBPACK_IMPORTED_MODULE_3_lodash__["includes"](wallet.name.toLowerCase(), this.search.toLowerCase());
                });
            }
        }
    }
    searchContacts() {
        this.filteredContactsList = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.contactsList, item => {
            let val = item.name;
            return __WEBPACK_IMPORTED_MODULE_3_lodash__["includes"](val.toLowerCase(), this.search.toLowerCase());
        });
    }
    close(item) {
        item
            .getAddress()
            .then((addr) => {
            if (!addr) {
                // Error is already formated
                this.popupProvider.ionicAlert('Error - no address');
                return;
            }
            this.logger.debug('Got address:' + addr + ' | ' + item.name);
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__amount_amount__["a" /* AmountPage */], {
                recipientType: item.recipientType,
                amount: parseInt(this.navParams.data.amount, 10),
                toAddress: addr,
                name: item.name,
                email: item.email,
                color: item.color,
                coin: item.coin,
                network: item.network,
                useAsModal: this._useAsModal
            });
        })
            .catch(err => {
            this.logger.error('Send: could not getAddress', err);
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Object])
], TransferToPage.prototype, "wallet", null);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Object])
], TransferToPage.prototype, "searchInput", null);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Boolean),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Boolean])
], TransferToPage.prototype, "useAsModal", null);
TransferToPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-transfer-to',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/send/transfer-to/transfer-to.html"*/'<div class="card" *ngIf="filteredContactsList && filteredContactsList[0]">\n  <ion-item-divider>\n    <span class="title" translate>Transfer to Contact</span>\n  </ion-item-divider>\n  <ion-list>\n    <button ion-item *ngFor="let item of filteredContactsList" (click)="close(item)">\n      <ion-icon class="item-img" item-start>\n        <gravatar [name]="item.name" [width]="35" [height]="35" [email]="item.email"></gravatar>\n      </ion-icon>\n      <div class="item-title">{{item.name}}</div>\n    </button>\n    <button ion-item class="show-more" *ngIf="contactsShowMore" (click)="showMore()">\n      <span translate>Show all</span>\n    </button>\n  </ion-list>\n</div>\n\n<div *ngFor="let coin of availableCoins">\n  <div class="card" *ngIf="walletList[coin] && walletList[coin][0]">\n    <ion-item-divider class="title">\n      <span translate>Transfer to {{ getCoinName(coin) }} Wallet</span>\n    </ion-item-divider>\n\n    <ion-list>\n      <button ion-item class="button-item" *ngFor="let wallet of filteredWallets[0] ? filteredWallets : walletList[coin]" (click)="close(wallet)" [ngClass]="{\'wallet-disabled\': !wallet.isComplete || wallet.needsBackup}">\n        <img [ngClass]="{ testnet: wallet.network === \'testnet\' }" src="assets/img/currencies/{{wallet.coin}}.svg" class="icon-wallet" />\n        <span class="item-title">{{wallet.name}}</span>\n        <ion-note class="wallet-warning" *ngIf="!wallet.isComplete" item-end>\n          {{\'Incomplete\' | translate}}\n        </ion-note>\n        <ion-note class="wallet-warning" *ngIf="wallet.isComplete && wallet.needsBackup" item-end>\n          {{\'Needs Backup\' | translate}}\n        </ion-note>\n        <ion-note *ngIf="wallet.m > 1 && wallet.isComplete && !wallet.needsBackup" item-end>\n          {{wallet.m}}-{{wallet.n}}\n        </ion-note>\n      </button>\n    </ion-list>\n  </div>\n</div>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/send/transfer-to/transfer-to.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_address_address__["a" /* AddressProvider */]])
], TransferToPage);

//# sourceMappingURL=transfer-to.js.map

/***/ }),

/***/ 2006:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__buy_card_buy_card__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__buy_card_card_description_card_description__ = __webpack_require__(2007);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__card_details_card_details__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__card_details_printable_card_printable_card__ = __webpack_require__(989);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__card_details_redeem_instructions_redeem_instructions__ = __webpack_require__(2008);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__card_terms_card_terms__ = __webpack_require__(2009);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__confirm_card_purchase_confirm_card_purchase__ = __webpack_require__(468);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gift_card_settings_gift_card_settings__ = __webpack_require__(999);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gift_cards_settings_gift_cards_settings__ = __webpack_require__(998);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__home_gift_cards_home_gift_cards__ = __webpack_require__(2010);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__purchased_cards_purchased_cards__ = __webpack_require__(329);











const GIFT_CARD_PAGES = [
    __WEBPACK_IMPORTED_MODULE_0__buy_card_buy_card__["a" /* BuyCardPage */],
    __WEBPACK_IMPORTED_MODULE_1__buy_card_card_description_card_description__["a" /* CardDescriptionComponent */],
    __WEBPACK_IMPORTED_MODULE_2__card_details_card_details__["a" /* CardDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_5__card_terms_card_terms__["a" /* CardTermsComponent */],
    __WEBPACK_IMPORTED_MODULE_6__confirm_card_purchase_confirm_card_purchase__["a" /* ConfirmCardPurchasePage */],
    __WEBPACK_IMPORTED_MODULE_7__gift_card_settings_gift_card_settings__["a" /* GiftCardSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_8__gift_cards_settings_gift_cards_settings__["a" /* GiftCardsSettingsPage */],
    ...__WEBPACK_IMPORTED_MODULE_9__home_gift_cards_home_gift_cards__["a" /* HOME_GIFT_CARD_COMPONENTS */],
    __WEBPACK_IMPORTED_MODULE_3__card_details_printable_card_printable_card__["a" /* PrintableCardComponent */],
    ...__WEBPACK_IMPORTED_MODULE_10__purchased_cards_purchased_cards__["a" /* PURCHASED_CARDS_PAGE_COMPONENTS */],
    __WEBPACK_IMPORTED_MODULE_4__card_details_redeem_instructions_redeem_instructions__["a" /* RedeemInstructionsComponent */]
];
/* harmony export (immutable) */ __webpack_exports__["a"] = GIFT_CARD_PAGES;

//# sourceMappingURL=gift-cards.js.map

/***/ }),

/***/ 2007:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CardDescriptionComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let CardDescriptionComponent = class CardDescriptionComponent {
    prepForMarkdown(markdown) {
        return markdown && markdown.replace(//gm, '-');
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], CardDescriptionComponent.prototype, "cardConfig", void 0);
CardDescriptionComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'card-description',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/buy-card/card-description/card-description.html"*/'<div [ngSwitch]="cardConfig.name">\n  <div *ngSwitchCase="\'Amazon.com\'">\n    <div translate>Only redeemable on www.amazon.com (USA website)</div>\n    <div translate>Amazon.com Gift Cards never expire and can be redeemed towards millions of items at www.amazon.com.</div>\n  </div>\n  <div *ngSwitchCase="\'Amazon.co.jp\'">\n    <div translate>Only redeemable on www.amazon.co.jp (Japan website)</div>\n    <div translate>Amazon.co.jp Gift Cards never expire and can be redeemed towards millions of items at www.amazon.co.jp.</div>\n  </div>\n  <div *ngSwitchCase="\'Mercado Livre\'">\n    <div translate>Only redeemable on Mercado Livre (Brazil)</div>\n    <div translate>\n      You can use your Mercado Livre gift cards on your Mercado Pago account for everyday expenses like utilities and metro rides.\n    </div>\n  </div>\n  <div *ngSwitchDefault externalize-links>\n    <div markdown [data]="prepForMarkdown(cardConfig.description)"></div>\n  </div>\n</div>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/buy-card/card-description/card-description.html"*/
    })
], CardDescriptionComponent);

//# sourceMappingURL=card-description.js.map

/***/ }),

/***/ 2008:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RedeemInstructionsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let RedeemInstructionsComponent = class RedeemInstructionsComponent {
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], RedeemInstructionsComponent.prototype, "cardConfig", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], RedeemInstructionsComponent.prototype, "params", void 0);
RedeemInstructionsComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'redeem-instructions',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/card-details/redeem-instructions/redeem-instructions.html"*/'<span [ngSwitch]="cardConfig.name">\n  <span *ngSwitchDefault>\n    <span *ngIf="cardConfig.redeemInstructions" markdown [data]="cardConfig.redeemInstructions" externalize-links></span>\n    <span *ngIf="!cardConfig.redeemInstructions">\n      {{\'Paste this code on {cardConfig.website}. This gift card cannot be recovered if your claim code is lost.\' |\n      translate:params }}</span>\n  </span>\n</span>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/card-details/redeem-instructions/redeem-instructions.html"*/
    })
], RedeemInstructionsComponent);

//# sourceMappingURL=redeem-instructions.js.map

/***/ }),

/***/ 2009:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CardTermsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ngx_markdown__ = __webpack_require__(652);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ngx_markdown___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_ngx_markdown__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_gift_card_gift_card__ = __webpack_require__(86);




let CardTermsComponent = class CardTermsComponent {
    constructor(giftCardProvider) {
        this.giftCardProvider = giftCardProvider;
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.cardConfig = yield this.giftCardProvider.getCardConfig(this.cardName);
            const terms = this.cardConfig.terms;
            this.cardTerms =
                terms &&
                    linkifyTerms(terms)
                        .replace('Terms and Conditions', '')
                        .replace(/\n/gm, '')
                        .replace(/\*/gm, '&ast;')
                        .replace(/[ ]{5}/gm, '');
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2_ngx_markdown__["MarkdownComponent"]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2_ngx_markdown__["MarkdownComponent"])
], CardTermsComponent.prototype, "markdown", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], CardTermsComponent.prototype, "cardName", void 0);
CardTermsComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'card-terms',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/card-terms/card-terms.html"*/'<markdown ngPreserveWhitespaces class="terms" [data]="cardTerms" externalize-links></markdown>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/card-terms/card-terms.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_gift_card_gift_card__["a" /* GiftCardProvider */]])
], CardTermsComponent);

function linkifyUrl(url) {
    return `[${url}](https://${url})`;
}
function linkifyTerms(terms) {
    const urlRegex = /[\w\/\-\:]+\.[\w\/\-\:]+((\.[\w\/\-\:]+)?)+/gm;
    const allUrls = terms.match(urlRegex) || [];
    const urlsWithoutProtocol = allUrls.filter(m => m && !m.startsWith('http') && !m.startsWith('www.') && m.length > 3);
    const termsWithPlaceholders = urlsWithoutProtocol.reduce((newTerms, url, index) => newTerms.replace(url, getPlaceholder(index)), terms);
    const linkifiedTerms = urlsWithoutProtocol.reduce((newTerms, url, index) => newTerms.replace(getPlaceholder(index), linkifyUrl(url)), termsWithPlaceholders);
    return linkifiedTerms;
}
function getPlaceholder(index) {
    return `---${index}`;
}
//# sourceMappingURL=card-terms.js.map

/***/ }),

/***/ 2010:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export HomeGiftCards */
/* unused harmony export getPrimaryCatalogCurrency */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations__ = __webpack_require__(256);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_observable_timer__ = __webpack_require__(393);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_observable_timer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_observable_timer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_operators__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_operators___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_operators__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_gift_card_gift_card__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__buy_card_buy_card__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__card_catalog_card_catalog__ = __webpack_require__(1041);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__card_details_card_details__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__purchased_cards_purchased_cards__ = __webpack_require__(329);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__gift_card_item_gift_card_item__ = __webpack_require__(2011);













let HomeGiftCards = class HomeGiftCards {
    constructor(actionSheetProvider, appProvider, giftCardProvider, navCtrl, persistenceProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.appProvider = appProvider;
        this.giftCardProvider = giftCardProvider;
        this.navCtrl = navCtrl;
        this.persistenceProvider = persistenceProvider;
        this.hideDiscount = false;
        this.primaryCatalogCurrency = 'usd';
        this.disableArchiveAnimation = true; // Removes flicker on iOS when returning to home tab
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.appName = this.appProvider.info.userVisibleName;
            yield this.initGiftCards();
            const availableCards = yield this.giftCardProvider.getAvailableCards();
            this.primaryCatalogCurrency = getPrimaryCatalogCurrency(availableCards);
            this.discountedCard = availableCards.find(cardConfig => Object(__WEBPACK_IMPORTED_MODULE_7__providers_gift_card_gift_card__["e" /* hasVisibleDiscount */])(cardConfig));
            this.hideDiscount = yield this.persistenceProvider.getHideGiftCardDiscountItem();
            yield Object(__WEBPACK_IMPORTED_MODULE_4_rxjs_observable_timer__["timer"])(3000).toPromise();
            this.giftCardProvider.preloadImages();
        });
    }
    buyGiftCards() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__card_catalog_card_catalog__["a" /* CardCatalogPage */]);
    }
    buyCard(cardName, discountContext) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const cardConfig = yield this.giftCardProvider.getCardConfig(cardName);
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__buy_card_buy_card__["a" /* BuyCardPage */], { cardConfig });
            if (this.discountedCard && this.discountedCard.name === cardName) {
                this.logDiscountClick(discountContext);
            }
        });
    }
    logDiscountClick(context) {
        this.giftCardProvider.logEvent('clickedGiftCardDiscount', this.giftCardProvider.getDiscountEventParams(this.discountedCard, context));
    }
    onGiftCardAction(event, purchasedCards) {
        event.action === 'view'
            ? this.viewGiftCards(event.cardName, purchasedCards)
            : this.showArchiveSheet(event);
    }
    onPromoScrollIntoView(context) {
        this.giftCardProvider.logEvent('presentedWithGiftCardDiscount', this.giftCardProvider.getDiscountEventParams(this.discountedCard, context));
    }
    viewGiftCards(cardName, cards) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const activeCards = cards.filter(c => !c.archived);
            activeCards.length === 1
                ? this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__card_details_card_details__["a" /* CardDetailsPage */], { card: activeCards[0] })
                : this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__purchased_cards_purchased_cards__["b" /* PurchasedCardsPage */], { cardName });
        });
    }
    showArchiveSheet(event) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const brandCards = this.activeBrands
                .find(brandCards => brandCards[0].name === event.cardName)
                .filter(card => !card.archived);
            const sheetName = brandCards.length === 1 ? 'archive-gift-card' : 'archive-all-gift-cards';
            const cardConfig = yield this.giftCardProvider.getCardConfig(brandCards[0].name);
            const archiveSheet = this.actionSheetProvider.createInfoSheet(sheetName, {
                brand: cardConfig.displayName
            });
            archiveSheet.present();
            archiveSheet.onDidDismiss((confirm) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
                if (!confirm)
                    return;
                yield this.giftCardProvider.archiveAllCards(event.cardName);
            }));
        });
    }
    showHideDiscountItemSheet() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.slidingItem.close();
            const hideDiscountSheet = this.actionSheetProvider.createInfoSheet('hide-gift-card-discount-item');
            hideDiscountSheet.present();
            hideDiscountSheet.onDidDismiss((confirm) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
                if (!confirm)
                    return;
                this.disableArchiveAnimation = false;
                this.hideDiscount = true;
                yield this.giftCardProvider.hideDiscountItem();
            }));
        });
    }
    hideArchivedBrands() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.disableArchiveAnimation = false;
            const purchasedBrands = yield this.giftCardProvider.getPurchasedBrands();
            const { activeCardNames } = yield this.getActiveGiftCards(purchasedBrands);
            const filteredBrands = this.activeBrands.filter(cards => activeCardNames.indexOf(cards[0].name) > -1);
            filteredBrands.length === this.activeBrands.length
                ? this.loadGiftCards()
                : (this.activeBrands = filteredBrands);
        });
    }
    initGiftCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.loadGiftCards();
            this.giftCardProvider.cardUpdates$
                .pipe(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_operators__["debounceTime"])(300))
                .subscribe(card => card.archived ? this.hideArchivedBrands() : this.loadGiftCards());
        });
    }
    getActiveGiftCards(purchasedBrands) {
        const activeCards = purchasedBrands.filter(cards => cards.filter(c => !c.archived).length);
        const activeCardNames = activeCards.map(cards => cards[0].name);
        return { activeCards, activeCardNames };
    }
    updatePendingGiftCards(purchasedBrands) {
        const allCards = purchasedBrands.reduce((allCards, brandCards) => [...allCards, ...brandCards], []);
        this.giftCardProvider.updatePendingGiftCards(allCards);
    }
    loadGiftCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.disableArchiveAnimation = true;
            const activeCards = yield this.giftCardProvider.getActiveCards();
            const activeBrands = this.groupCardsByBrand(activeCards);
            this.updatePendingGiftCards(activeBrands);
            this.activeBrands = activeBrands;
        });
    }
    groupCardsByBrand(cards) {
        return cards
            .reduce((brands, c) => {
            const brandCards = brands.find(b => b[0].name === c.name);
            brandCards ? brandCards.push(c) : brands.push([c]);
            return brands;
        }, [])
            .sort((a, b) => Object(__WEBPACK_IMPORTED_MODULE_7__providers_gift_card_gift_card__["f" /* sortByDisplayName */])(a[0], b[0]));
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Input"])('scrollArea'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["e" /* Content */])
], HomeGiftCards.prototype, "scrollArea", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* ItemSliding */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* ItemSliding */])
], HomeGiftCards.prototype, "slidingItem", void 0);
HomeGiftCards = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Component"])({
        selector: 'gift-cards',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/home-gift-cards/home-gift-cards.html"*/'<ion-list [@.disabled]="disableArchiveAnimation">\n  <gift-card-item *ngFor="let brandCards of activeBrands" class="sliding-container" [cardName]="brandCards[0].name"\n    [giftCards]="brandCards" (action)="onGiftCardAction($event, brandCards)" [@archiveAnimation]></gift-card-item>\n  <ion-item-sliding class="card-item-sliding" #slidingItem\n    *ngIf="activeBrands?.length && !hideDiscount && discountedCard" scrolled-into-view [scrollArea]="scrollArea"\n    (viewEnter)="onPromoScrollIntoView(\'Home Gift Card List Discount Item\')" [@archiveAnimation]>\n    <button ion-item *ngIf="discountedCard" class="discount-item"\n      (click)="buyCard(discountedCard.name, \'Home Gift Card List Discount Item\')">\n      <img-loader class="logo" [src]="discountedCard.icon"></img-loader>\n      <div class="ellipsis">Save <gift-card-discount-text [cardConfig]="discountedCard"\n          [discount]="discountedCard.discounts[0]">\n        </gift-card-discount-text> off {{discountedCard.displayName}}</div>\n    </button>\n    <ion-item-options side="right">\n      <button ion-button color="danger" (click)="showHideDiscountItemSheet()">\n        <div class="archive__icon">\n          <ion-icon ios="md-close" md="md-close"></ion-icon>\n        </div>\n        <div class="archive__text">Hide?</div>\n      </button>\n    </ion-item-options>\n  </ion-item-sliding>\n  <div *ngIf="activeBrands?.length" [@archiveAnimation] class="add-card-button" (click)="buyGiftCards()" tappable\n    translate>Buy Gift Card</div>\n</ion-list>\n<action-card *ngIf="!activeBrands?.length" (click)="buyGiftCards()" tappable>\n  <div action-card-body>\n    <img class="gift-card-brands" src="assets/img/gift-cards/gift-cards-{{primaryCatalogCurrency}}.png">\n    <div class="discount-wrapper">\n      <div *ngIf="discountedCard" class="gift-card-featured-discount"\n        (click)="$event.stopPropagation(); buyCard(discountedCard.name, \'Home Buy Gift Cards Discount Label\')" tappable\n        scrolled-into-view [scrollArea]="scrollArea"\n        (viewEnter)="onPromoScrollIntoView(\'Home Buy Gift Cards Discount Label\')">\n        <img [src]="discountedCard.icon">\n        <div class="ellipsis">Save <gift-card-discount-text [cardConfig]="discountedCard"\n            [discount]="discountedCard.discounts[0]">\n          </gift-card-discount-text> off {{discountedCard.displayName}}</div>\n      </div>\n    </div>\n  </div>\n  <div action-card-button translate>\n    Buy Gift Cards\n  </div>\n</action-card>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/home-gift-cards/home-gift-cards.html"*/,
        animations: [
            Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* trigger */])('archiveAnimation', [
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["i" /* transition */])(':leave', [
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["h" /* style */])({
                        opacity: 1
                    }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["e" /* animate */])('400ms 0ms ease', Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["h" /* style */])({
                        opacity: 0,
                        marginTop: '-88px',
                        transform: 'translate3d(0, 88px, 0)'
                    }))
                ])
            ]),
            Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* trigger */])('preventInitialChildAnimations', [
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["i" /* transition */])(':enter', [Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["f" /* query */])(':enter', [], { optional: true })])
            ])
        ]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["g" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_gift_card_gift_card__["a" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers__["Q" /* PersistenceProvider */]])
], HomeGiftCards);

function getPrimaryCatalogCurrency(availableCards) {
    const homeLogoCollageSupportedCurrencies = ['cad', 'eur', 'gbp', 'usd'];
    const firstBrandCurrency = availableCards[0] && availableCards[0].currency.toLowerCase();
    return homeLogoCollageSupportedCurrencies.indexOf(firstBrandCurrency) > -1
        ? firstBrandCurrency
        : 'usd';
}
const HOME_GIFT_CARD_COMPONENTS = [HomeGiftCards, __WEBPACK_IMPORTED_MODULE_12__gift_card_item_gift_card_item__["a" /* GiftCardItem */]];
/* harmony export (immutable) */ __webpack_exports__["a"] = HOME_GIFT_CARD_COMPONENTS;

//# sourceMappingURL=home-gift-cards.js.map

/***/ }),

/***/ 2011:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GiftCardItem; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__ = __webpack_require__(86);





let GiftCardItem = class GiftCardItem {
    constructor(giftCardProvider, renderer) {
        this.giftCardProvider = giftCardProvider;
        this.renderer = renderer;
        this.giftCards = [];
        this.action = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
    }
    ngAfterViewInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.cardName && this.setBrandStyling();
            this.currentCards = this.giftCards.filter(g => !g.archived);
            this.currency = this.currentCards[0].currency;
            this.numCurrencies = getNumCurrencies(this.currentCards);
            this.totalBalance = this.currentCards.reduce((sum, card) => sum + card.amount, 0);
        });
    }
    performAction(action) {
        this.action.emit({
            cardName: this.cardName,
            action
        });
        this.slidingItem.close();
    }
    shouldShowTotalBalance() {
        return this.cardConfig && this.numCurrencies === 1 && this.totalBalance;
    }
    setBrandStyling() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.cardConfig = yield this.giftCardProvider.getCardConfig(this.cardName);
            const isGradient = this.cardConfig.logoBackgroundColor.indexOf('gradient') > -1;
            const cssProperty = isGradient ? 'background-image' : 'background-color';
            this.renderer.setElementStyle(this.item.getNativeElement(), cssProperty, this.cardConfig.logoBackgroundColor);
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], GiftCardItem.prototype, "cardName", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Array)
], GiftCardItem.prototype, "giftCards", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"])
], GiftCardItem.prototype, "action", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* Item */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* Item */])
], GiftCardItem.prototype, "item", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* ItemSliding */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* ItemSliding */])
], GiftCardItem.prototype, "slidingItem", void 0);
GiftCardItem = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'gift-card-item',
        template: `
    <ion-item-sliding class="card-item-sliding" #slidingItem>
      <button ion-item (click)="performAction('view')">
        <img-loader class="logo" [src]="cardConfig?.logo"></img-loader>
        <ion-note
          item-end
          [ngClass]="{ dark: cardConfig?.logoBackgroundColor === '#ffffff' }"
          *ngIf="shouldShowTotalBalance()"
        >
          {{ totalBalance | formatCurrency: currency }}
        </ion-note>
      </button>
      <ion-item-options side="right">
        <button ion-button (click)="performAction('archive')" color="danger">
          <div class="archive__icon">
            <ion-icon ios="md-close" md="md-close"></ion-icon>
          </div>
          <div class="archive__text">Archive?</div>
        </button>
      </ion-item-options>
    </ion-item-sliding>
  `
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__["a" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["Renderer"]])
], GiftCardItem);

function getNumCurrencies(cards) {
    const currencies = cards.map(c => c.currency);
    const uniqueCurrencies = __WEBPACK_IMPORTED_MODULE_3_lodash__["uniq"](currencies);
    return uniqueCurrencies.length;
}
//# sourceMappingURL=gift-card-item.js.map

/***/ }),

/***/ 2012:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FiatToUnitPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_rate_rate__ = __webpack_require__(145);






let FiatToUnitPipe = class FiatToUnitPipe {
    constructor(configProvider, currencyProvider, rateProvider, decimalPipe) {
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.rateProvider = rateProvider;
        this.decimalPipe = decimalPipe;
        this.walletSettings = this.configProvider.get().wallet.settings;
    }
    transform(amount, coin, alternative) {
        alternative = alternative
            ? alternative
            : this.walletSettings.alternativeIsoCode;
        let amount_ = this.rateProvider.fromFiat(amount, alternative, coin);
        return (this.decimalPipe.transform(amount_ / this.currencyProvider.getPrecision(coin).unitToSatoshi || 0, '1.2-8') +
            ' ' +
            coin.toUpperCase());
    }
};
FiatToUnitPipe = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Pipe"])({
        name: 'fiatToUnit',
        pure: false
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_common__["d" /* DecimalPipe */]])
], FiatToUnitPipe);

//# sourceMappingURL=fiatToUnit.js.map

/***/ }),

/***/ 2013:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeysPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/*
 * Example use
 *  Simple: *ngFor="let item of giftCards | keys"
 *	With an object with objects: *ngFor="let item of (itemsObject | keys : 'date') | orderBy : ['-order']"
 */


let KeysPipe = class KeysPipe {
    transform(value, orderBy) {
        let keys = [];
        for (let key in value) {
            keys.push({
                key,
                value: value[key],
                order: orderBy ? value[key][orderBy] : null
            });
        }
        return keys;
    }
};
KeysPipe = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Pipe"])({
        name: 'keys'
    })
], KeysPipe);

//# sourceMappingURL=keys.js.map

/***/ }),

/***/ 2014:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OrderByPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/*
 * Example use
 *		Basic Array of single type: *ngFor="#todo of todoService.todos | orderBy : '-'"
 *		Multidimensional Array Sort on single column: *ngFor="#todo of todoService.todos | orderBy : ['-status']"
 *		Multidimensional Array Sort on multiple columns: *ngFor="#todo of todoService.todos | orderBy : ['status', '-title']"
 *    With an object with objects: *ngFor="let item of (itemsObject | keys : 'date') | orderBy : ['-order']"
 */


let OrderByPipe = OrderByPipe_1 = class OrderByPipe {
    static _orderByComparator(a, b) {
        if (isNaN(parseFloat(a)) ||
            !isFinite(a) ||
            (isNaN(parseFloat(b)) || !isFinite(b))) {
            // Isn't a number so lowercase the string to properly compare
            if (a.toLowerCase() < b.toLowerCase())
                return -1;
            if (a.toLowerCase() > b.toLowerCase())
                return 1;
        }
        else {
            // Parse strings as numbers to compare properly
            if (parseFloat(a) < parseFloat(b))
                return -1;
            if (parseFloat(a) > parseFloat(b))
                return 1;
        }
        return 0; // equal each other
    }
    transform(input, [config = '+']) {
        if (!Array.isArray(input))
            return input;
        if (!Array.isArray(config) ||
            (Array.isArray(config) && config.length == 1)) {
            var propertyToCheck = !Array.isArray(config) ? config : config[0];
            var desc = propertyToCheck.substr(0, 1) == '-';
            // Basic array
            if (!propertyToCheck ||
                propertyToCheck == '-' ||
                propertyToCheck == '+') {
                return !desc ? input.sort() : input.sort().reverse();
            }
            else {
                var property = propertyToCheck.substr(0, 1) == '+' ||
                    propertyToCheck.substr(0, 1) == '-'
                    ? propertyToCheck.substr(1)
                    : propertyToCheck;
                return input.sort((a, b) => {
                    return !desc
                        ? OrderByPipe_1._orderByComparator(a[property], b[property])
                        : -OrderByPipe_1._orderByComparator(a[property], b[property]);
                });
            }
        }
        else {
            // Loop over property of the array in order and sort
            return input.sort((a, b) => {
                for (var i = 0; i < config.length; i++) {
                    var desc = config[i].substr(0, 1) == '-';
                    var property = config[i].substr(0, 1) == '+' || config[i].substr(0, 1) == '-'
                        ? config[i].substr(1)
                        : config[i];
                    var comparison = !desc
                        ? OrderByPipe_1._orderByComparator(a[property], b[property])
                        : -OrderByPipe_1._orderByComparator(a[property], b[property]);
                    // Don't return 0 yet in case of needing to sort by next property
                    if (comparison != 0)
                        return comparison;
                }
                return 0; // equal each other
            });
        }
    }
};
OrderByPipe = OrderByPipe_1 = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Pipe"])({
        name: 'orderBy',
        pure: false
    })
], OrderByPipe);

var OrderByPipe_1;
//# sourceMappingURL=order-by.js.map

/***/ }),

/***/ 2015:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SatToFiatPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_rate_rate__ = __webpack_require__(145);





let SatToFiatPipe = class SatToFiatPipe {
    constructor(configProvider, rateProvider, decimalPipe) {
        this.configProvider = configProvider;
        this.rateProvider = rateProvider;
        this.decimalPipe = decimalPipe;
        this.walletSettings = this.configProvider.get().wallet.settings;
    }
    transform(amount, coin) {
        let amount_ = this.rateProvider.toFiat(amount, this.walletSettings.alternativeIsoCode, coin.toLowerCase());
        return (this.decimalPipe.transform(amount_ || 0, '1.2-2') +
            ' ' +
            this.walletSettings.alternativeIsoCode);
    }
};
SatToFiatPipe = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Pipe"])({
        name: 'satToFiat',
        pure: false
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_common__["d" /* DecimalPipe */]])
], SatToFiatPipe);

//# sourceMappingURL=satToFiat.js.map

/***/ }),

/***/ 2016:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SatToUnitPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_currency_currency__ = __webpack_require__(25);




let SatToUnitPipe = class SatToUnitPipe {
    constructor(decimalPipe, currencyProvider) {
        this.decimalPipe = decimalPipe;
        this.currencyProvider = currencyProvider;
    }
    transform(amount, coin) {
        const { unitToSatoshi } = this.currencyProvider.getPrecision(coin);
        return (this.decimalPipe.transform(amount / unitToSatoshi, '1.2-6') +
            ' ' +
            coin.toUpperCase());
    }
};
SatToUnitPipe = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Pipe"])({
        name: 'satToUnit',
        pure: false
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common__["d" /* DecimalPipe */],
        __WEBPACK_IMPORTED_MODULE_3__providers_currency_currency__["b" /* CurrencyProvider */]])
], SatToUnitPipe);

//# sourceMappingURL=satToUnit.js.map

/***/ }),

/***/ 2017:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CopyToClipboard; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_clipboard_clipboard__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(12);





// providers




let CopyToClipboard = class CopyToClipboard {
    constructor(dom, clipboard, platform, logger, translate, actionSheetProvider, clipboardProvider) {
        this.clipboard = clipboard;
        this.platform = platform;
        this.logger = logger;
        this.translate = translate;
        this.actionSheetProvider = actionSheetProvider;
        this.clipboardProvider = clipboardProvider;
        this.dom = dom;
    }
    copyBrowser() {
        let textarea = this.dom.createElement('textarea');
        this.dom.body.appendChild(textarea);
        textarea.value = this.value;
        textarea.select();
        this.dom.execCommand('copy');
        this.dom.body.removeChild(textarea);
    }
    copy() {
        if (!this.value)
            return;
        try {
            this.clipboardProvider.copy(this.value);
        }
        catch (e) {
            if (e)
                this.logger.warn(e.message);
            this.copyBrowser();
        }
        if (this.hideToast)
            return;
        const infoSheet = this.actionSheetProvider.createInfoSheet('copy-to-clipboard', { msg: this.value });
        infoSheet.present();
    }
};
CopyToClipboard = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[copy-to-clipboard]',
        inputs: ['value: copy-to-clipboard', 'hideToast: hide-toast'],
        host: {
            '(click)': 'copy()'
        }
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["g" /* __param */](0, Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"])(__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["b" /* DOCUMENT */])),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [Document,
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__["a" /* Clipboard */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_clipboard_clipboard__["a" /* ClipboardProvider */]])
], CopyToClipboard);

//# sourceMappingURL=copy-to-clipboard.js.map

/***/ }),

/***/ 2018:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExternalizeLinks; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers__ = __webpack_require__(35);




let ExternalizeLinks = class ExternalizeLinks {
    constructor(element, externalLinkProvider) {
        this.element = element;
        this.externalLinkProvider = externalLinkProvider;
    }
    ngAfterViewInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield __WEBPACK_IMPORTED_MODULE_2_rxjs__["Observable"].timer(500).toPromise();
            this.getAllLinks().forEach(aTag => aTag.addEventListener('click', this.handleClick.bind(this)));
        });
    }
    ngOnDestroy() {
        this.getAllLinks().forEach(aTag => {
            aTag.removeEventListener('click', this.handleClick.bind(this));
        });
    }
    getAllLinks() {
        return this.element.nativeElement.querySelectorAll('a');
    }
    handleClick(event) {
        event.preventDefault();
        this.openExternalLink(event.srcElement.href);
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
ExternalizeLinks = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[externalize-links]'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"],
        __WEBPACK_IMPORTED_MODULE_3__providers__["y" /* ExternalLinkProvider */]])
], ExternalizeLinks);

//# sourceMappingURL=externalize-links.js.map

/***/ }),

/***/ 2019:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FixedScrollBgColor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


/*
Sometimes the user can overshoot when scrolling, which can cause gaps to appear between
elements if colors are not properly set on the fixed and scroll containers to match the colors
of surrounding elements. This directive sets the proper bg-color on the fixed and scroll containers
to create the illusion of smooth, fluid, and connected elements.
*/
let FixedScrollBgColor = class FixedScrollBgColor {
    constructor(element) {
        this.element = element;
        this.bottomColor = '#f8f8f9';
    }
    ngOnChanges() {
        this.setFixedAndScrollContentBgColor(this.color);
    }
    setFixedAndScrollContentBgColor(color) {
        const scrollContent = this.element.nativeElement.getElementsByClassName('scroll-content')[0];
        const fixedContent = this.element.nativeElement.getElementsByClassName('fixed-content')[0];
        const linearGradient = `linear-gradient(to bottom, ${this.color}, ${this.color} 50%, ${this.bottomColor} 50%, ${this.bottomColor} 50%, ${this.bottomColor} 50%)`;
        if (color) {
            scrollContent.style.setProperty('background-image', linearGradient);
            fixedContent.style.setProperty('background-image', linearGradient);
        }
        else {
            scrollContent.style.removeProperty('background-image');
            fixedContent.style.removeProperty('background-image');
        }
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])('fixed-scroll-bg-color'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], FixedScrollBgColor.prototype, "color", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], FixedScrollBgColor.prototype, "bottomColor", void 0);
FixedScrollBgColor = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[fixed-scroll-bg-color]',
        host: { class: 'fixed-scroll-bg-color' }
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"]])
], FixedScrollBgColor);

//# sourceMappingURL=fixed-scroll-bg-color.js.map

/***/ }),

/***/ 2020:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IonContentBackgroundColor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app_app__ = __webpack_require__(28);



let IonContentBackgroundColor = class IonContentBackgroundColor {
    constructor(element, app) {
        this.element = element;
        this.app = app;
    }
    ngOnChanges() {
        this.setContentBackgroundColor(this.color);
    }
    setContentBackgroundColor(color) {
        const ionContent = this.element.nativeElement.getElementsByClassName('fixed-content')[0];
        if (color)
            ionContent.style.setProperty('background-color', color);
        else {
            const color = this.app.info.nameCase == 'Copay' ? '#192c3a' : '#2a3f90';
            ionContent.style.setProperty('background-color', color);
        }
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])('ion-content-background-color'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], IonContentBackgroundColor.prototype, "color", void 0);
IonContentBackgroundColor = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[ion-content-background-color]',
        host: { class: 'ion-content-background-color' }
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"], __WEBPACK_IMPORTED_MODULE_2__providers_app_app__["a" /* AppProvider */]])
], IonContentBackgroundColor);

//# sourceMappingURL=ion-content-background-color.js.map

/***/ }),

/***/ 2021:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LongPress; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular_gestures_gesture__ = __webpack_require__(569);



let LongPress = class LongPress {
    constructor(el) {
        this.longPress = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
        this.el = el.nativeElement;
    }
    ngOnInit() {
        this.pressGesture = new __WEBPACK_IMPORTED_MODULE_2_ionic_angular_gestures_gesture__["a" /* Gesture */](this.el, {
            recognizers: [[Hammer.Press, { time: 1000 }]]
        });
        this.pressGesture.listen();
        this.pressGesture.on('press', e => {
            this.longPress.emit(e);
        });
    }
    ngOnDestroy() {
        this.pressGesture.destroy();
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"])
], LongPress.prototype, "longPress", void 0);
LongPress = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[longPress]'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"]])
], LongPress);

//# sourceMappingURL=long-press.js.map

/***/ }),

/***/ 2022:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NavbarBg; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


/*
Ionic does not currently appear to provide an API to set the navbar background
to an arbitrary color. This directive enables this functionality.
*/
let NavbarBg = class NavbarBg {
    constructor(element) {
        this.element = element;
    }
    ngOnChanges() {
        this.setNewNavbarColor(this.color);
    }
    setNewNavbarColor(color) {
        const toolbarBg = this.element.nativeElement.getElementsByClassName('toolbar-background')[0];
        color
            ? toolbarBg.style.setProperty('background', color, 'important')
            : toolbarBg.style.removeProperty('background');
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])('navbar-bg'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], NavbarBg.prototype, "color", void 0);
NavbarBg = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[navbar-bg]'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"]])
], NavbarBg);

//# sourceMappingURL=navbar-bg.js.map

/***/ }),

/***/ 2023:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NoLowFee; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_popup_popup__ = __webpack_require__(18);




// Provider


let NoLowFee = class NoLowFee {
    constructor(configProvider, elem, logger, navCtrl, popupProvider) {
        this.configProvider = configProvider;
        this.elem = elem;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.logger.debug('NoLowFee Directive initialized');
        this.configWallet = this.configProvider.get().wallet;
    }
    noLowFee() {
        if (this.configWallet.settings.feeLevel &&
            this.configWallet.settings.feeLevel.match(/conomy/)) {
            this.logger.debug('Economy Fee setting... disabling link:' +
                this.elem.nativeElement.innerText);
            this.popupProvider
                .ionicAlert('Low Fee Error', 'Please change your Bitcoin Network Fee Policy setting to Normal or higher to use this service')
                .then(() => {
                this.navCtrl.pop();
            });
        }
    }
};
NoLowFee = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[no-low-fee]',
        host: {
            '(click)': 'noLowFee()'
        }
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_popup_popup__["a" /* PopupProvider */]])
], NoLowFee);

//# sourceMappingURL=no-low-fee.js.map

/***/ }),

/***/ 2024:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RevealAtScrollPosition; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);



let RevealAtScrollPosition = class RevealAtScrollPosition {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.scrollPositionOfLastStyleUpdate = 0;
        this.animationDistance = 28;
    }
    ngAfterViewInit() {
        this.setInitialStyles();
        this.scrollArea.ionScroll.subscribe(event => this.shouldUpdateStyling(event.scrollTop) &&
            this.updateStyling(event.scrollTop));
    }
    shouldUpdateStyling(scrollTop) {
        return (scrollTop < this.scrollThreshold ||
            (scrollTop > this.scrollThreshold &&
                this.scrollPositionOfLastStyleUpdate < this.scrollThreshold));
    }
    setInitialStyles() {
        this.setOpacity(0);
        this.renderer.setElementClass(this.element.nativeElement, 'ellipsis', true);
    }
    updateStyling(scrollTop) {
        const opacity = this.getOpacity(scrollTop);
        const translateX = this.getTranslation(scrollTop);
        this.setOpacity(opacity);
        this.setTransform(translateX);
        this.scrollPositionOfLastStyleUpdate = scrollTop;
    }
    setOpacity(opacity) {
        this.renderer.setElementStyle(this.element.nativeElement, 'opacity', opacity.toFixed(3));
    }
    setTransform(translateX) {
        this.renderer.setElementStyle(this.element.nativeElement, 'transform', `translateX(${translateX}px)`);
    }
    getOpacity(scrollTop) {
        const finalOpacity = 1;
        const fadeStartPosition = this.scrollThreshold - this.animationDistance;
        const m = finalOpacity / (this.scrollThreshold - fadeStartPosition);
        const opacity = m * (scrollTop - this.scrollThreshold) + finalOpacity;
        return opacity;
    }
    getTranslation(scrollTop) {
        /*
        point-slope-form
        y-y1 = m(x-x1)
        y = m(x-x1) + y1
          where m = (y2 - y1) / (x2 - x1)
    
        initialTranslateX = -10
        finalTranslateX = 0
        p1 = (scrollThreshold, finalTranslateX)
        p2 = (animationStartPos, initialTranslateX)
        */
        const initialTranslateX = -10;
        const finalTranslateX = 0;
        const animationStartPos = this.scrollThreshold - this.animationDistance;
        const m = (initialTranslateX - finalTranslateX) /
            (animationStartPos - this.scrollThreshold);
        const translateX = m * (scrollTop - this.scrollThreshold) + 0;
        return translateX > 0 ? 0 : translateX;
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])('reveal-at-scroll-pos'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Number)
], RevealAtScrollPosition.prototype, "scrollThreshold", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])('scrollArea'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Content */])
], RevealAtScrollPosition.prototype, "scrollArea", void 0);
RevealAtScrollPosition = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[reveal-at-scroll-pos]'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"], __WEBPACK_IMPORTED_MODULE_1__angular_core__["Renderer"]])
], RevealAtScrollPosition);

//# sourceMappingURL=reveal-at-scroll-pos.js.map

/***/ }),

/***/ 2025:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ScrolledIntoView; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);



let ScrolledIntoView = class ScrolledIntoView {
    constructor(elm) {
        this.elm = elm;
        this.inView = false;
        this.viewEnter = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
    }
    ngAfterViewInit() {
        this.checkIfElementInView();
        this.scrollArea.ionScroll.subscribe(() => this.checkIfElementInView());
    }
    checkIfElementInView() {
        const scanButtonAreaHeight = 70;
        const { scrollTop, contentHeight } = this.scrollArea;
        const { offsetTop, offsetHeight } = this.elm.nativeElement;
        if (scrollTop + contentHeight - scanButtonAreaHeight >
            offsetTop + offsetHeight) {
            if (this.inView)
                return;
            this.viewEnter.emit(true);
            this.inView = true;
        }
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])('scrollArea'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Content */])
], ScrolledIntoView.prototype, "scrollArea", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"])
], ScrolledIntoView.prototype, "viewEnter", void 0);
ScrolledIntoView = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[scrolled-into-view]'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"]])
], ScrolledIntoView);

//# sourceMappingURL=scrolled-into-view.js.map

/***/ }),

/***/ 2026:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WideHeaderBarButton; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers__ = __webpack_require__(35);



let WideHeaderBarButton = class WideHeaderBarButton {
    constructor(element, platformProvider, renderer) {
        this.element = element;
        this.platformProvider = platformProvider;
        this.renderer = renderer;
        this.platformName = 'md';
        this.platformName = this.platformProvider.isIOS ? 'ios' : 'md';
    }
    ngAfterViewInit() {
        const cssClasses = [
            'bar-button',
            `bar-button-${this.platformName}`,
            'bar-button-default',
            `bar-button-default-${this.platformName}`
        ];
        cssClasses.forEach(c => this.addClass(c));
    }
    addClass(cssClass) {
        this.renderer.setElementClass(this.element.nativeElement, cssClass, true);
    }
};
WideHeaderBarButton = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[wide-header-bar-button]'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"],
        __WEBPACK_IMPORTED_MODULE_2__providers__["R" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["Renderer"]])
], WideHeaderBarButton);

//# sourceMappingURL=wide-header-bar-button.js.map

/***/ }),

/***/ 2027:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pages_home_wallets_wallet_item_content_component__ = __webpack_require__(2028);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__action_card_action_card__ = __webpack_require__(2029);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__action_sheets__ = __webpack_require__(2030);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__amount_picker_amount_picker__ = __webpack_require__(2031);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__clipboard_card_clipboard_card__ = __webpack_require__(2032);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__expandable_header_expandable_header__ = __webpack_require__(2033);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gift_card_discount_text_gift_card_discount_text__ = __webpack_require__(2034);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__label_tip_label_tip__ = __webpack_require__(2035);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__price_card_price_card__ = __webpack_require__(2036);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__price_card_price_chart_price_chart__ = __webpack_require__(2037);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__search_bar_search_bar__ = __webpack_require__(2039);











const COMPONENTS = [
    __WEBPACK_IMPORTED_MODULE_1__action_card_action_card__["a" /* ActionCardComponent */],
    __WEBPACK_IMPORTED_MODULE_2__action_sheets__["a" /* ACTION_SHEET_COMPONENTS */],
    __WEBPACK_IMPORTED_MODULE_3__amount_picker_amount_picker__["a" /* AmountPickerComponent */],
    __WEBPACK_IMPORTED_MODULE_5__expandable_header_expandable_header__["a" /* EXPANDABLE_HEADER_COMPONENTS */],
    __WEBPACK_IMPORTED_MODULE_6__gift_card_discount_text_gift_card_discount_text__["a" /* GiftCardDiscountText */],
    __WEBPACK_IMPORTED_MODULE_7__label_tip_label_tip__["a" /* LabelTip */],
    __WEBPACK_IMPORTED_MODULE_0__pages_home_wallets_wallet_item_content_component__["a" /* WalletItemContent */],
    __WEBPACK_IMPORTED_MODULE_4__clipboard_card_clipboard_card__["a" /* ClipboardCardPage */],
    __WEBPACK_IMPORTED_MODULE_10__search_bar_search_bar__["a" /* SearchBarComponent */],
    __WEBPACK_IMPORTED_MODULE_8__price_card_price_card__["a" /* PriceCard */],
    __WEBPACK_IMPORTED_MODULE_9__price_card_price_chart_price_chart__["a" /* PriceChart */]
];
/* harmony export (immutable) */ __webpack_exports__["a"] = COMPONENTS;

//# sourceMappingURL=components.js.map

/***/ }),

/***/ 2028:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletItemContent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let WalletItemContent = class WalletItemContent {
    getBalance(wallet, currency) {
        const lastKnownBalance = this.getLastKownBalance(wallet, currency);
        const availableBalanceStr = wallet.cachedStatus &&
            wallet.cachedStatus.availableBalanceStr &&
            wallet.cachedStatus.availableBalanceStr.replace(` ${currency}`, '');
        return availableBalanceStr || lastKnownBalance;
    }
    getLastKownBalance(wallet, currency) {
        return (wallet.lastKnownBalance &&
            wallet.lastKnownBalance.replace(` ${currency}`, ''));
    }
    hasZeroBalance(wallet, currency) {
        return ((wallet.cachedStatus && wallet.cachedStatus.availableBalanceSat === 0) ||
            this.getLastKownBalance(wallet, currency) === '0.00');
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], WalletItemContent.prototype, "wallet", void 0);
WalletItemContent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'wallet-item-content',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/home/wallets/wallet-item-content.component.html"*/'<img class="icon-wallet" [ngClass]="{ testnet: wallet.network === \'testnet\' }"\n  src="assets/img/currencies/{{wallet.coin}}.svg" />\n<div class="wallet-item-content__left ellipsis">\n  <div class="wallet-item-content__name ellipsis">{{ wallet.name }}</div>\n  <div class="wallet-item-content__credentials">\n    <span>{{ wallet.coin.toUpperCase() }} <span\n        *ngIf="wallet.credentials.n > 1">({{ wallet.credentials.m }}/{{ wallet.credentials.n }})</span></span>\n    <span *ngIf="!wallet.isComplete()"> - {{ \'Incomplete\' | translate }}</span>\n  </div>\n</div>\n<div class="wallet-item-content__right">\n  <div *ngIf="!hasZeroBalance(wallet, wallet.coin.toUpperCase()) && !wallet.balanceHidden">\n    <div class="wallet-item-content__amount">{{ getBalance(wallet, wallet.coin.toUpperCase()) }}</div>\n    <div class="wallet-item-content__fiat" *ngIf="wallet.cachedStatus">\n      {{ wallet?.cachedStatus.availableBalanceAlternative }}\n      {{ wallet?.cachedStatus.alternativeIsoCode }}\n    </div>\n  </div>\n  <div *ngIf="hasZeroBalance(wallet, wallet.coin.toUpperCase()) && !wallet.balanceHidden">\n    <div class="wallet-item-content__amount">0</div>\n    <div class="wallet-item-content__fiat" *ngIf="wallet.cachedStatus">\n      0 {{ wallet?.cachedStatus.alternativeIsoCode }}\n    </div>\n  </div>\n  <div *ngIf="wallet.balanceHidden">\n    [<span translate>Hidden</span>]\n  </div>\n</div>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/home/wallets/wallet-item-content.component.html"*/
    })
], WalletItemContent);

//# sourceMappingURL=wallet-item-content.component.js.map

/***/ }),

/***/ 2029:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActionCardComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let ActionCardComponent = class ActionCardComponent {
};
ActionCardComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        host: { class: 'card' },
        selector: 'action-card',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/action-card/action-card.html"*/'<div class="action-card__header">\n  <ng-content select="[action-card-header]"></ng-content>\n</div>\n<div class="action-card__content">\n  <div class="action-card__title">\n    <ng-content select="[action-card-title]"></ng-content>\n  </div>\n  <div class="action-card__body">\n    <ng-content select="[action-card-body]"></ng-content>\n  </div>\n  <div action-card-button class="action-card__cta">\n    <ng-content select="[action-card-button]"></ng-content>\n  </div>\n</div>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/action-card/action-card.html"*/
    })
], ActionCardComponent);

//# sourceMappingURL=action-card.js.map

/***/ }),

/***/ 2030:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__action_sheet_action_sheet__ = __webpack_require__(855);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__incoming_data_menu_incoming_data_menu__ = __webpack_require__(854);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__info_sheet_info_sheet__ = __webpack_require__(856);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__options_sheet_options_sheet__ = __webpack_require__(858);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__wallet_selector_wallet_selector__ = __webpack_require__(859);





const ACTION_SHEET_COMPONENTS = [
    __WEBPACK_IMPORTED_MODULE_0__action_sheet_action_sheet__["a" /* ActionSheetComponent */],
    __WEBPACK_IMPORTED_MODULE_2__info_sheet_info_sheet__["a" /* INFO_SHEET_COMPONENTS */],
    __WEBPACK_IMPORTED_MODULE_3__options_sheet_options_sheet__["a" /* OptionsSheetComponent */],
    __WEBPACK_IMPORTED_MODULE_1__incoming_data_menu_incoming_data_menu__["a" /* IncomingDataMenuComponent */],
    __WEBPACK_IMPORTED_MODULE_4__wallet_selector_wallet_selector__["a" /* WalletSelectorComponent */]
];
/* harmony export (immutable) */ __webpack_exports__["a"] = ACTION_SHEET_COMPONENTS;

//# sourceMappingURL=action-sheets.js.map

/***/ }),

/***/ 2031:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AmountPickerComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let AmountPickerComponent = class AmountPickerComponent {
    constructor() {
        this.amountChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
    }
    ngOnInit() {
        this.amountIndex = getMiddleIndex(this.supportedAmounts);
        this.getAmount() && this.amountChange.emit(this.getAmount());
    }
    getAmount() {
        return ((this.supportedAmounts && this.supportedAmounts[this.amountIndex]) || 0);
    }
    shouldShowButton(value) {
        return (this.supportedAmounts && this.supportedAmounts[this.amountIndex + value]);
    }
    changeAmount(indexValue) {
        this.amountIndex = this.amountIndex + indexValue;
        this.amountChange.emit(this.getAmount());
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], AmountPickerComponent.prototype, "currency", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Array)
], AmountPickerComponent.prototype, "supportedAmounts", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"])
], AmountPickerComponent.prototype, "amountChange", void 0);
AmountPickerComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'amount-picker',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/amount-picker/amount-picker.html"*/'<div class="amount-picker__picker">\n  <div [ngClass]="{\'hidden\': !shouldShowButton(-1)}" class="amount-picker__button" (click)="changeAmount(-1)" tappable>\n    <img src="assets/img/icon-minus.svg">\n  </div>\n  <div class="amount-picker__amount">\n    <span *ngFor="let amount of supportedAmounts">\n      <span *ngIf="amount === getAmount()">{{amount | formatCurrency:currency:\'minimal\'}}</span>\n    </span>\n    <span *ngIf="!supportedAmounts">{{0 | formatCurrency:currency:0}}</span>\n  </div>\n  <div [ngClass]="{\'hidden\': !shouldShowButton(1)}" class="amount-picker__button" (click)="changeAmount(1)" tappable>\n    <img src="assets/img/icon-plus.svg">\n  </div>\n</div>\n<div class="amount-picker__values" *ngIf="supportedAmounts && supportedAmounts.length > 1">\n  <div>Purchase Amounts:</div>\n  <div><span\n      *ngFor="let amount of supportedAmounts; let last = last">{{amount | formatCurrency:currency:\'minimal\'}}<span\n        *ngIf="!last">,</span>\n    </span></div>\n</div>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/amount-picker/amount-picker.html"*/
    })
], AmountPickerComponent);

function getMiddleIndex(arr) {
    return arr && Math.floor(arr.length / 2);
}
//# sourceMappingURL=amount-picker.js.map

/***/ }),

/***/ 2032:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClipboardCardPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let ClipboardCardPage = class ClipboardCardPage {
    constructor() { }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], ClipboardCardPage.prototype, "validDataFromClipboard", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], ClipboardCardPage.prototype, "payProDetailsData", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], ClipboardCardPage.prototype, "remainingTimeStr", void 0);
ClipboardCardPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-clipboard-card',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/clipboard-card/clipboard-card.html"*/'<button ion-item detail-none class="clipboard-paypro-container"\n  *ngIf="validDataFromClipboard.type === \'PayPro\' || validDataFromClipboard.type === \'InvoiceUri\'">\n  <div *ngIf="payProDetailsData && !payProDetailsData.error" class="item-title">\n    <span translate>Payment request</span>\n  </div>\n  <div *ngIf="payProDetailsData && payProDetailsData.host && !payProDetailsData.error" class="item-subtitle">\n    <span translate>From</span>:\n    <ion-icon *ngIf="payProDetailsData?.verified" name="lock" color="success"></ion-icon>\n    <ion-icon *ngIf="!payProDetailsData?.verified" name="unlock" color="danger"></ion-icon>\n    {{payProDetailsData?.host}}\n  </div>\n  <ion-note *ngIf="payProDetailsData && !payProDetailsData.error" item-right>\n    <div *ngIf="!payProDetailsData?.isFiat" class="amount">\n      {{payProDetailsData?.amount | satToUnit: payProDetailsData?.coin}}\n    </div>\n    <div *ngIf="payProDetailsData?.isFiat" class="amount">\n      {{payProDetailsData?.amount | formatCurrency: payProDetailsData?.coin}}\n    </div>\n    <span [ngStyle]="remainingTimeStr === \'Expired\' ? { color: \'red\' } : {}" class="date">{{ remainingTimeStr }}</span>\n  </ion-note>\n  <div *ngIf="payProDetailsData && payProDetailsData.error" class="item-title">\n    {{payProDetailsData?.error}}\n  </div>\n  <div *ngIf="!payProDetailsData" class=\'loader gradient\'></div>\n  <div *ngIf="!payProDetailsData" class=\'loader loader-subtitle gradient\'></div>\n</button>\n<button ion-item detail-none class="clipboard"\n  *ngIf="validDataFromClipboard.type !== \'PayPro\' && validDataFromClipboard.type !== \'InvoiceUri\'">\n  <img\n    *ngIf="validDataFromClipboard.type === \'BitcoinUri\' || validDataFromClipboard.type === \'BitcoinCashUri\' || validDataFromClipboard.type === \'BitcoinAddress\' || validDataFromClipboard.type === \'BitcoinCashAddress\'"\n    alt="Coin"\n    src="assets/img/icon-btc-small.svg" />\n  <img\n    *ngIf="validDataFromClipboard.type === \'EthereumAddress\' || validDataFromClipboard.type === \'EthereumUri\'"\n    alt="Coin"\n    src="assets/img/icon-eth-small.svg" />\n  <div class="ellipsis">{{validDataFromClipboard.data}}</div>\n</button>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/clipboard-card/clipboard-card.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [])
], ClipboardCardPage);

//# sourceMappingURL=clipboard-card.js.map

/***/ }),

/***/ 2033:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ExpandableHeaderPrimaryComponent */
/* unused harmony export ExpandableHeaderFooterComponent */
/* unused harmony export ExpandableHeaderComponent */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);



let ExpandableHeaderPrimaryComponent = class ExpandableHeaderPrimaryComponent {
    constructor(element) {
        this.element = element;
    }
};
ExpandableHeaderPrimaryComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'expandable-header-primary',
        template: '<ng-content></ng-content>'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"]])
], ExpandableHeaderPrimaryComponent);

let ExpandableHeaderFooterComponent = class ExpandableHeaderFooterComponent {
    constructor(element) {
        this.element = element;
    }
};
ExpandableHeaderFooterComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'expandable-header-footer',
        template: '<ng-content></ng-content>'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"]])
], ExpandableHeaderFooterComponent);

let ExpandableHeaderComponent = class ExpandableHeaderComponent {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        /**
         * Determines how quickly the content fades out on scroll. The
         * greater the value, the quicker the fade.
         */
        this.fadeFactor = 2.5;
        this.disableFade = false;
    }
    ngOnInit() {
        if (this.disableFade) {
            return;
        }
        this.scrollArea.ionScroll.subscribe(event => event.domWrite(() => this.handleDomWrite(event.scrollTop)));
    }
    ngAfterViewInit() {
        this.headerHeight = this.element.nativeElement.offsetHeight;
    }
    handleDomWrite(scrollTop) {
        const newHeaderHeight = this.getNewHeaderHeight(scrollTop);
        newHeaderHeight > 0 && this.applyTransforms(scrollTop, newHeaderHeight);
    }
    applyTransforms(scrollTop, newHeaderHeight) {
        const transformations = this.computeTransformations(scrollTop, newHeaderHeight);
        this.transformPrimaryContent(transformations, true);
        this.transformFooterContent(transformations);
    }
    getNewHeaderHeight(scrollTop) {
        const newHeaderHeight = this.headerHeight - scrollTop;
        return newHeaderHeight < 0 ? 0 : newHeaderHeight;
    }
    computeTransformations(scrollTop, newHeaderHeight) {
        const opacity = this.getScaleValue(newHeaderHeight, this.fadeFactor);
        const scale = this.getScaleValue(newHeaderHeight, 0.5);
        const translateY = scrollTop > 0 ? scrollTop / 1.5 : 0;
        return [opacity, scale, translateY];
    }
    getScaleValue(newHeaderHeight, exponent) {
        return (Math.pow(newHeaderHeight, exponent) /
            Math.pow(this.headerHeight, exponent));
    }
    transformPrimaryContent(transformations, is3d) {
        let backColorGradient;
        const [opacity, scale, translateY] = transformations;
        const transform3d = `scale3d(${scale}, ${scale}, ${scale}) translateY(${translateY}px)`;
        const transform2d = `scale(${scale}, ${scale}) translate(0, ${translateY}px)`;
        const transformStr = is3d ? transform3d : transform2d;
        this.renderer.setElementStyle(this.primaryContent.element.nativeElement, 'opacity', `${opacity}`);
        this.primaryContent &&
            this.renderer.setElementStyle(this.primaryContent.element.nativeElement, 'transform', transformStr);
        backColorGradient = this.calculateBackColorGradient(opacity);
        const linearGradient = `linear-gradient(180deg, #14245E ${backColorGradient}% , #22378c)`;
        this.renderer.setElementStyle(this.element.nativeElement, 'background-image', linearGradient);
    }
    calculateBackColorGradient(opacity) {
        return (1 - opacity) * 100;
    }
    transformFooterContent(transformations) {
        const [opacity] = transformations;
        this.footerContent &&
            this.renderer.setElementStyle(this.footerContent.element.nativeElement, 'opacity', `${opacity}`);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ContentChild"])(ExpandableHeaderPrimaryComponent),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", ExpandableHeaderPrimaryComponent)
], ExpandableHeaderComponent.prototype, "primaryContent", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ContentChild"])(ExpandableHeaderFooterComponent),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", ExpandableHeaderFooterComponent)
], ExpandableHeaderComponent.prototype, "footerContent", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])('scrollArea'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Content */])
], ExpandableHeaderComponent.prototype, "scrollArea", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Number)
], ExpandableHeaderComponent.prototype, "fadeFactor", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Boolean)
], ExpandableHeaderComponent.prototype, "disableFade", void 0);
ExpandableHeaderComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'expandable-header',
        template: '<ng-content></ng-content>'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"], __WEBPACK_IMPORTED_MODULE_1__angular_core__["Renderer"]])
], ExpandableHeaderComponent);

const EXPANDABLE_HEADER_COMPONENTS = [
    ExpandableHeaderComponent,
    ExpandableHeaderFooterComponent,
    ExpandableHeaderPrimaryComponent
];
/* harmony export (immutable) */ __webpack_exports__["a"] = EXPANDABLE_HEADER_COMPONENTS;

//# sourceMappingURL=expandable-header.js.map

/***/ }),

/***/ 2034:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GiftCardDiscountText; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let GiftCardDiscountText = class GiftCardDiscountText {
    constructor() { }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], GiftCardDiscountText.prototype, "discount", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], GiftCardDiscountText.prototype, "cardConfig", void 0);
GiftCardDiscountText = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'gift-card-discount-text',
        template: `
    <span *ngIf="discount.type === 'flatrate'">{{
      discount.amount | formatCurrency: cardConfig.currency:'minimal'
    }}</span>
    <span *ngIf="discount.type === 'percentage'">{{ discount.amount }}%</span>
  `
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [])
], GiftCardDiscountText);

//# sourceMappingURL=gift-card-discount-text.js.map

/***/ }),

/***/ 2035:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LabelTip; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__info_sheet_info_sheet_template__ = __webpack_require__(857);



let LabelTip = class LabelTip {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
    }
    ngOnChanges() {
        this.renderer.setElementClass(this.element.nativeElement, this.type, true);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], LabelTip.prototype, "type", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], LabelTip.prototype, "header", void 0);
LabelTip = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'label-tip',
        template: `
    <div class="label-header" *ngIf="header !== 'no-header'">
      <img
        *ngIf="type === 'info'"
        class="label-header__icon"
        src="assets/img/icon-info-blue.svg"
      />
      <img
        *ngIf="type === 'warn'"
        class="label-header__icon"
        src="assets/img/icon-warning-circled.svg"
      />
      <img
        *ngIf="type === 'danger'"
        class="label-header__icon"
        src="assets/img/icon-danger.svg"
      />
      <ng-content select="[label-tip-title]"></ng-content>
    </div>
    <div
      [ngClass]="{
        blue: type === 'info',
        yellow: type == 'warn',
        red: type == 'danger'
      }"
    >
      <ng-content select="[label-tip-body]"></ng-content>
    </div>
  `
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"], __WEBPACK_IMPORTED_MODULE_1__angular_core__["Renderer"]])
], LabelTip);

//# sourceMappingURL=label-tip.js.map

/***/ }),

/***/ 2036:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PriceCard; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers__ = __webpack_require__(35);





let PriceCard = class PriceCard {
    constructor(currencyProvider, priceProvider, configProvider, logger) {
        this.currencyProvider = currencyProvider;
        this.priceProvider = priceProvider;
        this.configProvider = configProvider;
        this.logger = logger;
        this.lastDates = 6;
        this.coins = [];
        this.fiatCodes = [
            'USD',
            'INR',
            'GBP',
            'EUR',
            'CAD',
            'COP',
            'NGN',
            'BRL',
            'ARS',
            'AUD'
        ];
        const availableChains = this.currencyProvider.getAvailableChains();
        for (const coin of availableChains) {
            const { backgroundColor, gradientBackgroundColor } = this.currencyProvider.getTheme(coin);
            const card = {
                unitCode: coin,
                historicalRates: [],
                currentPrice: 0,
                averagePrice: 0,
                backgroundColor,
                gradientBackgroundColor,
                name: this.currencyProvider.getCoinName(coin)
            };
            this.coins.push(card);
        }
        this.getPrices();
    }
    getPrices() {
        this.setIsoCode();
        __WEBPACK_IMPORTED_MODULE_2_lodash__["forEach"](this.coins, (coin, index) => {
            this.priceProvider
                .getHistoricalBitcoinPrice(this.isoCode, coin.unitCode)
                .subscribe(response => {
                this.coins[index].historicalRates = response.reverse();
                this.updateValues(index);
            }, err => {
                this.logger.error('Error getting rates:', err);
            });
        });
    }
    updateCurrentPrice() {
        const lastRequest = this.coins[0].historicalRates[this.coins[0].historicalRates.length - 1].ts;
        if (__WEBPACK_IMPORTED_MODULE_3_moment__(lastRequest).isBefore(__WEBPACK_IMPORTED_MODULE_3_moment__(), 'days')) {
            this.getPrices();
            return;
        }
        __WEBPACK_IMPORTED_MODULE_2_lodash__["forEach"](this.coins, (coin, i) => {
            this.priceProvider
                .getCurrentBitcoinPrice(this.isoCode, coin.unitCode)
                .subscribe(response => {
                this.coins[i].historicalRates[this.coins[i].historicalRates.length - 1] = response;
                this.updateValues(i);
            }, err => {
                this.logger.error('Error getting current rate:', err);
            });
        });
    }
    updateValues(i) {
        this.coins[i].currentPrice = this.coins[i].historicalRates[this.coins[i].historicalRates.length - 1].rate;
        this.coins[i].averagePrice =
            ((this.coins[i].currentPrice - this.coins[i].historicalRates[0].rate) *
                100) /
                this.coins[i].historicalRates[0].rate;
        this.drawCanvas(i);
    }
    drawCanvas(index) {
        this.canvases.toArray().forEach((canvas, i) => {
            if (index == i)
                canvas.drawCanvas(this.coins[i]);
        });
    }
    updateCharts() {
        this.isoCode ===
            this.configProvider.get().wallet.settings.alternativeIsoCode
            ? this.updateCurrentPrice()
            : this.getPrices();
    }
    setIsoCode() {
        const alternativeIsoCode = this.configProvider.get().wallet.settings
            .alternativeIsoCode;
        this.isoCode = __WEBPACK_IMPORTED_MODULE_2_lodash__["includes"](this.fiatCodes, alternativeIsoCode)
            ? alternativeIsoCode
            : 'USD';
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChildren"])('canvas'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["QueryList"])
], PriceCard.prototype, "canvases", void 0);
PriceCard = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'price-card',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/price-card/price-card.html"*/'<ion-slides speed="500">\n  <ion-slide *ngFor="let coin of coins">\n    <ion-card>\n      <ion-card-content>\n        <ion-item>\n          <ion-avatar item-start>\n            <img src="assets/img/currencies/{{coin.unitCode}}.svg">\n          </ion-avatar>\n          <h2>{{coin.name}}</h2>\n        </ion-item>\n        <div class="price">\n          <div class="amount-content">\n            <div class="expression-container">\n              <span class="expression">\n                {{ coin.currentPrice| number:\'1.2-2\' }}\n                <span class="unit">{{ isoCode }}</span>\n              </span>\n            </div>\n            <div class="average-container">\n              <ion-icon name="md-arrow-dropup" color="success" *ngIf="coin.averagePrice > 0"></ion-icon>\n              <ion-icon name="md-arrow-dropdown" color="danger" *ngIf="coin.averagePrice < 0"></ion-icon>\n              <span class="average">{{ coin.averagePrice | number:\'1.2-2\' }} % <span class="average-time">| 7d</span></span>\n            </div>\n          </div>\n          <price-chart #canvas></price-chart>\n        </div>\n      </ion-card-content>\n    </ion-card>\n  </ion-slide>\n</ion-slides>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/price-card/price-card.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers__["r" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["T" /* PriceProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["q" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["N" /* Logger */]])
], PriceCard);

//# sourceMappingURL=price-card.js.map

/***/ }),

/***/ 2037:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PriceChart; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_chart_js__ = __webpack_require__(2038);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_chart_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_chart_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers__ = __webpack_require__(35);





let PriceChart = class PriceChart {
    constructor(configProvider) {
        this.configProvider = configProvider;
        this.isoCode = this.configProvider.get().wallet.settings.alternativeIsoCode;
    }
    drawCanvas(coin) {
        let rates = [];
        let labels = [];
        __WEBPACK_IMPORTED_MODULE_3_lodash__["forEach"](coin.historicalRates, (historicalRate, i) => {
            rates.push(historicalRate.rate);
            labels.push(`${i}`);
        });
        const context = this.lineCanvas
            .nativeElement.getContext('2d');
        let gradient = context.createLinearGradient(0, 0, 0, 275);
        gradient.addColorStop(0, coin.gradientBackgroundColor);
        gradient.addColorStop(0.35, 'rgba(255,255,255, 0.25)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        const options = {
            legend: {
                display: false
            },
            scales: {
                yAxes: [
                    {
                        display: false,
                        gridLines: {
                            display: false,
                            drawBorder: false
                        },
                        ticks: {
                            maxTicksLimit: 4,
                            stepSize: 500
                        }
                    }
                ],
                xAxes: [
                    {
                        display: false,
                        gridLines: {
                            display: false,
                            drawBorder: false
                        }
                    }
                ]
            },
            layout: {
                padding: {
                    bottom: 10,
                    top: 10,
                    left: 0,
                    right: 2
                }
            }
        };
        const data = {
            labels,
            datasets: [
                {
                    fill: true,
                    lineTension: 0.3,
                    backgroundColor: gradient,
                    borderColor: coin.backgroundColor,
                    borderCapStyle: 'round',
                    borderDash: [],
                    borderDashOffset: 0.0,
                    borderJoinStyle: 'round',
                    pointBorderColor: coin.backgroundColor,
                    pointBackgroundColor: coin.backgroundColor,
                    pointBorderWidth: 1,
                    pointHoverRadius: 1,
                    pointHoverBackgroundColor: coin.backgroundColor,
                    pointHoverBorderColor: 'rgba(220,220,220,1)',
                    pointHoverBorderWidth: 1,
                    pointRadius: 1,
                    data: rates,
                    spanGaps: true,
                    responsive: true
                }
            ]
        };
        this.lineChart = new __WEBPACK_IMPORTED_MODULE_2_chart_js__(this.lineCanvas.nativeElement, {
            type: 'line',
            data,
            options
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('lineCanvas'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], PriceChart.prototype, "lineCanvas", void 0);
PriceChart = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'price-chart',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/price-card/price-chart/price-chart.html"*/'<div class="chart">\n  <canvas #lineCanvas></canvas>\n</div>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/price-card/price-chart/price-chart.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers__["q" /* ConfigProvider */]])
], PriceChart);

//# sourceMappingURL=price-chart.js.map

/***/ }),

/***/ 2039:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SearchBarComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_operators__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_operators___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_operators__);





let SearchBarComponent = class SearchBarComponent {
    constructor() {
        this.search = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"]();
        this.debouncer = new __WEBPACK_IMPORTED_MODULE_3_rxjs__["Subject"]();
    }
    ngOnInit() {
        this.debouncer
            .pipe(Object(__WEBPACK_IMPORTED_MODULE_4_rxjs_operators__["debounceTime"])(200))
            .subscribe(value => this.search.emit(value));
        this.scrollArea &&
            this.scrollArea.ionScroll.subscribe(() => {
                const activeElement = document.activeElement;
                activeElement && activeElement.blur && activeElement.blur();
            });
    }
    onSearch($event) {
        this.debouncer.next($event);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], SearchBarComponent.prototype, "placeholder", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Content */])
], SearchBarComponent.prototype, "scrollArea", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Output"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["EventEmitter"])
], SearchBarComponent.prototype, "search", void 0);
SearchBarComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        host: { class: 'search-bar' },
        selector: 'search-bar',
        template: `
    <ion-input
      [placeholder]="placeholder"
      (input)="onSearch($event)"
    ></ion-input>
  `
    })
], SearchBarComponent);

//# sourceMappingURL=search-bar.js.map

/***/ }),

/***/ 2040:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProvidersModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__index__ = __webpack_require__(35);




let ProvidersModule = class ProvidersModule {
};
ProvidersModule = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"])({
        providers: [
            __WEBPACK_IMPORTED_MODULE_3__index__["a" /* ActionSheetProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["c" /* AddressProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["b" /* AddressBookProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["d" /* AnalyticsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["e" /* AndroidFingerprintAuth */],
            __WEBPACK_IMPORTED_MODULE_3__index__["g" /* AppProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["f" /* AppIdentityProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["h" /* BackupProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["k" /* BitPayProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["j" /* BitPayCardProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["i" /* BitPayAccountProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["m" /* BwcProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["l" /* BwcErrorProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["q" /* ConfigProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["p" /* CoinbaseProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["n" /* Clipboard */],
            __WEBPACK_IMPORTED_MODULE_3__index__["o" /* ClipboardProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["r" /* CurrencyProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["s" /* DerivationPathHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["t" /* Device */],
            __WEBPACK_IMPORTED_MODULE_3__index__["u" /* DomProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["v" /* DownloadProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["y" /* ExternalLinkProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["B" /* FeedbackProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["z" /* FCMNG */],
            __WEBPACK_IMPORTED_MODULE_3__index__["F" /* HomeIntegrationsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["G" /* HttpRequestsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["A" /* FeeProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["E" /* GiftCardProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["H" /* IncomingDataProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["I" /* InvoiceProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["J" /* KeyProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["K" /* LanguageLoader */],
            __WEBPACK_IMPORTED_MODULE_3__index__["L" /* LanguageProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["M" /* LaunchReview */],
            __WEBPACK_IMPORTED_MODULE_3__index__["N" /* Logger */],
            __WEBPACK_IMPORTED_MODULE_3__index__["w" /* ElectronProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["O" /* OnGoingProcessProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["P" /* PayproProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["R" /* PlatformProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["T" /* PriceProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["U" /* ProfileProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["S" /* PopupProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["W" /* QRScanner */],
            __WEBPACK_IMPORTED_MODULE_3__index__["V" /* PushNotificationsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["X" /* RateProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["Y" /* ReplaceParametersProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_1" /* ShapeshiftProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_4" /* StatusBar */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_3" /* SplashScreen */],
            __WEBPACK_IMPORTED_MODULE_3__index__["Z" /* ScanProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_0" /* ScreenOrientation */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_2" /* SocialSharing */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_6" /* Toast */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_7" /* TouchID */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_12" /* Vibration */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_5" /* TimeProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_8" /* TouchIdProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_9" /* TxConfirmNotificationProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["D" /* FilterProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_10" /* TxFormatProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_11" /* UserAgent */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_13" /* WalletProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["x" /* EmailNotificationsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__angular_common__["d" /* DecimalPipe */],
            __WEBPACK_IMPORTED_MODULE_3__index__["Q" /* PersistenceProvider */],
            __WEBPACK_IMPORTED_MODULE_3__index__["C" /* File */],
            __WEBPACK_IMPORTED_MODULE_3__index__["_14" /* WalletTabsProvider */]
        ]
    })
], ProvidersModule);

//# sourceMappingURL=providers.module.js.map

/***/ }),

/***/ 243:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AnalyticsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_fcm_ng__ = __webpack_require__(426);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_fcm_ng___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_fcm_ng__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__platform_platform__ = __webpack_require__(12);




let AnalyticsProvider = class AnalyticsProvider {
    constructor(FCMPlugin, platformProvider) {
        this.FCMPlugin = FCMPlugin;
        this.platformProvider = platformProvider;
    }
    logEvent(eventName, eventParams) {
        if (this.platformProvider.isCordova)
            this.FCMPlugin.logEvent(eventName, eventParams);
    }
    setUserProperty(name, value) {
        if (this.platformProvider.isCordova)
            this.FCMPlugin.setUserProperty(name, value);
    }
};
AnalyticsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_fcm_ng__["FCMNG"],
        __WEBPACK_IMPORTED_MODULE_3__platform_platform__["a" /* PlatformProvider */]])
], AnalyticsProvider);

//# sourceMappingURL=analytics.js.map

/***/ }),

/***/ 244:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LanguageProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_moment__);







let LanguageProvider = class LanguageProvider {
    constructor(logger, translate, configProvider) {
        this.logger = logger;
        this.translate = translate;
        this.configProvider = configProvider;
        this.languages = [
            {
                name: 'English',
                isoCode: 'en'
            },
            {
                name: 'Espaol',
                isoCode: 'es'
            },
            {
                name: 'Franais',
                isoCode: 'fr'
            },
            {
                name: 'Italiano',
                isoCode: 'it'
            },
            {
                name: 'Nederlands',
                isoCode: 'nl'
            },
            {
                name: 'Polski',
                isoCode: 'pl'
            },
            {
                name: 'Deutsch',
                isoCode: 'de'
            },
            {
                name: '',
                isoCode: 'ja',
                useIdeograms: true
            },
            {
                name: '',
                isoCode: 'zh',
                useIdeograms: true
            },
            {
                name: 'P',
                isoCode: 'ru'
            },
            {
                name: 'Portugus',
                isoCode: 'pt'
            }
        ];
        this.logger.debug('LanguageProvider initialized');
        this.translate.onLangChange.subscribe(event => {
            this.logger.info('Setting new default language to: ' + event.lang);
        });
    }
    load() {
        let lang = this.configProvider.get().wallet.settings.defaultLanguage;
        if (!__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](lang))
            this.current = lang;
        else {
            // Get from browser
            const browserLang = this.translate.getBrowserLang();
            this.current = this.getName(browserLang)
                ? browserLang
                : this.getDefault();
        }
        this.logger.info('Default language: ' + this.current);
        this.translate.setDefaultLang(this.current);
        __WEBPACK_IMPORTED_MODULE_6_moment__["locale"](this.current);
    }
    set(lang) {
        this.current = lang;
        this.translate.use(lang);
        __WEBPACK_IMPORTED_MODULE_6_moment__["locale"](lang);
        this.configProvider.set({
            wallet: { settings: { defaultLanguage: lang } }
        });
    }
    getName(lang) {
        return __WEBPACK_IMPORTED_MODULE_5_lodash__["result"](__WEBPACK_IMPORTED_MODULE_5_lodash__["find"](this.languages, {
            isoCode: lang
        }), 'name');
    }
    getDefault() {
        return this.languages[0]['isoCode'];
    }
    getCurrent() {
        return this.current;
    }
    getAvailables() {
        return this.languages;
    }
};
LanguageProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4__config_config__["a" /* ConfigProvider */]])
], LanguageProvider);

//# sourceMappingURL=language.js.map

/***/ }),

/***/ 245:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FilterProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);




let FilterProvider = class FilterProvider {
    constructor(decimalPipe, logger) {
        this.decimalPipe = decimalPipe;
        this.logger = logger;
        this.logger.debug('FilterProvider initialized');
        this.formats = {
            CURRENCY_SYM: '$',
            DECIMAL_SEP: '.',
            GROUP_SEP: ','
        };
    }
    formatFiatAmount(amount) {
        let value;
        let sep;
        let group;
        let intValue;
        let floatValue;
        let finalValue;
        value = this.decimalPipe.transform(amount);
        if (!value)
            return 0;
        sep = value.indexOf(this.formats.DECIMAL_SEP);
        group = value.indexOf(this.formats.GROUP_SEP);
        if (amount >= 0) {
            if (group > 0) {
                if (sep < 0) {
                    return value;
                }
                intValue = value.substring(0, sep);
                floatValue = parseFloat(value.substring(sep));
                floatValue = floatValue.toFixed(2);
                floatValue = floatValue.toString().substring(1);
                finalValue = intValue + floatValue;
                return finalValue;
            }
            else {
                value = parseFloat(value);
                return value.toFixed(2);
            }
        }
        return 0;
    }
};
FilterProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common__["d" /* DecimalPipe */], __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], FilterProvider);

//# sourceMappingURL=filter.js.map

/***/ }),

/***/ 246:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app_identity_app_identity__ = __webpack_require__(317);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_bitauth__ = __webpack_require__(971);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_bitauth___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_bitauth__);




// providers


let BitPayProvider = class BitPayProvider {
    constructor(http, appIdentityProvider, logger) {
        this.http = http;
        this.appIdentityProvider = appIdentityProvider;
        this.logger = logger;
        this.logger.debug('BitPayProvider initialized');
        this.NETWORK = 'livenet';
        this.BITPAY_API_URL =
            this.NETWORK == 'livenet'
                ? 'https://bitpay.com'
                : 'https://test.bitpay.com';
    }
    getEnvironment() {
        return {
            network: this.NETWORK
        };
    }
    get(endpoint, successCallback, errorCallback) {
        let url = this.BITPAY_API_URL + endpoint;
        let headers = {
            'Content-Type': 'application/json'
        };
        this.http.get(url, { headers }).subscribe(data => {
            successCallback(data);
        }, data => {
            errorCallback(data);
        });
    }
    post(endpoint, json, successCallback, errorCallback) {
        this.appIdentityProvider.getIdentity(this.getEnvironment().network, (err, appIdentity) => {
            if (err) {
                return errorCallback(err);
            }
            let dataToSign = this.BITPAY_API_URL + endpoint + JSON.stringify(json);
            let signedData = __WEBPACK_IMPORTED_MODULE_5_bitauth__["sign"](dataToSign, appIdentity.priv);
            let url = this.BITPAY_API_URL + endpoint;
            let headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]().set('content-type', 'application/json');
            headers = headers.append('x-identity', appIdentity.pub);
            headers = headers.append('x-signature', signedData);
            this.http.post(url, json, { headers }).subscribe(data => {
                successCallback(data);
            }, data => {
                errorCallback(data);
            });
        });
    }
    postAuth(json, successCallback, errorCallback) {
        this.appIdentityProvider.getIdentity(this.getEnvironment().network, (err, appIdentity) => {
            if (err) {
                return errorCallback(err);
            }
            json['params'].signature = __WEBPACK_IMPORTED_MODULE_5_bitauth__["sign"](JSON.stringify(json.params), appIdentity.priv);
            json['params'].pubkey = appIdentity.pub;
            json['params'] = JSON.stringify(json.params);
            let url = this.BITPAY_API_URL + '/api/v2/';
            let headers = {
                'Content-Type': 'application/json'
            };
            this.logger.debug('post auth:' + JSON.stringify(json));
            this.http.post(url, json, { headers }).subscribe((data) => {
                data.appIdentity = appIdentity;
                successCallback(data);
            }, data => {
                errorCallback(data);
            });
        });
    }
};
BitPayProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_4__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], BitPayProvider);

//# sourceMappingURL=bitpay.js.map

/***/ }),

/***/ 247:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ScanPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_incoming_data_incoming_data__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_scan_scan__ = __webpack_require__(981);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__paper_wallet_paper_wallet__ = __webpack_require__(467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__send_amount_amount__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__settings_addressbook_add_add__ = __webpack_require__(333);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__environments__ = __webpack_require__(424);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__wallet_tabs_wallet_tabs_provider__ = __webpack_require__(90);




// providers






// pages





let ScanPage = class ScanPage {
    constructor(navCtrl, scanProvider, platformProvider, incomingDataProvider, events, externalLinkProvider, logger, translate, navParams, walletTabsProvider, platform, actionSheetProvider) {
        this.navCtrl = navCtrl;
        this.scanProvider = scanProvider;
        this.platformProvider = platformProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.translate = translate;
        this.navParams = navParams;
        this.walletTabsProvider = walletTabsProvider;
        this.platform = platform;
        this.actionSheetProvider = actionSheetProvider;
        this.ngVersion = __WEBPACK_IMPORTED_MODULE_1__angular_core__["VERSION"].full;
        this.hasCameras = false;
        this.incomingDataErrorHandler = err => {
            this.showErrorInfoSheet(err);
        };
        this.finishIncomingDataMenuEventHandler = data => {
            if (!this.isCordova) {
                this.scanner.resetScan();
            }
            switch (data.redirTo) {
                case 'AmountPage':
                    this.sendPaymentToAddress(data.value, data.coin);
                    break;
                case 'AddressBookPage':
                    this.addToAddressBook(data.value);
                    break;
                case 'OpenExternalLink':
                    this.goToUrl(data.value);
                    break;
                case 'PaperWalletPage':
                    this.scanPaperWallet(data.value);
                    break;
                default:
                    if (this.isCordova) {
                        this.activate();
                    }
                    else if (this.isCameraSelected) {
                        this.scanner.startScan(this.selectedDevice);
                    }
            }
        };
        this.scannerServiceInitializedHandler = () => {
            this.logger.debug('Scanner initialization finished, reinitializing scan view...');
            this._refreshScanView();
        };
        this.isCameraSelected = false;
        this.browserScanEnabled = false;
        this.canEnableLight = true;
        this.canChangeCamera = true;
        this.scannerStates = {
            unauthorized: 'unauthorized',
            denied: 'denied',
            unavailable: 'unavailable',
            loading: 'loading',
            visible: 'visible'
        };
        this.scannerIsAvailable = true;
        this.scannerHasPermission = false;
        this.scannerIsDenied = false;
        this.scannerIsRestricted = false;
        this.canOpenSettings = false;
        this.isCordova = this.platformProvider.isCordova;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ScanPage');
        this.onResumeSubscription = this.platform.resume.subscribe(() => {
            this.ionViewWillEnter();
        });
    }
    ionViewWillLeave() {
        this.events.unsubscribe('incomingDataError', this.incomingDataErrorHandler);
        this.events.unsubscribe('finishIncomingDataMenuEvent', this.finishIncomingDataMenuEventHandler);
        this.events.unsubscribe('scannerServiceInitialized', this.scannerServiceInitializedHandler);
        if (!this.isCordova) {
            this.scanner.resetScan();
        }
        else {
            this.cameraToggleActive = false;
            this.lightActive = false;
            this.scanProvider.frontCameraEnabled = false;
            this.scanProvider.deactivate();
        }
        this.unregisterBackButtonAction && this.unregisterBackButtonAction();
    }
    ionViewWillEnter() {
        this.initializeBackButtonHandler();
        this.fromAddressbook = this.navParams.data.fromAddressbook;
        this.fromImport = this.navParams.data.fromImport;
        this.fromJoin = this.navParams.data.fromJoin;
        this.fromSend =
            this.walletTabsProvider.getFromPage() &&
                this.walletTabsProvider.getFromPage().fromSend;
        if (!__WEBPACK_IMPORTED_MODULE_13__environments__["a" /* default */].activateScanner) {
            // test scanner visibility in E2E mode
            this.selectedDevice = true;
            this.hasPermission = true;
            return;
        }
        this.events.subscribe('incomingDataError', this.incomingDataErrorHandler);
        this.events.subscribe('finishIncomingDataMenuEvent', this.finishIncomingDataMenuEventHandler);
        if (!this.isCordova) {
            if (!this.isCameraSelected) {
                this.loadCamera();
            }
            else {
                this.scanner.startScan(this.selectedDevice);
            }
        }
        else {
            // try initializing and refreshing status any time the view is entered
            if (this.scannerHasPermission) {
                this.activate();
            }
            else {
                if (!this.scanProvider.isInitialized()) {
                    this.scanProvider.gentleInitialize().then(() => {
                        this.authorize();
                    });
                }
                else {
                    this.authorize();
                }
            }
            this.events.subscribe('scannerServiceInitialized', this.scannerServiceInitializedHandler);
        }
    }
    ngOnDestroy() {
        this.onResumeSubscription.unsubscribe();
    }
    showErrorInfoSheet(error, title) {
        let infoSheetTitle = title ? title : this.translate.instant('Error');
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: error, title: infoSheetTitle });
        errorInfoSheet.present();
        errorInfoSheet.onDidDismiss(() => {
            if (this.isCordova) {
                this.activate();
            }
            else if (this.isCameraSelected) {
                this.scanner.startScan(this.selectedDevice);
            }
        });
    }
    initializeBackButtonHandler() {
        this.unregisterBackButtonAction = this.platform.registerBackButtonAction(() => {
            this.close();
        });
    }
    loadCamera() {
        this.scanner.camerasFound.subscribe((devices) => {
            this.hasCameras = true;
            this.availableDevices = devices;
            this.onDeviceSelectChange();
        });
        this.scanner.camerasNotFound.subscribe(() => {
            this.logger.error('An error has occurred when trying to enumerate your video-stream-enabled devices.');
        });
        this.scanner.askForPermission().then((answer) => {
            this.hasPermission = answer;
        });
    }
    goToUrl(url) {
        this.externalLinkProvider.open(url);
    }
    sendPaymentToAddress(bitcoinAddress, coin) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__send_amount_amount__["a" /* AmountPage */], { toAddress: bitcoinAddress, coin });
    }
    addToAddressBook(bitcoinAddress) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__settings_addressbook_add_add__["a" /* AddressbookAddPage */], { addressbookEntry: bitcoinAddress });
    }
    scanPaperWallet(privateKey) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__paper_wallet_paper_wallet__["a" /* PaperWalletPage */], { privateKey });
    }
    updateCapabilities() {
        let capabilities = this.scanProvider.getCapabilities();
        this.scannerIsAvailable = capabilities.isAvailable;
        this.scannerHasPermission = capabilities.hasPermission;
        this.scannerIsDenied = capabilities.isDenied;
        this.scannerIsRestricted = capabilities.isRestricted;
        this.canEnableLight = capabilities.canEnableLight;
        this.canChangeCamera = capabilities.canChangeCamera;
        this.canOpenSettings = capabilities.canOpenSettings;
    }
    handleCapabilities() {
        // always update the view
        if (!this.scanProvider.isInitialized()) {
            this.currentState = this.scannerStates.loading;
        }
        else if (!this.scannerIsAvailable) {
            this.currentState = this.scannerStates.unavailable;
        }
        else if (this.scannerIsDenied) {
            this.currentState = this.scannerStates.denied;
        }
        else if (this.scannerIsRestricted) {
            this.currentState = this.scannerStates.denied;
        }
        else if (!this.scannerHasPermission) {
            this.currentState = this.scannerStates.unauthorized;
        }
        this.logger.debug('Scan view state set to: ' + this.currentState);
    }
    _refreshScanView() {
        this.updateCapabilities();
        this.handleCapabilities();
        if (this.scannerHasPermission) {
            this.activate();
        }
    }
    activate() {
        this.scanProvider
            .activate()
            .then(() => {
            this.logger.info('Scanner activated, setting to visible...');
            this.updateCapabilities();
            this.handleCapabilities();
            this.currentState = this.scannerStates.visible;
            // resume preview if paused
            this.scanProvider.resumePreview();
            this.scanProvider.scan().then((contents) => {
                this.scanProvider.pausePreview();
                this.handleSuccessfulScan(contents);
            });
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    handleSuccessfulScan(contents) {
        if (this.fromAddressbook) {
            this.events.publish('Local/AddressScan', { value: contents });
            this.navCtrl.pop();
        }
        else if (this.fromImport) {
            this.events.publish('Local/BackupScan', { value: contents });
            this.navCtrl.pop();
        }
        else if (this.fromJoin) {
            this.events.publish('Local/InvitationScan', { value: contents });
            this.navCtrl.pop();
        }
        else if (this.fromSend) {
            this.events.publish('Local/AddressScan', { value: contents });
            this.close();
        }
        else {
            const redirParms = { activePage: 'ScanPage' };
            this.incomingDataProvider.redir(contents, redirParms);
        }
    }
    authorize() {
        this.scanProvider.initialize().then(() => {
            this._refreshScanView();
        });
    }
    attemptToReactivate() {
        this.scanProvider.reinitialize();
    }
    openSettings() {
        this.scanProvider.openSettings();
    }
    toggleLight() {
        this.scanProvider
            .toggleLight()
            .then(resp => {
            this.lightActive = resp;
        })
            .catch(error => {
            this.logger.warn('scanner error: ' + error);
        });
    }
    toggleCamera() {
        this.scanProvider
            .toggleCamera()
            .then(resp => {
            this.cameraToggleActive = resp;
            this.lightActive = false;
        })
            .catch(error => {
            this.logger.warn('scanner error: ' + error);
        });
    }
    handleQrCodeResult(resultString) {
        this.scanner.resetScan();
        setTimeout(() => {
            this.handleSuccessfulScan(resultString);
        }, 0);
    }
    onDeviceSelectChange() {
        if (!this.isCameraSelected) {
            for (const device of this.availableDevices) {
                if (device.kind == 'videoinput') {
                    this.selectedDevice = this.scanner.getDeviceById(device.deviceId);
                    this.isCameraSelected = true;
                    break;
                }
            }
        }
    }
    close() {
        this.walletTabsProvider.getTabNav()
            ? this.events.publish('ExitScan')
            : this.navCtrl.parent.select(0);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('scanner'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], ScanPage.prototype, "scanner", void 0);
ScanPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-scan',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/scan/scan.html"*/'<ion-header>\n  <ion-navbar class="navbar-transparent">\n    <ion-buttons left *ngIf="!fromAddressbook && !fromImport && !fromJoin">\n      <button class="modal-close-button" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n    <ion-title>{{\'Scan\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content *ngIf="!isCordova" class="fullscreen-tab">\n\n  <div [hidden]="!selectedDevice || !hasPermission">\n\n    <div [hidden]="!hasPermission" class="browser-scanner page-scan-camera-ready">\n\n      <zxing-scanner #scanner class="test-class" start="true" [device]="selectedDevice" (scanSuccess)="handleQrCodeResult($event)"></zxing-scanner>\n      <div class="guides">\n        <img class="svg qr-scan-guides" src="assets/img/bitpay-wallet-qr-scan-guides.svg">\n      </div>\n\n    </div>\n  </div>\n\n  <div *ngIf="!selectedDevice || !hasPermission" class="page-scan-has-problems">\n    <div class="header-container">\n      <div>\n        <div class="header" padding>\n          <div class="image-container">\n            <img src="assets/img/ico-receive.svg" />\n          </div>\n          <div class="title" padding translate>Scan QR Codes</div>\n        </div>\n        <div class="subtitle" translate>You can scan bitcoin addresses, payment requests, paper wallets, and more.</div>\n      </div>\n    </div>\n    <div class="body">\n      <div padding>\n        <div *ngIf="hasPermission === false" translate>Enable the camera to get started.</div>\n        <div *ngIf="!hasCameras && hasPermission === true" translate>Please connect a camera to get started.</div>\n      </div>\n      <div>\n        <button ion-button outline class="button-standard" *ngIf="hasPermission === false" (click)="loadCamera()">\n          {{\'Retry camera\' | translate}}\n        </button>\n      </div>\n    </div>\n  </div>\n</ion-content>\n\n<ion-content *ngIf="isCordova" class="back-transparent" no-bounce>\n  <div class="page-scan-has-problems" *ngIf="(currentState == scannerStates.unauthorized || currentState == scannerStates.denied || currentState == scannerStates.unavailable)">\n    <div class="header-container">\n      <div>\n        <div class="header" padding>\n          <div class="image-container">\n            <img src="assets/img/ico-receive.svg" />\n          </div>\n          <div class="title" padding translate>Scan QR Codes</div>\n        </div>\n        <div class="subtitle" translate>You can scan bitcoin addresses, payment requests, paper wallets, and more.</div>\n      </div>\n    </div>\n    <div class="body">\n      <div padding>\n        <div *ngIf="currentState == scannerStates.unauthorized" translate>Enable the camera to get started.</div>\n        <div *ngIf="currentState == scannerStates.denied" translate>Enable camera access in your device settings to get started.</div>\n        <div *ngIf="currentState == scannerStates.unavailable" translate>Please connect a camera to get started.</div>\n      </div>\n      <div>\n        <button ion-button outline class="button-standard" *ngIf="currentState == scannerStates.unauthorized" (click)="authorize()">\n          {{\'Allow camera access\' | translate}}\n        </button>\n        <button ion-button outline class="button-standard" *ngIf="currentState == scannerStates.denied && canOpenSettings" (click)="openSettings()">\n          {{\'Open settings\' | translate}}\n        </button>\n        <button ion-button outline class="button-standard" *ngIf="currentState == scannerStates.unavailable" (click)="attemptToReactivate()">\n          {{\'Retry camera\' | translate}}\n        </button>\n      </div>\n    </div>\n  </div>\n  <div class="page-scan-loading-camera" *ngIf="currentState == scannerStates.loading"></div>\n  <div class="page-scan-camera-ready" *ngIf="currentState == scannerStates.visible">\n    <div class="guides">\n      <img class="svg qr-scan-guides" src="assets/img/bitpay-wallet-qr-scan-guides.svg">\n    </div>\n    <div class="scanner-controls">\n      <span *ngIf="canEnableLight" class="icon-flash" [ngClass]="{\'active\': lightActive}" (click)="toggleLight()"></span>\n      <span *ngIf="canChangeCamera" class="icon-camera-toggle" [ngClass]="{\'active\': cameraToggleActive}" (click)="toggleCamera()"></span>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/scan/scan.html"*/,
        providers: [__WEBPACK_IMPORTED_MODULE_9__providers_scan_scan__["a" /* ScanProvider */]]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_scan_scan__["a" /* ScanProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_14__wallet_tabs_wallet_tabs_provider__["a" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_4__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */]])
], ScanPage);

//# sourceMappingURL=scan.js.map

/***/ }),

/***/ 248:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbasePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_coinbase_coinbase__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__send_amount_amount__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__coinbase_tx_details_coinbase_tx_details__ = __webpack_require__(986);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_lodash__);





// providers





// pages



let CoinbasePage = class CoinbasePage {
    constructor(coinbaseProvider, logger, popupProvider, navCtrl, externalLinkProvider, platformProvider, onGoingProcessProvider, modalCtrl, navParams, formBuilder) {
        this.coinbaseProvider = coinbaseProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.externalLinkProvider = externalLinkProvider;
        this.platformProvider = platformProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.modalCtrl = modalCtrl;
        this.navParams = navParams;
        this.formBuilder = formBuilder;
        this.pendingTransactions = { data: {} };
        this.oauthCodeForm = this.formBuilder.group({
            code: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required])
            ]
        });
        this.isElectron = this.platformProvider.isElectron;
        this.isCordova = this.platformProvider.isCordova;
        this.showOauthForm = false;
    }
    ionViewWillEnter() {
        if (this.navParams.data.code) {
            this.coinbaseProvider.getStoredToken((at) => {
                if (!at)
                    this.submitOauthCode(this.navParams.data.code);
            });
        }
        else {
            this.init();
        }
    }
    init() {
        this.currency = this.coinbaseProvider.getAvailableCurrency();
        this.loading = true;
        this.coinbaseProvider.getStoredToken((at) => {
            this.accessToken = at;
            // Update Access Token if necessary
            this.coinbaseProvider.init((err, data) => {
                if (err || __WEBPACK_IMPORTED_MODULE_12_lodash__["isEmpty"](data)) {
                    this.loading = false;
                    if (err) {
                        this.logger.error(err);
                        let errorId = err.errors ? err.errors[0].id : null;
                        err = err.errors
                            ? err.errors[0].message
                            : err.error_description
                                ? err.error_description
                                : err.error || err || 'Unknown error';
                        this.popupProvider
                            .ionicAlert('Error connecting to Coinbase', err)
                            .then(() => {
                            if (errorId == 'revoked_token') {
                                this.coinbaseProvider.logout();
                            }
                            this.navCtrl.pop();
                        });
                    }
                    return;
                }
                // Show rates
                this.coinbaseProvider.buyPrice(data.accessToken, this.currency, (_, b) => {
                    this.buyPrice = b.data || null;
                    this.coinbaseProvider.sellPrice(data.accessToken, this.currency, (_, s) => {
                        this.sellPrice = s.data || null;
                        this.loading = false;
                    });
                });
                // Updating accessToken and accountId
                this.accessToken = data.accessToken;
                this.accountId = data.accountId;
                this.updateTransactions();
            });
        });
    }
    updateTransactions() {
        this.logger.info('Getting transactions...');
        this.coinbaseProvider.getPendingTransactions(this.pendingTransactions);
    }
    openAuthenticateWindow() {
        const oauthUrl = this.getAuthenticateUrl();
        if (!this.isElectron) {
            this.externalLinkProvider.open(oauthUrl);
        }
        else {
            const { remote } = window.require('electron');
            const BrowserWindow = remote.BrowserWindow;
            const win = new BrowserWindow({
                alwaysOnTop: true,
                center: true,
                webPreferences: {
                    contextIsolation: false,
                    nodeIntegration: false
                }
            });
            win.once('ready-to-show', () => {
                win.show();
                win.focus();
            });
            win.loadURL(oauthUrl);
            win.webContents.on('did-finish-load', () => {
                const title = win.webContents.getTitle();
                if (title.indexOf('Coinbase') == -1) {
                    this.code = title;
                    this.submitOauthCode(this.code);
                    win.close();
                }
            });
        }
    }
    submitOauthCode(code) {
        this.onGoingProcessProvider.set('connectingCoinbase');
        this.coinbaseProvider.getToken(code, (err, accessToken) => {
            this.onGoingProcessProvider.clear();
            if (err) {
                this.popupProvider.ionicAlert('Error connecting to Coinbase', err);
                return;
            }
            if (!this.isElectron) {
                let previousView = this.navCtrl.getPrevious();
                this.navCtrl.removeView(previousView);
            }
            this.accessToken = accessToken;
            this.init();
        });
    }
    getAuthenticateUrl() {
        this.showOauthForm = this.isCordova || this.isElectron ? false : true;
        return this.coinbaseProvider.getOauthCodeUrl();
    }
    openSignupWindow() {
        let url = this.coinbaseProvider.getSignupUrl();
        let optIn = true;
        let title = 'Sign Up for Coinbase';
        let message = 'This will open Coinbase.com, where you can create an account.';
        let okText = 'Go to Coinbase';
        let cancelText = 'Back';
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openSupportWindow() {
        let url = this.coinbaseProvider.getSupportUrl();
        let optIn = true;
        let title = 'Coinbase Support';
        let message = 'You can email support@coinbase.com for direct support, or you can view their help center.';
        let okText = 'Open Help Center';
        let cancelText = 'Go Back';
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    toggleOauthForm() {
        this.showOauthForm = !this.showOauthForm;
    }
    openTxModal(tx) {
        this.tx = tx;
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_11__coinbase_tx_details_coinbase_tx_details__["a" /* CoinbaseTxDetailsPage */], { tx: this.tx });
        modal.present();
        modal.onDidDismiss(data => {
            if (data.updateRequired)
                this.updateTransactions();
        });
    }
    goToBuyCoinbasePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__send_amount_amount__["a" /* AmountPage */], {
            nextPage: 'BuyCoinbasePage',
            currency: this.currency,
            coin: 'btc',
            fixedUnit: true
        });
    }
    goToSellCoinbasePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__send_amount_amount__["a" /* AmountPage */], {
            nextPage: 'SellCoinbasePage',
            currency: this.currency,
            coin: 'btc',
            fixedUnit: true
        });
    }
};
CoinbasePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-coinbase',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/coinbase/coinbase.html"*/'<ion-header class="wide-header">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        <img src="assets/img/coinbase/coinbase-logo.png" width="70">\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary>\n          <img margin-left src="assets/img/coinbase/coinbase-logo.png" width="150">\n          <ion-spinner *ngIf="accessToken && loading"></ion-spinner>\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <div *ngIf="!accessToken" class="center-header">\n      <div padding text-center>\n        <div *ngIf="!showOauthForm">Coinbase\'s exchange service is available in US, and can take 3-5 days to buy or sell bitcoin.</div>\n        <div *ngIf="showOauthForm">If you have trouble, contact Coinbase support for direct assistance.</div>\n      </div>\n      <button margin-top *ngIf="!showOauthForm" ion-button outline class="button-standard" (click)="openAuthenticateWindow()">Connect Coinbase Account</button>\n      <button margin *ngIf="!showOauthForm" ion-button clear small color="dark" (click)="openSignupWindow()">Sign Up for Coinbase &rarr;</button>\n      <div *ngIf="showOauthForm" margin>\n        <form [formGroup]="oauthCodeForm" (ngSubmit)="submitOauthCode(oauthCodeForm.value.code)">\n          <ion-label stacked>OAuth Code</ion-label>\n          <ion-input type="text" formControlName="code" [value]="oauthCodeForm.value.code" placeholder="{{\'Enter OAuth Code\'}}" required></ion-input>\n          <button ion-button block outline type="submit" [disabled]="!oauthCodeForm.valid">Connect Coinbase Account</button>\n        </form>\n        <button margin-top ion-button block clear small color="dark" (click)="openSupportWindow()">Coinbase Support &rarr;</button>\n      </div>\n    </div>\n    <div *ngIf="accessToken">\n      <ion-list>\n        <button padding ion-item (click)="goToBuyCoinbasePage()">\n          <ion-icon item-start>\n            <img src="assets/img/buy-bitcoin.svg" alt="buy bitcoin" width="30">\n          </ion-icon>\n          <ion-label>Buy</ion-label>\n          <ion-note *ngIf="buyPrice" item-end>\n            {{buyPrice.amount|currency:\'$\':2}} {{buyPrice.currency}}/BTC\n          </ion-note>\n        </button>\n        <button padding ion-item (click)="goToSellCoinbasePage()">\n          <ion-icon item-start>\n            <img src="assets/img/sell-bitcoin.svg" alt="sell bitcoin" width="30">\n          </ion-icon>\n          <ion-label>Sell</ion-label>\n          <ion-note *ngIf="sellPrice"  item-end>\n            {{sellPrice.amount|currency:\'$\':2}} {{sellPrice.currency}}/BTC\n          </ion-note>\n        </button>\n        <ion-item-divider>Activity</ion-item-divider>\n        <div *ngIf="pendingTransactions.data && !error">\n          <button ion-item (click)="openTxModal(tx)" *ngFor="let tx of pendingTransactions.data | keys">\n            <ion-icon item-start>\n                <img src="assets/img/bought-pending.svg" alt="bought" *ngIf="(tx.type == \'buy\' || (tx.to &&tx.type == \'send\')) && tx.status != \'completed\'">\n                <img src="assets/img/bought.svg" alt="bought" *ngIf="(tx.type == \'buy\' || (tx.to &&tx.type == \'send\')) && tx.status == \'completed\'">\n                <img src="assets/img/sold-pending.svg" alt="sold" *ngIf="tx.from && tx.type == \'send\'">\n                <img src="assets/img/sold.svg" alt="sold" *ngIf="!tx.from && tx.type == \'sell\' && tx.status == \'completed\'">\n            </ion-icon>\n            <span *ngIf="tx.type == \'sell\' && tx.status == \'completed\'">Sold</span>\n            <span *ngIf="tx.type == \'send\' && tx.to && tx.status == \'completed\'">Bought</span>\n            <span *ngIf="tx.type == \'sell\' || (tx.type == \'send\' && tx.from)">-</span>{{tx.amount.amount.replace(\'-\',\'\')}}\n            {{tx.amount.currency}}\n            <ion-note item-end text-end>\n              <div class="assertive" *ngIf="tx.error || tx.status == \'error\'">\n                Error\n              </div>\n              <div *ngIf="!tx.error">\n                <div *ngIf="tx.status == \'completed\'">\n                  <time *ngIf="tx.created_at">{{tx.created_at | amTimeAgo}}</time>\n                </div>\n                <div *ngIf="tx.status == \'pending\'">\n                  <span *ngIf="tx.status == \'pending\'">Pending</span>\n                </div>\n              </div>\n            </ion-note>\n          </button>\n        </div>\n      </ion-list>\n    </div>\n  </div>\n</ion-content>\n'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/coinbase/coinbase.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */]])
], CoinbasePage);

//# sourceMappingURL=coinbase.js.map

/***/ }),

/***/ 249:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfirmPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__finish_finish__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__tabs_tabs__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__choose_fee_level_choose_fee_level__ = __webpack_require__(988);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_address_address__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_clipboard_clipboard__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_fee_fee__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_replace_parameters_replace_parameters__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_tx_confirm_notification_tx_confirm_notification__ = __webpack_require__(466);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__wallet_tabs_wallet_tabs_child__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__wallet_tabs_wallet_tabs_provider__ = __webpack_require__(90);








// Pages



// Providers





















let ConfirmPage = class ConfirmPage extends __WEBPACK_IMPORTED_MODULE_30__wallet_tabs_wallet_tabs_child__["a" /* WalletTabsChild */] {
    constructor(addressProvider, app, actionSheetProvider, bwcErrorProvider, bwcProvider, configProvider, currencyProvider, decimalPipe, externalLinkProvider, feeProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, platformProvider, profileProvider, popupProvider, replaceParametersProvider, translate, txConfirmNotificationProvider, txFormatProvider, walletProvider, walletTabsProvider, clipboardProvider, events, appProvider, keyProvider, statusBar) {
        super(navCtrl, profileProvider, walletTabsProvider);
        this.addressProvider = addressProvider;
        this.app = app;
        this.actionSheetProvider = actionSheetProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.decimalPipe = decimalPipe;
        this.externalLinkProvider = externalLinkProvider;
        this.feeProvider = feeProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.platformProvider = platformProvider;
        this.popupProvider = popupProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.txConfirmNotificationProvider = txConfirmNotificationProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.clipboardProvider = clipboardProvider;
        this.events = events;
        this.appProvider = appProvider;
        this.keyProvider = keyProvider;
        this.statusBar = statusBar;
        this.countDown = null;
        // custom fee flag
        this.usingCustomFee = false;
        this.usingMerchantFee = false;
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.CONFIRM_LIMIT_USD = 20;
        this.FEE_TOO_HIGH_LIMIT_PER = 15;
        this.config = this.configProvider.get();
        this.configFeeLevel = this.config.wallet.settings.feeLevel
            ? this.config.wallet.settings.feeLevel
            : 'normal';
        this.isCordova = this.platformProvider.isCordova;
        this.hideSlideButton = false;
        this.showMultiplesOutputs = false;
        this.recipients = this.navParams.data.recipients;
        this.fromMultiSend = this.navParams.data.fromMultiSend;
        this.appName = this.appProvider.info.nameCase;
    }
    ngOnInit() {
        // Overrides the ngOnInit logic of WalletTabsChild
    }
    ionViewWillLeave() {
        if (this.isCordova) {
            this.statusBar.styleBlackOpaque();
        }
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        if (this.navCtrl.getPrevious().name == 'SelectInvoicePage') {
            this.navCtrl.remove(this.navCtrl.getPrevious().index);
        }
        if (this.isCordova) {
            this.statusBar.styleDefault();
        }
        this.navCtrl.swipeBackEnabled = false;
        this.isOpenSelector = false;
        this.coin = this.navParams.data.coin;
        let networkName;
        let amount;
        if (this.fromMultiSend) {
            networkName = this.navParams.data.network;
            amount = this.navParams.data.totalAmount;
        }
        else {
            amount = this.navParams.data.amount;
            try {
                networkName = this.addressProvider.getCoinAndNetwork(this.navParams.data.toAddress, this.navParams.data.network || 'livenet').network;
            }
            catch (e) {
                const message = this.replaceParametersProvider.replace(this.translate.instant('{{appName}} only supports Bitcoin Cash using new version numbers addresses.'), { appName: this.appName });
                const backText = this.translate.instant('Go back');
                const learnText = this.translate.instant('Learn more');
                this.popupProvider
                    .ionicConfirm(null, message, backText, learnText)
                    .then(back => {
                    if (!back) {
                        const url = 'https://support.bitpay.com/hc/en-us/articles/115004671663';
                        this.externalLinkProvider.open(url);
                    }
                    this.navCtrl.pop();
                });
                return;
            }
        }
        this.tx = {
            toAddress: this.navParams.data.toAddress,
            sendMax: this.navParams.data.useSendMax ? true : false,
            amount: this.navParams.data.useSendMax && this.isChain()
                ? 0
                : parseInt(amount, 10),
            description: this.navParams.data.description,
            paypro: this.navParams.data.paypro,
            data: this.navParams.data.data,
            payProUrl: this.navParams.data.payProUrl,
            spendUnconfirmed: this.config.wallet.spendUnconfirmed,
            // Vanity tx info (not in the real tx)
            recipientType: this.navParams.data.recipientType,
            name: this.navParams.data.name,
            email: this.navParams.data.email,
            color: this.navParams.data.color,
            network: this.navParams.data.network
                ? this.navParams.data.network
                : networkName,
            coin: this.navParams.data.coin,
            txp: {},
            tokenAddress: this.navParams.data.tokenAddress
        };
        this.tx.origToAddress = this.tx.toAddress;
        if (this.navParams.data.requiredFeeRate) {
            this.usingMerchantFee = true;
            this.tx.feeRate = +this.navParams.data.requiredFeeRate;
        }
        else {
            this.tx.feeLevel =
                this.tx.coin && this.tx.coin == 'bch' ? 'normal ' : this.configFeeLevel;
        }
        if (this.tx.coin && this.tx.coin == 'bch' && !this.fromMultiSend) {
            this.tx.toAddress = this.bitcoreCash
                .Address(this.tx.toAddress)
                .toString(true);
        }
        this.getAmountDetails();
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelName = feeOpts[this.tx.feeLevel];
        this.showAddress = false;
        this.walletSelectorTitle = this.translate.instant('Send from');
        this.setWalletSelector(this.tx.coin, this.tx.network, this.tx.amount)
            .then(() => {
            this.afterWalletSelectorSet();
        })
            .catch(err => {
            this.showErrorInfoSheet(err, null, true);
        });
        if (this.isCordova) {
            window.addEventListener('keyboardWillShow', () => {
                this.hideSlideButton = true;
            });
            window.addEventListener('keyboardWillHide', () => {
                this.hideSlideButton = false;
            });
        }
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ConfirmPage');
    }
    getAmountDetails() {
        this.amount = this.decimalPipe.transform(this.tx.amount /
            this.currencyProvider.getPrecision(this.coin).unitToSatoshi, '1.2-6');
    }
    isChain() {
        const chain = this.currencyProvider.getAvailableChains();
        return chain.includes(this.coin);
    }
    getChain(coin) {
        return this.currencyProvider.getChain(coin).toLowerCase();
    }
    afterWalletSelectorSet() {
        const parentWallet = this.getParentWallet();
        if (parentWallet &&
            this.tx.coin === parentWallet.coin &&
            this.tx.network === parentWallet.network) {
            this.setWallet(parentWallet);
        }
        else if (this.wallets.length > 1) {
            return this.showWallets();
        }
        else if (this.wallets.length) {
            this.setWallet(this.wallets[0]);
        }
    }
    setWalletSelector(coin, network, minAmount) {
        const parentWallet = this.getParentWallet();
        if (parentWallet &&
            (parentWallet.network == network && parentWallet.coin == coin)) {
            return Promise.resolve();
        }
        return new Promise(resolve => {
            // no min amount? (sendMax) => look for no empty wallets
            minAmount = minAmount ? minAmount : 1;
            this.wallets = this.profileProvider.getWallets({
                onlyComplete: true,
                hasFunds: true,
                network,
                coin
            });
            return resolve();
        });
    }
    /* sets a wallet on the UI, creates a TXPs for that wallet */
    setWallet(wallet) {
        this.wallet = wallet;
        // If select another wallet
        this.tx.coin = this.wallet.coin;
        if (!this.usingCustomFee && !this.usingMerchantFee) {
            this.tx.feeLevel = wallet.coin == 'bch' ? 'normal' : this.configFeeLevel;
        }
        this.setButtonText(this.wallet.credentials.m > 1, !!this.tx.paypro);
        if (this.tx.paypro)
            this.paymentTimeControl(this.tx.paypro.expires);
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelName = feeOpts[this.tx.feeLevel];
        this.updateTx(this.tx, this.wallet, { dryRun: true }).catch(err => {
            const previousView = this.navCtrl.getPrevious().name;
            switch (err) {
                case 'insufficient_funds':
                    if (this.showUseUnconfirmedMsg()) {
                        this.showErrorInfoSheet(this.translate.instant('You do not have enough confirmed funds to make this payment. Wait for your pending transactions to confirm or enable "Use unconfirmed funds" in Advanced Settings.'), this.translate.instant('No enough confirmed funds'), true);
                    }
                    else if (previousView === 'AmountPage') {
                        // Do not allow user to change or use max amount if previous view is not Amount
                        this.showInsufficientFundsInfoSheet();
                    }
                    else {
                        this.showErrorInfoSheet(this.translate.instant('You are trying to send more funds than you have available. Make sure you do not have funds locked by pending transaction proposals.'), this.translate.instant('Insufficient funds'), true);
                    }
                    break;
                default:
                    this.showErrorInfoSheet(err);
                    break;
            }
        });
    }
    showUseUnconfirmedMsg() {
        return (this.wallet.cachedStatus &&
            this.wallet.cachedStatus.balance.totalAmount >=
                this.tx.amount + this.tx.feeRate &&
            !this.tx.spendUnconfirmed);
    }
    setButtonText(isMultisig, isPayPro) {
        if (isPayPro) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to pay')
                : this.translate.instant('Click to pay');
        }
        else if (isMultisig) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to accept')
                : this.translate.instant('Click to accept');
            this.successText =
                this.wallet.credentials.n == 1
                    ? this.translate.instant('Payment Sent')
                    : this.translate.instant('Proposal created');
        }
        else {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to send')
                : this.translate.instant('Click to send');
            this.successText = this.translate.instant('Payment Sent');
        }
    }
    paymentTimeControl(expires) {
        const expirationTime = Math.floor(new Date(expires).getTime() / 1000);
        this.paymentExpired = false;
        this.setExpirationTime(expirationTime);
        const countDown = setInterval(() => {
            this.setExpirationTime(expirationTime, countDown);
        }, 1000);
    }
    setExpirationTime(expirationTime, countDown) {
        const now = Math.floor(Date.now() / 1000);
        if (now > expirationTime) {
            this.paymentExpired = true;
            this.remainingTimeStr = this.translate.instant('Expired');
            if (countDown) {
                /* later */
                clearInterval(countDown);
            }
            return;
        }
        const totalSecs = expirationTime - now;
        const m = Math.floor(totalSecs / 60);
        const s = totalSecs % 60;
        this.remainingTimeStr = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
    }
    updateTx(tx, wallet, opts) {
        return new Promise((resolve, reject) => {
            if (opts.clearCache) {
                tx.txp = {};
            }
            this.tx = tx;
            // End of quick refresh, before wallet is selected.
            if (!wallet) {
                return resolve();
            }
            this.onGoingProcessProvider.set('calculatingFee');
            this.feeProvider
                .getFeeRate(wallet.coin, tx.network, this.usingMerchantFee
                ? this.currencyProvider.getMaxMerchantFee(wallet.coin)
                : this.tx.feeLevel)
                .then(feeRate => {
                let msg;
                if (this.usingCustomFee) {
                    msg = this.translate.instant('Custom');
                    tx.feeLevelName = msg;
                }
                else if (this.usingMerchantFee) {
                    const maxAllowedFee = feeRate * 5;
                    this.logger.info(`Using Merchant Fee: ${tx.feeRate} vs. referent level (5 * feeRate) ${maxAllowedFee}`);
                    const isUtxo = this.currencyProvider.isUtxoCoin(wallet.coin);
                    if (tx.network != 'testnet' &&
                        tx.feeRate > maxAllowedFee &&
                        isUtxo) {
                        this.onGoingProcessProvider.set('calculatingFee');
                        this.showHighFeeSheet();
                    }
                    msg = this.translate.instant('This payment requires a miner fee of:');
                    this.merchantFeeLabel = msg;
                }
                else {
                    const feeOpts = this.feeProvider.getFeeOpts();
                    tx.feeLevelName = feeOpts[tx.feeLevel];
                    tx.feeRate = feeRate;
                }
                // call getSendMaxInfo if was selected from amount view
                if (tx.sendMax && this.isChain()) {
                    this.useSendMax(tx, wallet, opts)
                        .then(() => {
                        return resolve();
                    })
                        .catch(err => {
                        return reject(err);
                    });
                }
                else {
                    // txp already generated for this wallet?
                    if (tx.txp[wallet.id]) {
                        this.onGoingProcessProvider.clear();
                        return resolve();
                    }
                    this.buildTxp(tx, wallet, opts)
                        .then(() => {
                        this.onGoingProcessProvider.clear();
                        return resolve();
                    })
                        .catch(err => {
                        this.onGoingProcessProvider.clear();
                        return reject(err);
                    });
                }
            })
                .catch(err => {
                this.logger.warn('Error getting fee rate', err);
                this.onGoingProcessProvider.clear();
                return reject(this.translate.instant('Error getting fee rate'));
            });
        });
    }
    useSendMax(tx, wallet, opts) {
        return new Promise((resolve, reject) => {
            this.getSendMaxInfo(__WEBPACK_IMPORTED_MODULE_6_lodash__["clone"](tx), wallet)
                .then(sendMaxInfo => {
                if (sendMaxInfo) {
                    this.logger.debug('Send max info', sendMaxInfo);
                    if (sendMaxInfo.amount <= 0) {
                        this.showErrorInfoSheet(this.translate.instant('Not enough funds for fee'));
                        return resolve();
                    }
                    tx.sendMaxInfo = sendMaxInfo;
                    tx.amount = tx.sendMaxInfo.amount;
                    this.getAmountDetails();
                }
                this.showSendMaxWarning(wallet, sendMaxInfo);
                // txp already generated for this wallet?
                if (tx.txp[wallet.id]) {
                    return resolve();
                }
                this.buildTxp(tx, wallet, opts)
                    .then(() => {
                    return resolve();
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(() => {
                const msg = this.translate.instant('Error getting SendMax information');
                return reject(msg);
            });
        });
    }
    getFeeRate(amount, fee) {
        return (fee / (amount + fee)) * 100;
    }
    isHighFee(amount, fee) {
        return this.getFeeRate(amount, fee) > this.FEE_TOO_HIGH_LIMIT_PER;
    }
    showHighFeeSheet() {
        const minerFeeInfoSheet = this.actionSheetProvider.createInfoSheet('miner-fee');
        minerFeeInfoSheet.present();
    }
    buildTxp(tx, wallet, opts) {
        return new Promise((resolve, reject) => {
            this.getTxp(__WEBPACK_IMPORTED_MODULE_6_lodash__["clone"](tx), wallet, opts.dryRun)
                .then(txp => {
                if (this.currencyProvider.isUtxoCoin(tx.coin)) {
                    const per = this.getFeeRate(txp.amount, txp.fee);
                    txp.feeRatePerStr = per.toFixed(2) + '%';
                    txp.feeTooHigh = this.isHighFee(txp.amount, txp.fee);
                }
                if (txp.feeTooHigh) {
                    this.showHighFeeSheet();
                }
                tx.txp[wallet.id] = txp;
                this.tx = tx;
                this.logger.debug('Confirm. TX Fully Updated for wallet:' +
                    wallet.id +
                    ' Txp:' +
                    txp.id);
                return resolve();
            })
                .catch(err => {
                if (err.message == 'Insufficient funds') {
                    return reject('insufficient_funds');
                }
                else {
                    return reject(err);
                }
            });
        });
    }
    getSendMaxInfo(tx, wallet) {
        return new Promise((resolve, reject) => {
            if (!tx.sendMax)
                return resolve();
            this.onGoingProcessProvider.set('retrievingInputs');
            this.walletProvider
                .getSendMaxInfo(wallet, {
                feePerKb: tx.feeRate,
                excludeUnconfirmedUtxos: !tx.spendUnconfirmed,
                returnInputs: true
            })
                .then(res => {
                this.onGoingProcessProvider.clear();
                return resolve(res);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.logger.warn('Error getting send max info', err);
                return reject(err);
            });
        });
    }
    showSendMaxWarning(wallet, sendMaxInfo) {
        if (!sendMaxInfo)
            return;
        const warningMsg = this.verifyExcludedUtxos(wallet, sendMaxInfo);
        const coinName = this.currencyProvider.getCoinName(this.wallet.coin);
        const { unitToSatoshi } = this.currencyProvider.getPrecision(this.tx.coin);
        const fee = sendMaxInfo.fee / unitToSatoshi;
        const minerFeeNoticeInfoSheet = this.actionSheetProvider.createInfoSheet('miner-fee-notice', {
            coinName,
            fee,
            coin: this.tx.coin.toUpperCase(),
            msg: !__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](warningMsg) ? warningMsg : ''
        });
        minerFeeNoticeInfoSheet.present();
    }
    verifyExcludedUtxos(_, sendMaxInfo) {
        const warningMsg = [];
        if (sendMaxInfo.utxosBelowFee > 0) {
            const amountBelowFeeStr = sendMaxInfo.amountBelowFee /
                this.currencyProvider.getPrecision(this.tx.coin).unitToSatoshi;
            const message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountBelowFeeStr}} {{coin}} were excluded. These funds come from UTXOs smaller than the network fee provided.'), { amountBelowFeeStr, coin: this.tx.coin.toUpperCase() });
            warningMsg.push(message);
        }
        if (sendMaxInfo.utxosAboveMaxSize > 0) {
            const amountAboveMaxSizeStr = sendMaxInfo.amountAboveMaxSize /
                this.currencyProvider.getPrecision(this.tx.coin).unitToSatoshi;
            const message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountAboveMaxSizeStr}} {{coin}} were excluded. The maximum size allowed for a transaction was exceeded.'), { amountAboveMaxSizeStr, coin: this.tx.coin.toUpperCase() });
            warningMsg.push(message);
        }
        return warningMsg.join('\n');
    }
    getTxp(tx, wallet, dryRun) {
        return new Promise((resolve, reject) => {
            // ToDo: use a credential's (or fc's) function for this
            if (tx.description && !wallet.credentials.sharedEncryptingKey) {
                const msg = this.translate.instant('Could not add message to imported wallet without shared encrypting key');
                return reject(msg);
            }
            if (this.currencyProvider.isUtxoCoin(tx.coin) &&
                tx.amount > Number.MAX_SAFE_INTEGER) {
                const msg = this.translate.instant('Amount too big');
                return reject(msg);
            }
            const txp = {};
            // set opts.coin to wallet.coin
            txp.coin = wallet.coin;
            if (this.fromMultiSend) {
                txp.outputs = [];
                this.navParams.data.recipients.forEach(recipient => {
                    if (tx.coin && tx.coin == 'bch') {
                        recipient.toAddress = this.bitcoreCash
                            .Address(recipient.toAddress)
                            .toString(true);
                        recipient.addressToShow = this.walletProvider.getAddressView(tx.coin, tx.network, recipient.toAddress);
                    }
                    txp.outputs.push({
                        toAddress: recipient.toAddress,
                        amount: recipient.amount,
                        message: tx.description,
                        data: tx.data
                    });
                });
            }
            else if (tx.paypro) {
                txp.outputs = [];
                const { instructions } = tx.paypro;
                for (const instruction of instructions) {
                    txp.outputs.push({
                        toAddress: instruction.toAddress,
                        amount: instruction.amount,
                        message: instruction.message,
                        data: instruction.data
                    });
                }
            }
            else {
                txp.outputs = [
                    {
                        toAddress: tx.toAddress,
                        amount: tx.amount,
                        message: tx.description,
                        data: tx.data
                    }
                ];
            }
            if (tx.sendMaxInfo) {
                txp.inputs = tx.sendMaxInfo.inputs;
                txp.fee = tx.sendMaxInfo.fee;
            }
            else {
                if (this.usingCustomFee || this.usingMerchantFee) {
                    txp.feePerKb = tx.feeRate;
                }
                else
                    txp.feeLevel = tx.feeLevel;
            }
            txp.message = tx.description;
            if (tx.paypro) {
                txp.payProUrl = tx.payProUrl;
                tx.paypro.host = new URL(tx.payProUrl).host;
            }
            txp.excludeUnconfirmedUtxos = !tx.spendUnconfirmed;
            txp.dryRun = dryRun;
            if (tx.recipientType == 'wallet') {
                txp.customData = {
                    toWalletName: tx.name ? tx.name : null
                };
            }
            if (tx.tokenAddress) {
                txp.tokenAddress = tx.tokenAddress;
                for (const output of txp.outputs) {
                    if (!output.data) {
                        output.data = this.bwcProvider
                            .getCore()
                            .Transactions.get({ chain: 'ERC20' })
                            .encodeData({
                            recipients: [
                                { address: output.toAddress, amount: output.amount }
                            ],
                            tokenAddress: tx.tokenAddress
                        });
                    }
                }
            }
            this.walletProvider
                .getAddress(this.wallet, false)
                .then(address => {
                txp.from = address;
                this.walletProvider
                    .createTx(wallet, txp)
                    .then(ctxp => {
                    return resolve(ctxp);
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    showInsufficientFundsInfoSheet() {
        const insufficientFundsInfoSheet = this.actionSheetProvider.createInfoSheet('insufficient-funds');
        insufficientFundsInfoSheet.present();
        insufficientFundsInfoSheet.onDidDismiss(option => {
            if (option || typeof option === 'undefined') {
                this.isWithinWalletTabs()
                    ? this.navCtrl.pop()
                    : this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_9__tabs_tabs__["a" /* TabsPage */]); // using setRoot(TabsPage) as workaround when coming from scanner
            }
            else {
                this.tx.sendMax = true;
                this.setWallet(this.wallet);
            }
        });
    }
    showErrorInfoSheet(error, title, exit) {
        if (!error)
            return;
        this.logger.warn('ERROR:', error);
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        if (error.message === 'FINGERPRINT_CANCELLED' ||
            error.message === 'PASSWORD_CANCELLED') {
            this.hideSlideButton = false;
            return;
        }
        const infoSheetTitle = title ? title : this.translate.instant('Error');
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: this.bwcErrorProvider.msg(error), title: infoSheetTitle });
        errorInfoSheet.present();
        errorInfoSheet.onDidDismiss(() => {
            this.hideSlideButton = false;
            if (exit) {
                this.isWithinWalletTabs()
                    ? this.navCtrl.popToRoot()
                    : this.navCtrl.last().name == 'ConfirmCardPurchasePage'
                        ? this.navCtrl.pop()
                        : this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_9__tabs_tabs__["a" /* TabsPage */]); // using setRoot(TabsPage) as workaround when coming from scanner
            }
        });
    }
    toggleAddress() {
        this.showAddress = !this.showAddress;
    }
    onWalletSelect(wallet) {
        this.setWallet(wallet);
    }
    approve(tx, wallet) {
        if (!tx || !wallet)
            return undefined;
        this.hideSlideButton = true;
        if (this.paymentExpired) {
            this.showErrorInfoSheet(this.translate.instant('This bitcoin payment request has expired.'));
            return undefined;
        }
        this.onGoingProcessProvider.set('creatingTx');
        return this.getTxp(__WEBPACK_IMPORTED_MODULE_6_lodash__["clone"](tx), wallet, false)
            .then(txp => {
            return this.confirmTx(txp, wallet).then((nok) => {
                if (nok) {
                    if (this.isCordova) {
                        this.slideButton.isConfirmed(false);
                        this.hideSlideButton = false;
                    }
                    this.onGoingProcessProvider.clear();
                    return;
                }
                this.publishAndSign(txp, wallet);
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.warn('Error getting transaction proposal', err);
        });
    }
    confirmTx(txp, wallet) {
        return new Promise(resolve => {
            if (wallet.isPrivKeyEncrypted)
                return resolve(false);
            this.txFormatProvider.formatToUSD(wallet.coin, txp.amount).then(val => {
                const amountUsd = parseFloat(val);
                if (amountUsd <= this.CONFIRM_LIMIT_USD)
                    return resolve(false);
                const unit = txp.coin.toUpperCase();
                const amount = (this.tx.amount /
                    this.currencyProvider.getPrecision(txp.coin).unitToSatoshi).toFixed(8);
                const name = wallet.name;
                const message = this.replaceParametersProvider.replace(this.translate.instant('Sending {{amount}} {{unit}} from your {{name}} wallet'), { amount, unit, name });
                const okText = this.translate.instant('Confirm');
                const cancelText = this.translate.instant('Cancel');
                this.popupProvider
                    .ionicConfirm(null, message, okText, cancelText)
                    .then((ok) => {
                    return resolve(!ok);
                });
            });
        });
    }
    publishAndSign(txp, wallet) {
        if (!wallet.canSign) {
            return this.onlyPublish(txp, wallet);
        }
        return this.walletProvider
            .publishAndSign(wallet, txp)
            .then(txp => {
            this.onGoingProcessProvider.clear();
            if (this.config.confirmedTxsNotifications &&
                this.config.confirmedTxsNotifications.enabled) {
                this.txConfirmNotificationProvider.subscribe(wallet, {
                    txid: txp.txid
                });
            }
            return this.openFinishModal();
        })
            .catch(err => {
            if (this.isCordova)
                this.slideButton.isConfirmed(false);
            this.onGoingProcessProvider.clear();
            this.showErrorInfoSheet(err);
            if (txp.payProUrl) {
                this.logger.warn('Paypro error: removing payment proposal');
                this.walletProvider.removeTx(wallet, txp).catch(() => {
                    this.logger.warn('Could not delete payment proposal');
                });
            }
        });
    }
    onlyPublish(txp, wallet) {
        this.logger.info('No signing proposal: No private key');
        this.onGoingProcessProvider.set('sendingTx');
        return this.walletProvider
            .onlyPublish(wallet, txp)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.openFinishModal(true);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorInfoSheet(err);
        });
    }
    openFinishModal(onlyPublish) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            let params = {
                finishText: this.successText
            };
            if (onlyPublish) {
                const finishText = this.translate.instant('Payment Published');
                const finishComment = this.translate.instant('You could sign the transaction later in your wallet details');
                params = { finishText, finishComment };
            }
            const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_8__finish_finish__["a" /* FinishModalPage */], params, {
                showBackdrop: true,
                enableBackdropDismiss: false,
                cssClass: 'finish-modal'
            });
            yield modal.present();
            this.clipboardProvider.clearClipboardIfValidData([
                'PayPro',
                'BitcoinUri',
                'BitcoinCashUri',
                'InvoiceUri'
            ]);
            if (this.isWithinWalletTabs()) {
                this.close().then(() => {
                    this.events.publish('OpenWallet', this.wallet);
                });
            }
            else {
                // using setRoot(TabsPage) as workaround when coming from scanner
                this.app
                    .getRootNavs()[0]
                    .setRoot(__WEBPACK_IMPORTED_MODULE_9__tabs_tabs__["a" /* TabsPage */])
                    .then(() => {
                    setTimeout(() => {
                        this.events.publish('OpenWallet', this.wallet);
                    }, 1000);
                });
            }
        });
    }
    chooseFeeLevel() {
        if (this.tx.coin == 'bch')
            return;
        if (this.usingMerchantFee)
            return; // TODO: should we allow override?
        const txObject = {
            network: this.tx.network,
            feeLevel: this.tx.feeLevel,
            noSave: true,
            coin: this.tx.coin,
            customFeePerKB: this.usingCustomFee ? this.tx.feeRate : undefined,
            feePerSatByte: this.usingCustomFee ? this.tx.feeRate / 1000 : undefined
        };
        const myModal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_10__choose_fee_level_choose_fee_level__["a" /* ChooseFeeLevelPage */], txObject, {
            showBackdrop: true,
            enableBackdropDismiss: false
        });
        myModal.present();
        myModal.onDidDismiss(data => {
            this.onFeeModalDismiss(data);
        });
    }
    onFeeModalDismiss(data) {
        if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](data))
            return;
        this.logger.debug('New fee level chosen:' + data.newFeeLevel + ' was:' + this.tx.feeLevel);
        this.usingCustomFee = data.newFeeLevel == 'custom' ? true : false;
        if (this.tx.feeLevel == data.newFeeLevel && !this.usingCustomFee) {
            return;
        }
        this.tx.feeLevel = data.newFeeLevel;
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelName = feeOpts[this.tx.feeLevel];
        if (this.usingCustomFee)
            this.tx.feeRate = parseInt(data.customFeePerKB, 10);
        this.updateTx(this.tx, this.wallet, {
            clearCache: true,
            dryRun: true
        }).catch(err => {
            this.logger.warn('Error updateTx', err);
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        const id = this.wallet ? this.wallet.credentials.walletId : null;
        const params = {
            wallets: this.wallets,
            selectedWalletId: id,
            title: this.walletSelectorTitle
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(wallet => {
            this.onSelectWalletEvent(wallet);
        });
    }
    onSelectWalletEvent(wallet) {
        if (!__WEBPACK_IMPORTED_MODULE_6_lodash__["isEmpty"](wallet))
            this.onWalletSelect(wallet);
        this.isOpenSelector = false;
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], ConfirmPage.prototype, "slideButton", void 0);
ConfirmPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Component"])({
        selector: 'page-confirm',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/send/confirm/confirm.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{ \'Confirm\' | translate }}</ion-title>\n    <ion-buttons right *ngIf="isWithinWalletTabs()">\n      <button (click)="close()" ion-button>\n        {{\'Cancel\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content [ngClass]="{\'no-margin-bottom\': hideSlideButton}" no-bounce>\n  <ion-list *ngIf="tx">\n    <ion-item>\n      <div class="header-container">\n        <div class="sending-label">\n          <span translate *ngIf="!tx.sendMax">Sending</span>\n          <span translate *ngIf="tx.sendMax">Sending maximum amount</span>\n        </div>\n        <div class="amount-label">\n          <div class="amount">\n            <div>\n              {{amount}}\n              <span class="amount-coin">{{tx.coin | uppercase}}</span>\n            </div>\n            <img class="sending-img" src="assets/img/icon-tx-sent-outline.svg">\n          </div>\n          <div class="alternative">{{tx.amount | satToFiat: tx.coin}}</div>\n        </div>\n      </div>\n    </ion-item>\n    <button ion-item class="item-fee" [attr.detail-none]="usingMerchantFee ? \'\' : null" (click)="chooseFeeLevel()" [ngClass]="{\'warn\': wallet && tx.txp[wallet.id] && tx.txp[wallet.id].feeTooHigh, \'btn-opacity\': usingMerchantFee}" [disabled]="usingMerchantFee">\n      <div class="fee-title">\n        <span *ngIf="!merchantFeeLabel" translate>Miner fee:</span>\n        <span *ngIf="merchantFeeLabel">{{ merchantFeeLabel }}</span>\n        <br>\n        <b *ngIf="!merchantFeeLabel">{{tx.feeLevelName}}</b>\n      </div>\n      <div class="fee-loading" *ngIf="!wallet || !tx.txp[wallet.id]">\n        <div>...</div>\n        <div>...</div>\n      </div>\n      <div *ngIf="wallet && tx.txp[wallet.id]">\n        <span class="fee-amount">{{tx.txp[wallet.id].fee | satToUnit: getChain(tx.coin)}}</span>\n        <div class="fee-details">\n          <span>\n              {{tx.txp[wallet.id].fee | satToFiat: getChain(tx.coin)}}\n          </span>\n          <span *ngIf="tx.txp[wallet.id].feeRatePerStr">\n            &middot;\n            <span>\n              <ion-icon *ngIf="tx.txp[wallet.id].feeTooHigh" name="warning"></ion-icon>\n              {{tx.txp[wallet.id].feeRatePerStr}}\n              <span translate> of total amount</span>\n            </span>\n          </span>\n        </div>\n      </div>\n    </button>\n\n    <ion-item *ngIf="tx.paypro && wallet">\n      <span translate>Payment Expires:</span>\n      <ion-note *ngIf="!paymentExpired" item-end>{{remainingTimeStr}}</ion-note>\n      <ion-note *ngIf="paymentExpired" [ngStyle]="{\'color\': \'red\'}" item-end>{{\'Expired\' | translate}}</ion-note>\n    </ion-item>\n\n    <ion-item class="container-to" *ngIf="wallet">\n      <span translate>To</span>\n\n      <div class="payment-proposal-to" *ngIf="!tx.recipientType">\n        <img class="coin-img-{{tx.coin}}" *ngIf="!tx.paypro" src="assets/img/icon-{{tx.coin}}-small.svg" alt="Coin" />\n        <div class="ellipsis address-with-divider" *ngIf="!tx.paypro" copy-to-clipboard="{{ tx.origToAddress }}">\n          <span *ngIf="!tx.name">{{tx.origToAddress}}</span>\n          <span *ngIf="tx.name">{{tx.name}}</span>\n        </div>\n\n        <div class="paypro" *ngIf="tx.paypro">\n\n          <ion-icon *ngIf="tx.paypro.verified" name="lock" color="success"></ion-icon>\n          <ion-icon *ngIf="!tx.paypro.verified" name="unlock" color="danger"></ion-icon>\n\n          <span>{{tx.paypro.host || tx.paypro.toAddress}}</span>\n        </div>\n      </div>\n\n      <div class="wallet" *ngIf="tx.recipientType == \'wallet\'">\n        <ion-icon item-start>\n          <img [ngClass]="{ testnet: tx.network === \'testnet\' }" src="assets/img/currencies/{{tx.coin}}.svg" class="icon-wallet" />\n        </ion-icon>\n        <div class="ellipsis" copy-to-clipboard="{{ tx.origToAddress }}">\n          <span *ngIf="!tx.name">{{tx.origToAddress}}</span>\n          <span *ngIf="tx.name">{{tx.name}}</span>\n        </div>\n      </div>\n\n      <div class="wallet" *ngIf="tx.recipientType == \'contact\'" (longPress)="toggleAddress()">\n        <ion-icon class="item-gravatar" item-left>\n          <gravatar [name]="tx.name" [height]="35" [width]="35" [email]="tx.email"></gravatar>\n        </ion-icon>\n        <div class="ellipsis">\n          <span *ngIf="tx.name && !showAddress">{{tx.name}}</span>\n          <span *ngIf="tx.name && showAddress" copy-to-clipboard="{{ tx.toAddress }}">{{tx.toAddress}}</span>\n        </div>\n      </div>\n\n      <div class="wallet" (click)="showMultiplesOutputs = !showMultiplesOutputs">\n        <div class="multiple-length" *ngIf="fromMultiSend">\n          <img class="coin-img-{{tx.coin}}" src="assets/img/icon-{{tx.coin}}-small.svg" alt="Coin" />\n          <div class="ellipsis address-with-divider">\n            <span>\n              <span translate>Multiple recipients: </span>\n              <span>{{recipients?.length}}</span>\n            </span>\n          </div>\n        </div>\n        <div class="last-item" *ngIf="fromMultiSend" item-end>\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="showMultiplesOutputs" name="ios-arrow-up-outline"></ion-icon>\n            <ion-icon *ngIf="!showMultiplesOutputs" name="ios-arrow-down-outline"></ion-icon>\n          </button>\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-list detail-none *ngIf="tx && fromMultiSend && showMultiplesOutputs">\n      <ion-item *ngFor="let recipient of recipients" copy-to-clipboard="{{recipient.toAddress}}">\n        <div item-left>\n          <h2>\n            <span translate>To</span>:\n          </h2>\n          <h3>\n            <span translate>Amount</span>:\n          </h3>\n        </div>\n        <ion-note item-right text-end col-11>\n          <span class="output-note ellipsis">{{recipient.addressToShow || recipient.toAddress || recipient.address}}</span>\n          <span class="output-note ellipsis">{{recipient.amountToShow}} {{coin | uppercase}}\n            <span *ngIf="recipient.altAmountStr">({{recipient.altAmountStr}})</span>\n          </span>\n        </ion-note>\n      </ion-item>\n    </ion-list>\n\n    <button class="container-from" ion-item detail-none (click)="showWallets()" [ngClass]="{\'not-clickable\': isWithinWalletTabs()}">\n      <span translate>From</span>\n      <div class="wallet" *ngIf="wallet">\n        <ion-icon item-start>\n          <img [ngClass]="{ testnet: wallet.network === \'testnet\' }" src="assets/img/currencies/{{wallet.coin}}.svg" class="icon-wallet" />\n        </ion-icon>\n        <div>{{wallet.name}}</div>\n        <div class="last-item" item-end *ngIf="!isWithinWalletTabs()">\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n            <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n          </button>\n        </div>\n      </div>\n      <div class="wallet" *ngIf="!wallet">\n        <ion-icon item-start>\n          <img class="icon-wallet disabled" src="assets/img/icon-wallet.svg" />\n        </ion-icon>\n        <div translate>Select a wallet</div>\n        <div class="last-item" item-end>\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n            <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n          </button>\n        </div>\n      </div>\n    </button>\n\n    <ion-item>\n      <ion-label stacked>{{\'Memo\' | translate}}</ion-label>\n      <ion-textarea placeholder="{{\'Enter a transaction memo\' | translate}}" [(ngModel)]="tx.description" name="tx.description" autocomplete="off" autocorrect="off"></ion-textarea>\n    </ion-item>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [ngClass]="{\'slide-confirm-fast slide-confirm-down\': hideSlideButton, \'slide-confirm-slow\': !hideSlideButton}" [disabled]="!wallet || !tx?.txp[wallet.id] || paymentExpired" [buttonText]="buttonText" (slideDone)="approve(tx, wallet)">\n  </page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="approve(tx, wallet)" [disabled]="!wallet || !tx?.txp[wallet.id] || paymentExpired">{{buttonText}}</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/send/confirm/confirm.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_12__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_5_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_11__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_common__["d" /* DecimalPipe */],
        __WEBPACK_IMPORTED_MODULE_19__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_5_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_5_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_22__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_23__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_25__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_24__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_26__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_27__providers_tx_confirm_notification_tx_confirm_notification__["a" /* TxConfirmNotificationProvider */],
        __WEBPACK_IMPORTED_MODULE_28__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_29__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_31__wallet_tabs_wallet_tabs_provider__["a" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_clipboard_clipboard__["a" /* ClipboardProvider */],
        __WEBPACK_IMPORTED_MODULE_5_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_13__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_status_bar__["a" /* StatusBar */]])
], ConfirmPage);

//# sourceMappingURL=confirm.js.map

/***/ }),

/***/ 25:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Coin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CurrencyProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__coin__ = __webpack_require__(1467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__token__ = __webpack_require__(1468);





var Coin;
(function (Coin) {
    Coin["BTC"] = "btc";
    Coin["BCH"] = "bch";
    Coin["ETH"] = "eth";
    Coin["USDC"] = "usdc";
    Coin["GUSD"] = "gusd";
    Coin["PAX"] = "pax";
})(Coin || (Coin = {}));
let CurrencyProvider = class CurrencyProvider {
    constructor() {
        this.ratesApi = {};
        this.blockExplorerUrls = {};
        this.coinOpts = __WEBPACK_IMPORTED_MODULE_3__coin__["a" /* availableCoins */];
        this.availableTokens = Object.values(__WEBPACK_IMPORTED_MODULE_4__token__["a" /* TokenOpts */]);
        this.availableCoins = Object.keys(this.coinOpts);
        for (const opts of Object.values(this.coinOpts)) {
            const { paymentInfo, coin } = opts;
            const { blockExplorerUrls, ratesApi } = paymentInfo;
            this.blockExplorerUrls[coin] = blockExplorerUrls;
            this.ratesApi[coin] = ratesApi;
        }
    }
    isUtxoCoin(coin) {
        return !!this.coinOpts[coin].properties.isUtxo;
    }
    isSingleAddress(coin) {
        return !!this.coinOpts[coin].properties.singleAddress;
    }
    isSharedCoin(coin) {
        return !!this.coinOpts[coin].properties.hasMultiSig;
    }
    isERCToken(coin) {
        return !!this.coinOpts[coin].properties.isERCToken;
    }
    getLinkedEthWallet(coin, walletId) {
        if (!this.coinOpts[coin].properties.isERCToken)
            return null;
        return walletId.replace(/-0x.*$/, '');
    }
    isMultiSend(coin) {
        return !!this.coinOpts[coin].properties.hasMultiSend;
    }
    getAvailableCoins() {
        return this.availableCoins;
    }
    getAvailableChains() {
        return __WEBPACK_IMPORTED_MODULE_2_lodash__["uniq"](__WEBPACK_IMPORTED_MODULE_2_lodash__["map"](Object.values(this.coinOpts), (opts) => opts.chain.toLowerCase()));
    }
    getAvailableTokens() {
        return this.availableTokens;
    }
    getMultiSigCoins() {
        return this.availableCoins.filter(coin => this.isSharedCoin(coin));
    }
    getCoinName(coin) {
        return this.coinOpts[coin].name;
    }
    getChain(coin) {
        return this.coinOpts[coin].chain;
    }
    getRatesApi() {
        return this.ratesApi;
    }
    getBlockExplorerUrls() {
        return this.blockExplorerUrls;
    }
    getPaymentCode(coin) {
        return this.coinOpts[coin].paymentInfo.paymentCode;
    }
    getPrecision(coin) {
        return this.coinOpts[coin].unitInfo;
    }
    getProtocolPrefix(coin, network) {
        return this.coinOpts[coin].paymentInfo.protocolPrefix[network];
    }
    getFeeUnits(coin) {
        return this.coinOpts[coin].feeInfo;
    }
    getMaxMerchantFee(coin) {
        return this.coinOpts[coin].feeInfo.maxMerchantFee;
    }
    getTheme(coin) {
        return this.coinOpts[coin].theme;
    }
};
CurrencyProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [])
], CurrencyProvider);

//# sourceMappingURL=currency.js.map

/***/ }),

/***/ 250:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayCardIntroPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bitpay_account_bitpay_account__ = __webpack_require__(463);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bitpay_card_bitpay_card__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__bitpay_card__ = __webpack_require__(327);






// providers





// pages

let BitPayCardIntroPage = class BitPayCardIntroPage {
    constructor(translate, actionSheetCtrl, navParams, bitPayAccountProvider, popupProvider, bitPayCardProvider, navCtrl, externalLinkProvider, statusBar, platformProvider) {
        this.translate = translate;
        this.actionSheetCtrl = actionSheetCtrl;
        this.navParams = navParams;
        this.bitPayAccountProvider = bitPayAccountProvider;
        this.popupProvider = popupProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.navCtrl = navCtrl;
        this.externalLinkProvider = externalLinkProvider;
        this.statusBar = statusBar;
        this.platformProvider = platformProvider;
    }
    ionViewWillEnter() {
        if (this.platformProvider.isIOS) {
            this.statusBar.styleLightContent();
        }
        if (this.navParams.data.secret) {
            let pairData = {
                secret: this.navParams.data.secret,
                email: this.navParams.data.email,
                otp: this.navParams.data.otp
            };
            let pairingReason = this.translate.instant('add your BitPay Visa card(s)');
            this.bitPayAccountProvider.pair(pairData, pairingReason, (err, paired, apiContext) => {
                if (err) {
                    this.popupProvider.ionicAlert(this.translate.instant('Error pairing BitPay Account'), err);
                    return;
                }
                if (paired) {
                    this.bitPayCardProvider.sync(apiContext, (err, cards) => {
                        if (err) {
                            this.popupProvider.ionicAlert(this.translate.instant('Error updating Debit Cards'), err);
                            return;
                        }
                        // Fixes mobile navigation
                        setTimeout(() => {
                            if (cards[0]) {
                                this.navCtrl
                                    .push(__WEBPACK_IMPORTED_MODULE_11__bitpay_card__["a" /* BitPayCardPage */], { id: cards[0].id }, { animate: false })
                                    .then(() => {
                                    let previousView = this.navCtrl.getPrevious();
                                    this.navCtrl.removeView(previousView);
                                });
                            }
                        }, 200);
                    });
                }
            });
        }
        this.bitPayAccountProvider.getAccounts((err, accounts) => {
            if (err) {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                return;
            }
            this.accounts = accounts;
        });
    }
    ionViewDidEnter() {
        this.bitPayCardProvider.logEvent('legacycard_view_setup', {});
    }
    ionViewWillLeave() {
        if (this.platformProvider.isIOS) {
            this.statusBar.styleLightContent();
        }
    }
    bitPayCardInfo() {
        let url = 'https://bitpay.com/visa/faq';
        this.externalLinkProvider.open(url);
    }
    orderBitPayCard() {
        this.bitPayCardProvider.logEvent('legacycard_order', {});
        let url = 'https://bitpay.com/visa/get-started';
        this.externalLinkProvider.open(url);
    }
    connectBitPayCard() {
        this.bitPayCardProvider.logEvent('legacycard_connect', {});
        if (this.accounts.length == 0) {
            this.startPairBitPayAccount();
        }
        else {
            this.showAccountSelector();
        }
    }
    startPairBitPayAccount() {
        this.navCtrl.popToRoot({ animate: false }); // Back to Root
        let url = 'https://bitpay.com/visa/dashboard/add-to-bitpay-wallet-confirm';
        this.externalLinkProvider.open(url);
    }
    showAccountSelector() {
        let options = [];
        __WEBPACK_IMPORTED_MODULE_5_lodash__["forEach"](this.accounts, account => {
            options.push({
                text: (account.givenName || account.familyName) +
                    ' (' +
                    account.email +
                    ')',
                handler: () => {
                    this.onAccountSelect(account);
                }
            });
        });
        // Add account
        options.push({
            text: this.translate.instant('Add account'),
            handler: () => {
                this.onAccountSelect();
            }
        });
        // Cancel
        options.push({
            text: this.translate.instant('Cancel'),
            role: 'cancel'
        });
        let actionSheet = this.actionSheetCtrl.create({
            title: this.translate.instant('From BitPay account'),
            buttons: options
        });
        actionSheet.present();
    }
    onAccountSelect(account) {
        if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isUndefined"](account)) {
            this.startPairBitPayAccount();
        }
        else {
            this.bitPayCardProvider.sync(account.apiContext, err => {
                if (err) {
                    this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                    return;
                }
                this.navCtrl.pop();
            });
        }
    }
};
BitPayCardIntroPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-bitpay-card-intro',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/bitpay-card/bitpay-card-intro/bitpay-card-intro.html"*/'<ion-header no-border>\n  <ion-navbar transparent>\n    <ion-buttons right>\n      <button ion-button icon-only (click)="bitPayCardInfo()">\n        <ion-icon name="information-circle"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="bitpayCard-illustration">\n    <img class="bitpayCard-illustration-img" src="assets/img/bitpay-card/bitpay-card-visa.svg" />\n  </div>\n  <ion-slides pager="true">\n    <ion-slide>\n      <p class="slider-text" translate>\n        Turn bitcoin into dollars, swipe anywhere Visa is accepted.\n      </p>\n    </ion-slide>\n    <ion-slide>\n      <p class="slider-text" translate>\n        Get local cash anywhere you go, from any Visa compatible ATM. ATM bank fees may apply.\n      </p>\n    </ion-slide>\n    <ion-slide>\n      <p class="slider-text" translate>\n        Pay 0% fees to turn bitcoin into dollars.\n      </p>\n    </ion-slide>\n  </ion-slides>\n  <div padding>\n    <button ion-button class="button-standard" (click)="orderBitPayCard()">\n      {{\'Order the BitPay Card\' | translate}}\n    </button>\n    <button ion-button clear color="blank" class="button-standard" (click)="connectBitPayCard()">\n      {{\'Connect my BitPay Card\' | translate}}\n    </button>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/bitpay-card/bitpay-card-intro/bitpay-card-intro.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["a" /* ActionSheetController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bitpay_account_bitpay_account__["a" /* BitPayAccountProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_8__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */],
        __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__["a" /* PlatformProvider */]])
], BitPayCardIntroPage);

//# sourceMappingURL=bitpay-card-intro.js.map

/***/ }),

/***/ 26:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActionSheetProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_incoming_data_menu_incoming_data_menu__ = __webpack_require__(854);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_info_sheet_info_sheet__ = __webpack_require__(856);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_options_sheet_options_sheet__ = __webpack_require__(858);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_wallet_selector_wallet_selector__ = __webpack_require__(859);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_dom_dom__ = __webpack_require__(427);







let ActionSheetProvider = class ActionSheetProvider {
    constructor(domProvider) {
        this.domProvider = domProvider;
    }
    createOptionsSheet(type, params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_4__components_options_sheet_options_sheet__["a" /* OptionsSheetComponent */], type, params).instance;
    }
    createIncomingDataMenu(params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_2__components_incoming_data_menu_incoming_data_menu__["a" /* IncomingDataMenuComponent */], null, params).instance;
    }
    createInfoSheet(type, params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_3__components_info_sheet_info_sheet__["b" /* InfoSheetComponent */], type, params)
            .instance;
    }
    createWalletSelector(params) {
        return this.setupSheet(__WEBPACK_IMPORTED_MODULE_5__components_wallet_selector_wallet_selector__["a" /* WalletSelectorComponent */], null, params).instance;
    }
    setupSheet(componentType, sheetType, params) {
        const sheet = this.domProvider.appendComponentToBody(componentType);
        sheet.instance.componentRef = sheet;
        sheet.instance.sheetType = sheetType;
        sheet.instance.params = params;
        return sheet;
    }
};
ActionSheetProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_dom_dom__["a" /* DomProvider */]])
], ActionSheetProvider);

//# sourceMappingURL=action-sheet.js.map

/***/ }),

/***/ 27:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExternalLinkProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__electron_electron__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__popup_popup__ = __webpack_require__(18);



// providers



let ExternalLinkProvider = class ExternalLinkProvider {
    constructor(popupProvider, logger, platformProvider, electronProvider) {
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.electronProvider = electronProvider;
        this.logger.debug('ExternalLinkProvider initialized');
    }
    restoreHandleOpenURL(old) {
        setTimeout(() => {
            window.handleOpenURL = old;
        }, 500);
    }
    open(url, optIn, title, message, okText, cancelText) {
        return new Promise(resolve => {
            if (optIn) {
                this.popupProvider
                    .ionicConfirm(title, message, okText, cancelText)
                    .then((res) => {
                    this.openBrowser(res, url);
                    resolve();
                });
            }
            else {
                this.openBrowser(true, url);
                resolve();
            }
        });
    }
    openBrowser(res, url) {
        let old = window.handleOpenURL;
        // Ignore external URLs: avoid opening action sheet
        window.handleOpenURL = url => {
            this.logger.debug('Skip: ' + url);
        };
        if (res)
            this.platformProvider.isElectron
                ? this.electronProvider.openExternalLink(url)
                : window.open(url, '_system');
        this.restoreHandleOpenURL(old);
    }
};
ExternalLinkProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_3__electron_electron__["a" /* ElectronProvider */]])
], ExternalLinkProvider);

//# sourceMappingURL=external-link.js.map

/***/ }),

/***/ 28:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_language_language__ = __webpack_require__(244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__platform_platform__ = __webpack_require__(12);




// providers





/* TODO: implement interface properly
interface App {
  packageName: string;
  packageDescription: string;
  packageNameId: string;
  themeColor: string;
  userVisibleName: string;
  purposeLine: string;
  bundleName: string;
  appUri: string;
  name: string;
  nameNoSpace: string;
  nameCase: string;
  nameCaseNoSpace: string;
  gitHubRepoName: string;
  gitHubRepoUrl: string;
  gitHubRepoBugs: string;
  disclaimerUrl: string;
  url: string;
  appDescription: string;
  winAppName: string;
  WindowsStoreIdentityName: string;
  WindowsStoreDisplayName: string;
  windowsAppId: string;
  pushSenderId: string;
  description: string;
  version: string;
  androidVersion: string;
  commitHash: string;
  _extraCSS: string;
  _enabledExtensions;
}*/
let AppProvider = class AppProvider {
    constructor(http, logger, language, config, persistence, file, platformProvider) {
        this.http = http;
        this.logger = logger;
        this.language = language;
        this.config = config;
        this.persistence = persistence;
        this.file = file;
        this.platformProvider = platformProvider;
        this.info = {};
        this.jsonPathApp = 'assets/appConfig.json';
        this.jsonPathServices = 'assets/externalServices.json';
        this.logger.debug('AppProvider initialized');
    }
    load() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield Promise.all([this.getInfo(), this.loadProviders()]);
        });
    }
    getInfo() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            [this.servicesInfo, this.info] = yield Promise.all([
                this.getServicesInfo(),
                this.getAppInfo()
            ]);
            if (this.platformProvider.isCordova) {
                this.info = JSON.parse(this.info);
                this.servicesInfo = JSON.parse(this.servicesInfo);
            }
        });
    }
    loadProviders() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.persistence.load();
            yield this.config.load();
            this.language.load();
        });
    }
    getAppInfo() {
        if (this.platformProvider.isCordova) {
            return this.file.readAsText(this.file.applicationDirectory + 'www/', this.jsonPathApp);
        }
        else {
            return this.http.get(this.jsonPathApp).toPromise();
        }
    }
    getServicesInfo() {
        if (this.platformProvider.isCordova) {
            return this.file.readAsText(this.file.applicationDirectory + 'www/', this.jsonPathServices);
        }
        else {
            return this.http.get(this.jsonPathServices).toPromise();
        }
    }
};
AppProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__["a" /* File */],
        __WEBPACK_IMPORTED_MODULE_8__platform_platform__["a" /* PlatformProvider */]])
], AppProvider);

//# sourceMappingURL=app.js.map

/***/ }),

/***/ 285:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__action_sheet__ = __webpack_require__(855);



class ActionSheetParent {
    present() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            return this.actionSheet.present(this.componentRef);
        });
    }
    dismiss(data) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.actionSheet.dismiss(data);
        });
    }
    onDidDismiss(func) {
        this.dismissFunction = func;
        this.actionSheet.dismissFunction = func;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ActionSheetParent;

__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2__action_sheet__["a" /* ActionSheetComponent */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2__action_sheet__["a" /* ActionSheetComponent */])
], ActionSheetParent.prototype, "actionSheet", void 0);
//# sourceMappingURL=action-sheet-parent.js.map

/***/ }),

/***/ 286:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ElectronProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);



let ElectronProvider = class ElectronProvider {
    constructor(logger) {
        this.logger = logger;
        this.logger.debug('ElectronProvider initialized');
    }
    readFromClipboard() {
        const { clipboard } = window.require('electron');
        return clipboard.readText();
    }
    writeToClipboard(text) {
        const { clipboard } = window.require('electron');
        return clipboard.writeText(text);
    }
    clearClipboard() {
        const { clipboard } = window.require('electron');
        clipboard.clear();
    }
    openExternalLink(url) {
        const { shell } = window.require('electron');
        return shell.openExternal(url);
    }
};
ElectronProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], ElectronProvider);

//# sourceMappingURL=electron.js.map

/***/ }),

/***/ 317:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppIdentityProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_bitauth__ = __webpack_require__(971);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_bitauth___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_bitauth__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);



// providers



let AppIdentityProvider = class AppIdentityProvider {
    constructor(logger, persistenceProvider) {
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.logger.debug('AppIdentityProvider initialized');
    }
    getIdentity(network, cb) {
        let pubkey;
        let isNew;
        this.persistenceProvider.getAppIdentity(network).then(data => {
            let appIdentity = data || {};
            if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](appIdentity) || (appIdentity && !appIdentity.priv)) {
                isNew = true;
                appIdentity = __WEBPACK_IMPORTED_MODULE_4_bitauth__["generateSin"]();
            }
            try {
                pubkey = __WEBPACK_IMPORTED_MODULE_4_bitauth__["getPublicKeyFromPrivateKey"](appIdentity.priv);
                __WEBPACK_IMPORTED_MODULE_4_bitauth__["getSinFromPublicKey"](pubkey);
                if (isNew)
                    this.persistenceProvider.setAppIdentity(network, appIdentity);
            }
            catch (e) {
                return cb(e);
            }
            return cb(null, appIdentity);
        });
    }
};
AppIdentityProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__persistence_persistence__["b" /* PersistenceProvider */]])
], AppIdentityProvider);

//# sourceMappingURL=app-identity.js.map

/***/ }),

/***/ 32:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_text_encoding__ = __webpack_require__(1955);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_text_encoding___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_text_encoding__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__address_address__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__fee_fee__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__filter_filter__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__rate_rate__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__touchid_touchid__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__tx_format_tx_format__ = __webpack_require__(71);






// Providers















let WalletProvider = WalletProvider_1 = class WalletProvider {
    constructor(logger, bwcProvider, txFormatProvider, configProvider, currencyProvider, persistenceProvider, bwcErrorProvider, rateProvider, filter, popupProvider, onGoingProcessProvider, touchidProvider, events, feeProvider, translate, addressProvider, keyProvider) {
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.txFormatProvider = txFormatProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.persistenceProvider = persistenceProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.rateProvider = rateProvider;
        this.filter = filter;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.touchidProvider = touchidProvider;
        this.events = events;
        this.feeProvider = feeProvider;
        this.translate = translate;
        this.addressProvider = addressProvider;
        this.keyProvider = keyProvider;
        // Ratio low amount warning (fee/amount) in incoming TX
        this.LOW_AMOUNT_RATIO = 0.15;
        // Ratio of "many utxos" warning in total balance (fee/amount)
        this.TOTAL_LOW_WARNING_RATIO = 0.3;
        this.WALLET_STATUS_MAX_TRIES = 5;
        this.WALLET_STATUS_DELAY_BETWEEN_TRIES = 1.6 * 1000;
        this.SOFT_CONFIRMATION_LIMIT = 12;
        this.SAFE_CONFIRMATIONS = 6;
        this.errors = this.bwcProvider.getErrors();
        this.logger.debug('WalletProvider initialized');
        this.isPopupOpen = false;
    }
    invalidateCache(wallet) {
        if (wallet.cachedStatus)
            wallet.cachedStatus.isValid = false;
        if (wallet.completeHistory)
            wallet.completeHistoryIsValid = false;
        if (wallet.cachedActivity)
            wallet.cachedActivity.isValid = false;
    }
    fetchStatus(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            const walletId = wallet.id;
            const processPendingTxps = status => {
                const txps = status.pendingTxps;
                const now = Math.floor(Date.now() / 1000);
                __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txps, tx => {
                    tx = this.txFormatProvider.processTx(wallet.coin, tx);
                    // no future transactions...
                    if (tx.createdOn > now)
                        tx.createdOn = now;
                    tx.wallet = wallet;
                    if (!tx.wallet) {
                        this.logger.error('no wallet at txp?');
                        return;
                    }
                    const action = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](tx.actions, {
                        copayerId: tx.wallet.copayerId
                    });
                    if (!action && tx.status == 'pending') {
                        tx.pendingForUs = true;
                    }
                    if (action && action.type == 'accept') {
                        tx.statusForUs = 'accepted';
                    }
                    else if (action && action.type == 'reject') {
                        tx.statusForUs = 'rejected';
                    }
                    else {
                        tx.statusForUs = 'pending';
                    }
                    if (!tx.deleteLockTime)
                        tx.canBeRemoved = true;
                });
                wallet.pendingTxps = txps;
            };
            const cacheBalance = (wallet, balance) => {
                if (!balance)
                    return;
                const configGet = this.configProvider.get();
                const config = configGet.wallet;
                const cache = wallet.cachedStatus;
                // Address with Balance
                cache.balanceByAddress = balance.byAddress;
                // Total wallet balance is same regardless of 'spend unconfirmed funds' setting.
                cache.totalBalanceSat = balance.totalAmount;
                // Spend unconfirmed funds
                if (config.spendUnconfirmed) {
                    cache.lockedBalanceSat = balance.lockedAmount;
                    cache.availableBalanceSat = balance.availableAmount;
                    cache.totalBytesToSendMax = balance.totalBytesToSendMax;
                    cache.pendingAmount = 0;
                    cache.spendableAmount = balance.totalAmount - balance.lockedAmount;
                }
                else {
                    cache.lockedBalanceSat = balance.lockedConfirmedAmount;
                    cache.availableBalanceSat = balance.availableConfirmedAmount;
                    cache.totalBytesToSendMax = balance.totalBytesToSendConfirmedMax;
                    cache.pendingAmount =
                        balance.totalAmount - balance.totalConfirmedAmount;
                    cache.spendableAmount =
                        balance.totalConfirmedAmount - balance.lockedAmount;
                }
                // Selected unit
                cache.unitToSatoshi = this.currencyProvider.getPrecision(wallet.coin).unitToSatoshi;
                cache.satToUnit = 1 / cache.unitToSatoshi;
                // STR
                cache.totalBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.totalBalanceSat);
                cache.lockedBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.lockedBalanceSat);
                cache.availableBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.availableBalanceSat);
                cache.spendableBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.spendableAmount);
                cache.pendingBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.pendingAmount);
                cache.alternativeName = config.settings.alternativeName;
                cache.alternativeIsoCode = config.settings.alternativeIsoCode;
                this.rateProvider
                    .whenRatesAvailable(wallet.coin)
                    .then(() => {
                    const availableBalanceAlternative = this.rateProvider.toFiat(cache.availableBalanceSat, cache.alternativeIsoCode, wallet.coin);
                    const totalBalanceAlternative = this.rateProvider.toFiat(cache.totalBalanceSat, cache.alternativeIsoCode, wallet.coin);
                    const pendingBalanceAlternative = this.rateProvider.toFiat(cache.pendingAmount, cache.alternativeIsoCode, wallet.coin);
                    const lockedBalanceAlternative = this.rateProvider.toFiat(cache.lockedBalanceSat, cache.alternativeIsoCode, wallet.coin);
                    const spendableBalanceAlternative = this.rateProvider.toFiat(cache.spendableAmount, cache.alternativeIsoCode, wallet.coin);
                    const alternativeConversionRate = this.rateProvider.toFiat(100000000, cache.alternativeIsoCode, wallet.coin);
                    cache.availableBalanceAlternative = this.filter.formatFiatAmount(availableBalanceAlternative);
                    cache.totalBalanceAlternative = this.filter.formatFiatAmount(totalBalanceAlternative);
                    cache.pendingBalanceAlternative = this.filter.formatFiatAmount(pendingBalanceAlternative);
                    cache.lockedBalanceAlternative = this.filter.formatFiatAmount(lockedBalanceAlternative);
                    cache.spendableBalanceAlternative = this.filter.formatFiatAmount(spendableBalanceAlternative);
                    cache.alternativeConversionRate = this.filter.formatFiatAmount(alternativeConversionRate);
                    cache.alternativeBalanceAvailable = true;
                    cache.isRateAvailable = true;
                })
                    .catch(err => {
                    this.logger.warn('Could not get rates: ', err);
                });
            };
            const isStatusCached = () => {
                return wallet.cachedStatus && wallet.cachedStatus.isValid;
            };
            const cacheStatus = (status) => {
                if (status.wallet && status.wallet.scanStatus == 'running')
                    return;
                wallet.cachedStatus = status || {};
                const cache = wallet.cachedStatus;
                cache.statusUpdatedOn = Date.now();
                cache.isValid = true;
                cache.email = status.preferences ? status.preferences.email : null;
                cacheBalance(wallet, status.balance);
            };
            const checkAndUpdateAdddress = () => {
                // Check address
                this.isAddressUsed(wallet, wallet.cachedStatus.balance.byAddress).then(used => {
                    const isSingleAddress = wallet.cachedStatus.wallet &&
                        wallet.cachedStatus.wallet.singleAddress;
                    if (used && !isSingleAddress) {
                        this.logger.debug('Current Wallet address used. Creating new');
                        // Force new address
                        this.getAddress(wallet, true).catch(err => {
                            this.logger.warn('Failed to create address: ', err);
                        });
                    }
                });
            };
            const hasMeet = (s1, s2) => {
                let diff = false;
                __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](s1, (v, k) => {
                    if (s2[k] == v)
                        diff = true;
                    else
                        this.logger.debug(`Status condition not meet: ${k} is ${s2[k]} not ${v}`);
                });
                return diff;
            };
            const doFetchStatus = (tries = 0) => {
                return new Promise((resolve, reject) => {
                    if (isStatusCached() && !opts.force && !opts.until) {
                        this.logger.debug('Status cache hit for ' + wallet.id);
                        // This will update exchange rates
                        cacheStatus(wallet.cachedStatus);
                        //
                        checkAndUpdateAdddress();
                        processPendingTxps(wallet.cachedStatus);
                        return resolve(wallet.cachedStatus);
                    }
                    tries = tries || 0;
                    const { token } = wallet.credentials;
                    wallet.getStatus({ tokenAddress: token ? token.address : '' }, (err, status) => {
                        if (err) {
                            if (err instanceof this.errors.NOT_AUTHORIZED) {
                                return reject('WALLET_NOT_REGISTERED');
                            }
                            return reject(err);
                        }
                        if (opts.until) {
                            if (!hasMeet(opts.until, status.balance) &&
                                tries < this.WALLET_STATUS_MAX_TRIES) {
                                this.logger.debug('Retrying update... ' +
                                    walletId +
                                    ' Try:' +
                                    tries +
                                    ' until:', opts.until);
                                return setTimeout(() => {
                                    return resolve(doFetchStatus(++tries));
                                }, this.WALLET_STATUS_DELAY_BETWEEN_TRIES * tries);
                            }
                            else {
                                this.logger.debug('# Got Wallet Status for: ' + wallet.id + ' after meeting:', opts.until);
                            }
                        }
                        else {
                            this.logger.debug('# Got Wallet Status for: ' + wallet.id);
                        }
                        processPendingTxps(status);
                        cacheStatus(status);
                        wallet.scanning =
                            status.wallet && status.wallet.scanStatus == 'running';
                        return resolve(status);
                    });
                });
            };
            /* ========== Start =========== */
            if (opts.until && hasMeet(opts.until, wallet.cachedStatus.balance)) {
                this.logger.debug('Status change already meet: ' + wallet.credentials.walletName);
                return resolve(wallet.cachedStatus);
            }
            if (WalletProvider_1.statusUpdateOnProgress[wallet.id] && !opts.until) {
                this.logger.info('!! Status update already on progress for: ' +
                    wallet.credentials.walletName);
                return reject('INPROGRESS');
            }
            WalletProvider_1.statusUpdateOnProgress[wallet.id] = true;
            doFetchStatus()
                .then(status => {
                WalletProvider_1.statusUpdateOnProgress[wallet.id] = false;
                resolve(status);
            })
                .catch(err => {
                WalletProvider_1.statusUpdateOnProgress[wallet.id] = false;
                return reject(err);
            });
        });
    }
    // Check address
    isAddressUsed(wallet, byAddress) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getLastAddress(wallet.id)
                .then(addr => {
                const used = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](byAddress, {
                    address: addr
                });
                return resolve(used);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getAddressView(coin, network, address) {
        if (coin != 'bch')
            return address;
        const protoAddr = this.getProtoAddress(coin, network, address);
        return protoAddr;
    }
    getProtoAddress(coin, network, address) {
        const proto = this.getProtocolHandler(coin, network);
        const protoAddr = proto + ':' + address;
        return protoAddr;
    }
    getAddress(wallet, forceNew) {
        return new Promise((resolve, reject) => {
            let walletId = wallet.id;
            const { token } = wallet.credentials;
            if (token) {
                walletId = wallet.id.replace(`-${token.address}`, '');
            }
            this.persistenceProvider
                .getLastAddress(walletId)
                .then((addr) => {
                if (addr) {
                    // prevent to show legacy address
                    const isBchLegacy = wallet.coin == 'bch' && addr.match(/^[CHmn]/);
                    if (!forceNew && !isBchLegacy)
                        return resolve(addr);
                }
                if (!wallet.isComplete())
                    return reject(this.bwcErrorProvider.msg('WALLET_NOT_COMPLETE'));
                if (wallet.needsBackup) {
                    return reject(this.bwcErrorProvider.msg('WALLET_NEEDS_BACKUP'));
                }
                this.createAddress(wallet)
                    .then(_addr => {
                    this.persistenceProvider
                        .storeLastAddress(walletId, _addr)
                        .then(() => {
                        return resolve(_addr);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    createAddress(wallet) {
        return new Promise((resolve, reject) => {
            this.logger.info('Creating address for wallet:', wallet.id);
            wallet.createAddress({}, (err, addr) => {
                if (err) {
                    let prefix = this.translate.instant('Could not create address');
                    if (err instanceof this.errors.MAIN_ADDRESS_GAP_REACHED ||
                        (err.message && err.message == 'MAIN_ADDRESS_GAP_REACHED')) {
                        this.logger.warn(this.bwcErrorProvider.msg(err, 'Server Error'));
                        prefix = null;
                        if (!this.isPopupOpen) {
                            this.isPopupOpen = true;
                            this.popupProvider
                                .ionicAlert(null, this.bwcErrorProvider.msg('MAIN_ADDRESS_GAP_REACHED'))
                                .then(() => {
                                this.isPopupOpen = false;
                            });
                        }
                        wallet.getMainAddresses({
                            reverse: true,
                            limit: 1
                        }, (err, addr) => {
                            if (err)
                                return reject(err);
                            return resolve(addr[0].address);
                        });
                    }
                    else {
                        const msg = this.bwcErrorProvider.msg(err, prefix);
                        return reject(msg);
                    }
                }
                else if (!this.addressProvider.isValid(addr.address)) {
                    this.logger.error('Invalid address generated: ', addr.address);
                    const msg = 'INVALID_ADDRESS';
                    return reject(msg);
                }
                else {
                    return resolve(addr.address);
                }
            });
        });
    }
    getSavedTxs(walletId) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getTxHistory(walletId)
                .then(txs => {
                let localTxs = [];
                if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txs)) {
                    return resolve(localTxs);
                }
                localTxs = txs;
                return resolve(__WEBPACK_IMPORTED_MODULE_4_lodash__["compact"](localTxs));
            })
                .catch((err) => {
                return reject(err);
            });
        });
    }
    fetchTxsFromServer(wallet, skip, endingTxid, limit) {
        return new Promise((resolve, reject) => {
            let res = [];
            const result = {
                res,
                shouldContinue: res.length >= limit
            };
            const { token } = wallet.credentials;
            wallet.getTxHistory({
                skip,
                limit,
                tokenAddress: token ? token.address : ''
            }, (err, txsFromServer) => {
                if (err)
                    return reject(err);
                if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txsFromServer))
                    return resolve(result);
                res = __WEBPACK_IMPORTED_MODULE_4_lodash__["takeWhile"](txsFromServer, tx => {
                    return tx.txid != endingTxid;
                });
                result.res = res;
                result.shouldContinue = res.length >= limit;
                return resolve(result);
            });
        });
    }
    updateLocalTxHistory(wallet, progressFn, opts = {}) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            const FIRST_LIMIT = 5;
            const LIMIT = 100;
            let requestLimit = FIRST_LIMIT;
            const walletId = wallet.credentials.walletId;
            WalletProvider_1.progressFn[walletId] = progressFn || (() => { });
            let foundLimitTx = [];
            const fixTxsUnit = (txs) => {
                if (!txs || !txs[0] || !txs[0].amountStr)
                    return;
                const cacheCoin = txs[0].amountStr.split(' ')[1];
                if (cacheCoin == 'bits') {
                    this.logger.debug('Fixing Tx Cache Unit to: ' + wallet.coin);
                    __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txs, tx => {
                        tx.amountStr = this.txFormatProvider.formatAmountStr(wallet.coin, tx.amount);
                        tx.feeStr = this.txFormatProvider.formatAmountStr(wallet.coin, tx.fees);
                    });
                }
            };
            if (WalletProvider_1.historyUpdateOnProgress[wallet.id]) {
                this.logger.debug('!! History update already on progress for: ' + wallet.id);
                if (progressFn) {
                    WalletProvider_1.progressFn[walletId] = progressFn;
                }
                return reject('HISTORY_IN_PROGRESS'); // no callback call yet.
            }
            this.logger.debug('Updating Transaction History for ' + wallet.credentials.walletName);
            WalletProvider_1.historyUpdateOnProgress[wallet.id] = true;
            this.getSavedTxs(walletId)
                .then(txsFromLocal => {
                fixTxsUnit(txsFromLocal);
                const confirmedTxs = this.removeAndMarkSoftConfirmedTx(txsFromLocal);
                const endingTxid = confirmedTxs[0] ? confirmedTxs[0].txid : null;
                const endingTs = confirmedTxs[0] ? confirmedTxs[0].time : null;
                // First update
                WalletProvider_1.progressFn[walletId](txsFromLocal, 0);
                wallet.completeHistory = txsFromLocal;
                // send update
                this.events.publish('Local/WalletHistoryUpdate', {
                    walletId: wallet.id,
                    complete: false
                });
                const getNewTxs = (newTxs, skip, tries = 0) => {
                    return new Promise((resolve, reject) => {
                        this.fetchTxsFromServer(wallet, skip, endingTxid, requestLimit)
                            .then(result => {
                            const res = result.res;
                            const shouldContinue = result.shouldContinue
                                ? result.shouldContinue
                                : false;
                            newTxs = newTxs.concat(this.processNewTxs(wallet, __WEBPACK_IMPORTED_MODULE_4_lodash__["compact"](res)));
                            WalletProvider_1.progressFn[walletId](newTxs.concat(txsFromLocal), newTxs.length);
                            skip = skip + requestLimit;
                            this.logger.debug('Syncing TXs for:' +
                                walletId +
                                '. Got:' +
                                newTxs.length +
                                ' Skip:' +
                                skip, ' EndingTxid:', endingTxid, ' Continue:', shouldContinue);
                            // TODO Dirty <HACK>
                            // do not sync all history, just looking for a single TX.
                            if (opts.limitTx) {
                                foundLimitTx = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](newTxs.concat(txsFromLocal), {
                                    txid: opts.limitTx
                                });
                                if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](foundLimitTx)) {
                                    this.logger.debug('Found limitTX: ' + opts.limitTx);
                                    return resolve([foundLimitTx]);
                                }
                            }
                            // </HACK>
                            if (!shouldContinue) {
                                this.logger.debug('Finished Sync: New / soft confirmed Txs: ' +
                                    newTxs.length);
                                return resolve(newTxs);
                            }
                            requestLimit = LIMIT;
                            return getNewTxs(newTxs, skip).then(txs => {
                                resolve(txs);
                            });
                        })
                            .catch(err => {
                            if (err instanceof this.errors.CONNECTION_ERROR ||
                                (err.message && err.message.match(/5../))) {
                                if (tries > 1)
                                    return reject(err);
                                return setTimeout(() => {
                                    return resolve(getNewTxs(newTxs, skip, ++tries));
                                }, 2000 + 3000 * tries);
                            }
                            else {
                                return reject(err);
                            }
                        });
                    });
                };
                getNewTxs([], 0)
                    .then(txs => {
                    const array = __WEBPACK_IMPORTED_MODULE_4_lodash__["compact"](txs.concat(confirmedTxs));
                    const newHistory = __WEBPACK_IMPORTED_MODULE_4_lodash__["uniqBy"](array, x => {
                        return x.txid;
                    });
                    const updateNotes = () => {
                        return new Promise((resolve, reject) => {
                            if (!endingTs)
                                return resolve();
                            // this.logger.debug('Syncing notes from: ' + endingTs);
                            wallet.getTxNotes({
                                minTs: endingTs
                            }, (err, notes) => {
                                if (err) {
                                    this.logger.warn('Could not get TxNotes: ', err);
                                    return reject(err);
                                }
                                __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](notes, note => {
                                    // this.logger.debug('Note for ' + note.txid);
                                    __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](newHistory, (tx) => {
                                        if (tx.txid == note.txid) {
                                            // this.logger.debug(
                                            //  '...updating note for ' + note.txid
                                            // );
                                            tx.note = note;
                                        }
                                    });
                                });
                                return resolve();
                            });
                        });
                    };
                    const updateLowAmount = txs => {
                        if (!opts.lowAmount)
                            return;
                        __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txs, tx => {
                            tx.lowAmount = tx.amount < opts.lowAmount;
                        });
                    };
                    this.getLowAmount(wallet).then(fee => {
                        opts.lowAmount = fee;
                        updateLowAmount(txs);
                    });
                    updateNotes()
                        .then(() => {
                        // <HACK>
                        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](foundLimitTx)) {
                            this.logger.debug('Tx history read until limitTx: ' + opts.limitTx);
                            return resolve(newHistory);
                        }
                        // </HACK>
                        const historyToSave = JSON.stringify(newHistory);
                        __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txs, tx => {
                            tx.recent = true;
                        });
                        // Final update
                        if (walletId == wallet.credentials.walletId) {
                            wallet.completeHistory = newHistory;
                        }
                        return this.persistenceProvider
                            .setTxHistory(walletId, historyToSave)
                            .then(() => {
                            this.logger.debug('History sync & saved for ' +
                                wallet.id +
                                ' Txs: ' +
                                newHistory.length);
                            return resolve();
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    processNewTxs(wallet, txs) {
        const now = Math.floor(Date.now() / 1000);
        const txHistoryUnique = {};
        const ret = [];
        wallet.hasUnsafeConfirmed = false;
        __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txs, tx => {
            tx = this.txFormatProvider.processTx(wallet.coin, tx);
            // no future transactions...
            if (tx.time > now)
                tx.time = now;
            if (tx.confirmations >= this.SAFE_CONFIRMATIONS) {
                tx.safeConfirmed = this.SAFE_CONFIRMATIONS + '+';
            }
            else {
                tx.safeConfirmed = false;
                wallet.hasUnsafeConfirmed = true;
            }
            if (tx.note) {
                delete tx.note.encryptedEditedByName;
                delete tx.note.encryptedBody;
            }
            if (!txHistoryUnique[tx.txid]) {
                ret.push(tx);
                txHistoryUnique[tx.txid] = true;
            }
            else {
                this.logger.debug('Ignoring duplicate TX in history: ' + tx.txid);
            }
        });
        return ret;
    }
    removeAndMarkSoftConfirmedTx(txs) {
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](txs, tx => {
            if (tx.confirmations >= this.SOFT_CONFIRMATION_LIMIT)
                return tx;
            tx.recent = true;
        });
    }
    // Approx utxo amount, from which the uxto is economically redeemable
    getLowAmount(wallet) {
        return new Promise((resolve, reject) => {
            this.getMinFee(wallet)
                .then(fee => {
                const minFee = fee;
                return resolve(minFee / this.LOW_AMOUNT_RATIO);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    // Approx utxo amount, from which the uxto is economically redeemable
    getMinFee(wallet, nbOutputs) {
        return new Promise((resolve, reject) => {
            this.feeProvider
                .getFeeLevels(wallet.coin)
                .then(data => {
                const normalLevelRate = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](data.levels[wallet.network], level => {
                    return level.level === 'normal';
                });
                const lowLevelRate = (normalLevelRate.feePerKb / 1000).toFixed(0);
                const size = this.getEstimatedTxSize(wallet, nbOutputs);
                return resolve(size * parseInt(lowLevelRate, 10));
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    // These 2 functions were taken from
    // https://github.com/bitpay/bitcore-wallet-service/blob/master/lib/model/txproposal.js#L243
    getEstimatedSizeForSingleInput(wallet) {
        switch (wallet.credentials.addressType) {
            case 'P2PKH':
                return 147;
            default:
            case 'P2SH':
                return wallet.m * 72 + wallet.n * 36 + 44;
        }
    }
    getEstimatedTxSize(wallet, nbOutputs) {
        // Note: found empirically based on all multisig P2SH inputs and within m & n allowed limits.
        nbOutputs = nbOutputs ? nbOutputs : 2; // Assume 2 outputs
        const safetyMargin = 0.02;
        const overhead = 4 + 4 + 9 + 9;
        const inputSize = this.getEstimatedSizeForSingleInput(wallet);
        const outputSize = 34;
        const nbInputs = 1; // Assume 1 input
        const size = overhead + inputSize * nbInputs + outputSize * nbOutputs;
        return parseInt((size * (1 + safetyMargin)).toFixed(0), 10);
    }
    getTxNote(wallet, txid) {
        return new Promise((resolve, reject) => {
            wallet.getTxNote({
                txid
            }, (err, note) => {
                if (err)
                    return reject(err);
                return resolve(note);
            });
        });
    }
    editTxNote(wallet, args) {
        return new Promise((resolve, reject) => {
            wallet.editTxNote(args, (err, res) => {
                if (err)
                    return reject(err);
                return resolve(res);
            });
        });
    }
    getTxp(wallet, txpid) {
        return new Promise((resolve, reject) => {
            wallet.getTx(txpid, (err, txp) => {
                if (err)
                    return reject(err);
                return resolve(txp);
            });
        });
    }
    isHistoryCached(wallet) {
        return wallet.completeHistory && wallet.completeHistoryIsValid;
    }
    getTx(wallet, txid) {
        return new Promise((resolve, reject) => {
            const finish = list => {
                const tx = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](list, {
                    txid
                });
                if (!tx)
                    return reject('Could not get transaction');
                return tx;
            };
            if (this.isHistoryCached(wallet)) {
                const tx = finish(wallet.completeHistory);
                return resolve(tx);
            }
            else {
                const opts = {
                    limitTx: txid
                };
                this.fetchTxHistory(wallet, null, opts)
                    .then(txHistory => {
                    const tx = finish(txHistory);
                    return resolve(tx);
                })
                    .catch(err => {
                    return reject(err);
                });
            }
        });
    }
    fetchTxHistory(wallet, progressFn, opts = {}) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            if (!wallet.isComplete())
                return resolve();
            if (this.isHistoryCached(wallet) && !opts.force) {
                this.logger.debug('Returning cached history for ' + wallet.id);
                return resolve(wallet.completeHistory);
            }
            this.updateLocalTxHistory(wallet, progressFn, opts)
                .then(txs => {
                WalletProvider_1.historyUpdateOnProgress[wallet.id] = false;
                if (opts.limitTx) {
                    return resolve(txs);
                }
                wallet.completeHistoryIsValid = true;
                return resolve(wallet.completeHistory);
            })
                .catch(err => {
                if (err != 'HISTORY_IN_PROGRESS') {
                    WalletProvider_1.historyUpdateOnProgress[wallet.id] = false;
                    this.logger.warn('!! Could not update history for ', wallet.id, err);
                }
                return reject(err);
            });
        });
    }
    createTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.createTxProposal(txp, (err, createdTxp) => {
                if (err)
                    return reject(err);
                else {
                    this.logger.debug('Transaction created');
                    return resolve(createdTxp);
                }
            });
        });
    }
    publishTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.publishTxProposal({
                txp
            }, (err, publishedTx) => {
                if (err)
                    return reject(err);
                else {
                    this.logger.debug('Transaction published');
                    return resolve(publishedTx);
                }
            });
        });
    }
    signTx(wallet, txp, password) {
        return new Promise((resolve, reject) => {
            if (!wallet || !txp)
                return reject('MISSING_PARAMETER');
            const rootPath = wallet.getRootPath();
            const signatures = this.keyProvider.sign(wallet.credentials.keyId, rootPath, txp, password);
            try {
                wallet.pushSignatures(txp, signatures, (err, signedTxp) => {
                    if (err) {
                        this.logger.error('Transaction signed err: ', err);
                        return reject(err);
                    }
                    return resolve(signedTxp);
                });
            }
            catch (e) {
                this.logger.error('Error at pushSignatures:', e);
                return reject(e);
            }
        });
    }
    broadcastTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            if (txp.status != 'accepted')
                return reject('TX_NOT_ACCEPTED');
            wallet.broadcastTxProposal(txp, (err, broadcastedTxp, memo) => {
                if (err) {
                    if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isArrayBuffer"](err)) {
                        const enc = new __WEBPACK_IMPORTED_MODULE_5_text_encoding___default.a.TextDecoder();
                        err = enc.decode(err);
                        this.removeTx(wallet, txp);
                        return reject(err);
                    }
                    else {
                        return reject(err);
                    }
                }
                this.logger.info('Transaction broadcasted: ', broadcastedTxp.txid);
                if (memo)
                    this.logger.info('Memo: ', memo);
                return resolve(broadcastedTxp);
            });
        });
    }
    rejectTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.rejectTxProposal(txp, null, (err, rejectedTxp) => {
                if (err)
                    return reject(err);
                this.logger.debug('Transaction rejected');
                return resolve(rejectedTxp);
            });
        });
    }
    removeTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.removeTxProposal(txp, err => {
                this.logger.debug('Transaction removed');
                this.invalidateCache(wallet);
                this.events.publish('Local/TxAction', {
                    walletId: wallet.id
                });
                return resolve(err);
            });
        });
    }
    // updates local and remote prefs for 1 wallet
    updateRemotePreferencesFor(client, prefs) {
        return new Promise((resolve, reject) => {
            client.preferences = client.preferences || {};
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](prefs)) {
                __WEBPACK_IMPORTED_MODULE_4_lodash__["assign"](client.preferences, prefs);
            }
            this.logger.debug('Saving remote preferences', client.credentials.walletName, JSON.stringify(client.preferences));
            client.savePreferences(client.preferences, err => {
                if (err) {
                    this.popupProvider.ionicAlert(this.bwcErrorProvider.msg(err, this.translate.instant('Could not save preferences on the server')));
                    return reject(err);
                }
                return resolve();
            });
        });
    }
    updateRemotePreferences(clients, prefs) {
        prefs = prefs ? prefs : {};
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isArray"](clients))
            clients = [clients];
        let updates = [];
        clients.forEach(c => {
            if (this.currencyProvider.isERCToken(c.credentials.coin))
                return;
            updates.push(this.updateRemotePreferencesFor(c, prefs));
        });
        return Promise.all(updates);
    }
    recreate(wallet) {
        return new Promise((resolve, reject) => {
            this.logger.info('Recreating wallet:', wallet.id);
            wallet.recreateWallet(err => {
                wallet.notAuthorized = false;
                if (err)
                    return reject(err);
                return resolve();
            });
        });
    }
    startScan(wallet) {
        return new Promise((resolve, reject) => {
            this.logger.info('Scanning wallet ' + wallet.id);
            if (!wallet.isComplete())
                return reject('Wallet incomplete: ' + wallet.name);
            wallet.scanning = true;
            wallet.startScan({
                includeCopayerBranches: true
            }, err => {
                if (err)
                    return reject(err);
                return resolve();
            });
        });
    }
    clearTxHistory(wallet) {
        this.invalidateCache(wallet);
        this.persistenceProvider.removeTxHistory(wallet.id);
    }
    expireAddress(walletId) {
        return new Promise((resolve, reject) => {
            this.logger.info('Cleaning Address ' + walletId);
            this.persistenceProvider
                .clearLastAddress(walletId)
                .then(() => {
                return resolve();
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getMainAddresses(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            opts.reverse = true;
            wallet.getMainAddresses(opts, (err, addresses) => {
                if (err)
                    return reject(err);
                return resolve(addresses);
            });
        });
    }
    getBalance(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            wallet.getBalance(opts, (err, resp) => {
                if (err)
                    return reject(err);
                return resolve(resp);
            });
        });
    }
    getLowUtxos(wallet) {
        return new Promise((resolve, reject) => {
            wallet.getUtxos({
                coin: wallet.coin
            }, (err, resp) => {
                if (err || !resp || !resp.length)
                    return reject(err ? err : 'No UTXOs');
                this.getMinFee(wallet, resp.length)
                    .then(fee => {
                    const minFee = fee;
                    const balance = __WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](resp, 'satoshis');
                    // for 2 outputs
                    this.getLowAmount(wallet)
                        .then(fee => {
                        const lowAmount = fee;
                        const lowUtxos = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](resp, x => {
                            return x.satoshis < lowAmount;
                        });
                        const totalLow = __WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](lowUtxos, 'satoshis');
                        return resolve({
                            allUtxos: resp || [],
                            lowUtxos: lowUtxos || [],
                            totalLow,
                            warning: minFee / balance > this.TOTAL_LOW_WARNING_RATIO,
                            minFee
                        });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            });
        });
    }
    reject(wallet, txp) {
        return new Promise((resolve, reject) => {
            this.rejectTx(wallet, txp)
                .then(txpr => {
                this.invalidateCache(wallet);
                this.events.publish('Local/TxAction', {
                    walletId: wallet.id
                });
                return resolve(txpr);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    onlyPublish(wallet, txp) {
        return new Promise((resolve, reject) => {
            this.publishTx(wallet, txp)
                .then(() => {
                this.invalidateCache(wallet);
                this.events.publish('Local/TxAction', {
                    walletId: wallet.id
                });
                return resolve();
            })
                .catch(err => {
                return reject(this.bwcErrorProvider.msg(err));
            });
        });
    }
    prepare(wallet) {
        return new Promise((resolve, reject) => {
            this.touchidProvider
                .checkWallet(wallet)
                .then(() => {
                this.keyProvider
                    .handleEncryptedWallet(wallet.credentials.keyId)
                    .then((password) => {
                    return resolve(password);
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    signAndBroadcast(wallet, publishedTxp, password) {
        return new Promise((resolve, reject) => {
            this.onGoingProcessProvider.set('signingTx');
            let expected = wallet.cachedStatus.balance.totalAmount -
                publishedTxp.amount -
                publishedTxp.fee;
            this.signTx(wallet, publishedTxp, password)
                .then(signedTxp => {
                this.invalidateCache(wallet);
                if (signedTxp.status == 'accepted') {
                    this.onGoingProcessProvider.set('broadcastingTx');
                    this.broadcastTx(wallet, signedTxp)
                        .then(broadcastedTxp => {
                        this.events.publish('Local/TxAction', {
                            walletId: wallet.id,
                            until: { totalAmount: expected }
                        });
                        return resolve(broadcastedTxp);
                    })
                        .catch(err => {
                        return reject(this.bwcErrorProvider.msg(err));
                    });
                }
                else {
                    this.events.publish('Local/TxAction', {
                        walletId: wallet.id
                    });
                    return resolve(signedTxp);
                }
            })
                .catch(err => {
                const msg = err && err.message
                    ? err.message
                    : this.translate.instant('The payment was created but could not be completed. Please try again from home screen');
                this.logger.error('Sign error: ' + msg);
                this.events.publish('Local/TxAction', {
                    walletId: wallet.id,
                    until: { totalAmount: expected }
                });
                return reject(msg);
            });
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            // Already published?
            if (txp.status == 'pending') {
                this.prepare(wallet)
                    .then((password) => {
                    this.signAndBroadcast(wallet, txp, password)
                        .then(broadcastedTxp => {
                        return resolve(broadcastedTxp);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            }
            else {
                this.prepare(wallet)
                    .then((password) => {
                    this.onGoingProcessProvider.set('sendingTx');
                    this.publishTx(wallet, txp)
                        .then(publishedTxp => {
                        this.signAndBroadcast(wallet, publishedTxp, password)
                            .then(broadcastedTxp => {
                            return resolve(broadcastedTxp);
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            }
        });
    }
    signMultipleTxps(wallet, txps) {
        [].concat(txps);
        const promises = [];
        return this.prepare(wallet).then((password) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](txps, txp => {
                promises.push(this.signAndBroadcast(wallet, txp, password).catch(error => {
                    this.logger.error(error);
                    return error;
                }));
            });
            return Promise.all(promises);
        }));
    }
    getEncodedWalletInfo(wallet, password) {
        return new Promise((resolve, reject) => {
            if (!wallet.credentials.keyId) {
                return resolve();
            }
            const derivationPath = this.keyProvider.getBaseAddressDerivationPath(wallet.credentials.keyId, {
                account: wallet.account,
                coin: wallet.coin,
                n: wallet.n,
                network: wallet.network
            });
            const encodingType = {
                mnemonic: 1,
                xpriv: 2,
                xpub: 3
            };
            let info = {};
            const keys = this.getKeysWithPassword(wallet, password);
            if (!keys || (!keys.mnemonic && !keys.xPrivKey))
                return reject(this.translate.instant('Exporting via QR not supported for this wallet'));
            if (keys.mnemonic) {
                info = {
                    type: encodingType.mnemonic,
                    data: keys.mnemonic
                };
            }
            else {
                info = {
                    type: encodingType.xpriv,
                    data: keys.xPrivKey
                };
            }
            const mnemonicHasPassphrase = this.keyProvider.mnemonicHasPassphrase(wallet.credentials.keyId);
            return resolve(info.type +
                '|' +
                info.data +
                '|' +
                wallet.credentials.network.toLowerCase() +
                '|' +
                derivationPath +
                '|' +
                mnemonicHasPassphrase +
                '|' +
                wallet.coin);
        });
    }
    getKeysWithPassword(wallet, password) {
        try {
            return this.keyProvider.get(wallet.credentials.keyId, password);
        }
        catch (e) {
            this.logger.error(e);
        }
    }
    setTouchId(walletsArray, enabled) {
        const opts = {
            touchIdFor: {}
        };
        walletsArray.forEach(wallet => {
            opts.touchIdFor[wallet.id] = enabled;
        });
        const promise = this.touchidProvider.checkWallet(walletsArray[0]);
        return promise.then(() => {
            this.configProvider.set(opts);
            return Promise.resolve();
        });
    }
    getKeys(wallet) {
        return new Promise((resolve, reject) => {
            this.prepare(wallet)
                .then((password) => {
                let keys;
                try {
                    keys = this.getKeysWithPassword(wallet, password);
                }
                catch (e) {
                    return reject(e);
                }
                return resolve(keys);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getMnemonicAndPassword(wallet) {
        return new Promise((resolve, reject) => {
            this.prepare(wallet)
                .then((password) => {
                let keys;
                try {
                    keys = this.getKeysWithPassword(wallet, password);
                }
                catch (e) {
                    return reject(e);
                }
                const mnemonic = keys.mnemonic;
                return resolve({ mnemonic, password });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getSendMaxInfo(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            wallet.getSendMaxInfo(opts, (err, res) => {
                if (err)
                    return reject(err);
                return resolve(res);
            });
        });
    }
    getEstimateGas(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            wallet.getEstimateGas(opts, (err, res) => {
                if (err)
                    return reject(err);
                return resolve(res);
            });
        });
    }
    getProtocolHandler(coin, network = 'livenet') {
        return this.currencyProvider.getProtocolPrefix(coin, network);
    }
    copyCopayers(wallet, newWallet) {
        return new Promise((resolve, reject) => {
            let walletPrivKey = this.bwcProvider
                .getBitcore()
                .PrivateKey.fromString(wallet.credentials.walletPrivKey);
            let copayer = 1;
            let i = 0;
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](wallet.credentials.publicKeyRing, item => {
                let name = item.copayerName || 'copayer ' + copayer++;
                newWallet._doJoinWallet(newWallet.credentials.walletId, walletPrivKey, item.xPubKey, item.requestPubKey, name, {
                    coin: newWallet.credentials.coin
                }, (err) => {
                    // Ignore error is copayer already in wallet
                    if (err && !(err instanceof this.errors.COPAYER_IN_WALLET))
                        return reject(err);
                    if (++i == wallet.credentials.publicKeyRing.length)
                        return resolve();
                });
            });
        });
    }
};
WalletProvider.progressFn = {};
WalletProvider.statusUpdateOnProgress = {};
WalletProvider.historyUpdateOnProgress = {};
WalletProvider = WalletProvider_1 = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_14__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_20__tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_9__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_10__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_16__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_7__bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_18__rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_12__filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_17__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_15__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_19__touchid_touchid__["a" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_11__fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_13__key_key__["a" /* KeyProvider */]])
], WalletProvider);

var WalletProvider_1;
//# sourceMappingURL=wallet.js.map

/***/ }),

/***/ 320:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__add_create_wallet_create_wallet__ = __webpack_require__(321);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__add_join_wallet_join_wallet__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__add_select_currency_select_currency__ = __webpack_require__(326);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash__);




// pages



// providers



let AddWalletPage = class AddWalletPage {
    constructor(navCtrl, logger, profileProvider, navParams, translate) {
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.navParams = navParams;
        this.translate = translate;
        this.fromEthCard = this.navParams.data.fromEthCard;
        this.title = this.fromEthCard
            ? this.translate.instant('Select Key to add ETH Wallet to')
            : this.translate.instant('Select Key');
        const opts = {
            canAddNewAccount: true,
            showHidden: true
        };
        const wallets = this.profileProvider.getWallets(opts);
        this.walletsGroups = __WEBPACK_IMPORTED_MODULE_9_lodash__["values"](__WEBPACK_IMPORTED_MODULE_9_lodash__["groupBy"](wallets, 'keyId'));
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AddWalletPage');
    }
    goToAddPage(keyId) {
        if (this.navParams.data.isCreate) {
            if (this.fromEthCard) {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__add_create_wallet_create_wallet__["a" /* CreateWalletPage */], {
                    isShared: false,
                    coin: 'eth',
                    keyId
                });
            }
            else {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__add_select_currency_select_currency__["a" /* SelectCurrencyPage */], {
                    isShared: this.navParams.data.isShared,
                    isZeroState: keyId ? false : true,
                    keyId
                });
            }
        }
        else if (this.navParams.data.isJoin) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_join_wallet_join_wallet__["a" /* JoinWalletPage */], {
                keyId,
                url: this.navParams.data.url
            });
        }
    }
};
AddWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-add-wallet',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/add-wallet/add-wallet.html"*/'<wide-header-page title="{{ title }}">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <button ion-item *ngFor="let walletsGroup of walletsGroups; let i = index" (click)="goToAddPage(walletsGroup[0].keyId)">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-key.svg" width="22">\n        </ion-icon>\n        <ion-label>\n          <div *ngIf="walletsGroup[0].canSign">{{profileProvider.getWalletGroup(walletsGroup[0].keyId).name}}</div>\n          <div *ngIf="!walletsGroup[0].canSign" translate>Read Only Wallets</div>\n        </ion-label>\n        <ion-note item-end>\n          {{walletsGroup.length}} Wallet<span *ngIf="walletsGroup.length > 1">s</span>\n        </ion-note>\n      </button>\n    </ion-list>\n\n    <label-tip *ngIf="walletsGroups && walletsGroups[0]" type="info" class="no-arrowhead">\n      <span label-tip-title translate>Don\'t see your Key?</span>\n      <div label-tip-body>\n        <span translate>\n          Legacy wallets created before 9/15 can\'t support additional wallets being added.\n        </span>\n      </div>\n    </label-tip>\n\n    <button ion-button class="button-standard" color="light" (click)="goToAddPage()">\n      <span translate>Create New Key</span>\n    </button>\n\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/add-wallet/add-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], AddWalletPage);

//# sourceMappingURL=add-wallet.js.map

/***/ }),

/***/ 321:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CreateWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_push_notifications_push_notifications__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__settings_wallet_group_settings_wallet_group_onboarding_wallet_group_onboarding__ = __webpack_require__(322);






// Providers













// Pages

let CreateWalletPage = class CreateWalletPage {
    constructor(currencyProvider, navCtrl, navParams, fb, profileProvider, configProvider, derivationPathHelperProvider, popupProvider, onGoingProcessProvider, logger, walletProvider, translate, events, pushNotificationsProvider, externalLinkProvider, bwcErrorProvider, bwcProvider, modalCtrl, persistenceProvider) {
        this.currencyProvider = currencyProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.fb = fb;
        this.profileProvider = profileProvider;
        this.configProvider = configProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.events = events;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.modalCtrl = modalCtrl;
        this.persistenceProvider = persistenceProvider;
        /* For compressed keys, m*73 + n*34 <= 496 */
        this.COPAYER_PAIR_LIMITS = {
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 4,
            6: 4,
            7: 3,
            8: 3,
            9: 2,
            10: 2,
            11: 1,
            12: 1
        };
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.isShared = this.navParams.get('isShared');
        this.coin = this.navParams.get('coin');
        this.keyId = this.navParams.get('keyId');
        this.defaults = this.configProvider.getDefaults();
        this.tc = this.isShared ? this.defaults.wallet.totalCopayers : 1;
        this.copayers = __WEBPACK_IMPORTED_MODULE_5_lodash__["range"](2, this.defaults.limits.totalCopayers + 1);
        this.derivationPathByDefault = this.isShared
            ? this.coin === 'bch'
                ? this.derivationPathHelperProvider.defaultMultisigBCH
                : this.derivationPathHelperProvider.defaultMultisigBTC
            : this.bwcProvider.getCore().Deriver.pathFor(this.coin, 'livenet');
        this.derivationPathForTestnet = this.bwcProvider
            .getCore()
            .Deriver.pathFor(this.coin, 'testnet');
        this.showAdvOpts = false;
        const walletName = this.currencyProvider.getCoinName(this.coin);
        this.createForm = this.fb.group({
            walletName: [walletName, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required],
            myName: [null],
            totalCopayers: [1],
            requiredCopayers: [1],
            bwsURL: [this.defaults.bws.url],
            selectedSeed: ['new'],
            recoveryPhrase: [null],
            derivationPath: [this.derivationPathByDefault],
            testnetEnabled: [false],
            singleAddress: [false],
            coin: [null, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required]
        });
        this.createForm.controls['coin'].setValue(this.coin);
        this.createLabel = this.translate.instant(`${this.coin.toUpperCase()} Wallet`);
        this.showKeyOnboarding = this.navParams.data.showKeyOnboarding;
        this.setTotalCopayers(this.tc);
        this.updateRCSelect(this.tc);
        this.updateSeedSourceSelect();
    }
    ngOnInit() {
        if (this.isShared) {
            this.createForm.get('myName').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required]);
        }
    }
    setTotalCopayers(n) {
        this.createForm.controls['totalCopayers'].setValue(n);
    }
    updateRCSelect(n) {
        const maxReq = this.COPAYER_PAIR_LIMITS[n];
        this.signatures = __WEBPACK_IMPORTED_MODULE_5_lodash__["range"](1, maxReq + 1);
        this.createForm.controls['requiredCopayers'].setValue(Math.min(Math.trunc(n / 2 + 1), maxReq));
    }
    isSingleAddress() {
        return this.currencyProvider.isSingleAddress(this.coin);
    }
    updateSeedSourceSelect() {
        this.seedOptions = [
            {
                id: 'new',
                label: this.translate.instant('Random'),
                supportsTestnet: true
            },
            {
                id: 'set',
                label: this.translate.instant('Specify Recovery Phrase'),
                supportsTestnet: false
            }
        ];
        this.createForm.controls['selectedSeed'].setValue(this.seedOptions[0].id); // new or set
    }
    seedOptionsChange(seed) {
        if (seed === 'set') {
            this.createForm
                .get('recoveryPhrase')
                .setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required]);
        }
        else {
            this.createForm.get('recoveryPhrase').setValidators(null);
        }
        this.createForm.controls['selectedSeed'].setValue(seed); // new or set
        if (this.createForm.controls['testnet'])
            this.createForm.controls['testnet'].setValue(false);
        this.createForm.controls['derivationPath'].setValue(this.derivationPathByDefault);
        this.createForm.controls['recoveryPhrase'].setValue(null);
    }
    setDerivationPath() {
        const path = this.createForm.value.testnet
            ? this.derivationPathForTestnet
            : this.derivationPathByDefault;
        this.createForm.controls['derivationPath'].setValue(path);
    }
    setOptsAndCreate() {
        const opts = {
            keyId: this.keyId,
            name: this.createForm.value.walletName,
            m: this.createForm.value.requiredCopayers,
            n: this.createForm.value.totalCopayers,
            myName: this.createForm.value.totalCopayers > 1
                ? this.createForm.value.myName
                : null,
            networkName: this.createForm.value.testnetEnabled ? 'testnet' : 'livenet',
            bwsurl: this.createForm.value.bwsURL,
            singleAddress: this.currencyProvider.isSingleAddress(this.createForm.value.coin)
                ? true
                : this.createForm.value.singleAddress,
            coin: this.createForm.value.coin
        };
        const setSeed = this.createForm.value.selectedSeed == 'set';
        if (setSeed) {
            const words = this.createForm.value.recoveryPhrase || '';
            if (words.indexOf(' ') == -1 &&
                words.indexOf('prv') == 1 &&
                words.length > 108) {
                opts.extendedPrivateKey = words;
            }
            else {
                opts.mnemonic = words;
            }
            const derivationPath = this.createForm.value.derivationPath;
            opts.networkName = this.derivationPathHelperProvider.getNetworkName(derivationPath);
            opts.derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(derivationPath);
            opts.account = this.derivationPathHelperProvider.getAccount(derivationPath);
            // set opts.useLegacyPurpose
            if (this.derivationPathHelperProvider.parsePath(this.createForm.value.derivationPath).purpose == "44'" &&
                opts.n > 1) {
                opts.useLegacyPurpose = true;
                this.logger.debug('Using 44 for Multisig');
            }
            // set opts.useLegacyCoinType
            if (this.coin == 'bch' &&
                this.derivationPathHelperProvider.parsePath(this.createForm.value.derivationPath).coinCode == "0'") {
                opts.useLegacyCoinType = true;
                this.logger.debug('Using 0 for BCH creation');
            }
            if (!opts.networkName ||
                !opts.derivationStrategy ||
                !Number.isInteger(opts.account)) {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Invalid derivation path');
                this.popupProvider.ionicAlert(title, subtitle);
                return;
            }
        }
        if (setSeed && !opts.mnemonic && !opts.extendedPrivateKey) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Please enter the wallet recovery phrase');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        if (!this.derivationPathHelperProvider.isValidDerivationPathCoin(this.createForm.value.derivationPath, this.coin)) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Invalid derivation path for selected coin');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        if (this.showKeyOnboarding) {
            this.showKeyOnboardingSlides(opts);
        }
        else {
            this.create(opts);
        }
    }
    showKeyOnboardingSlides(opts) {
        this.logger.debug('Showing key onboarding');
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_19__settings_wallet_group_settings_wallet_group_onboarding_wallet_group_onboarding__["a" /* WalletGroupOnboardingPage */], null, {
            showBackdrop: false,
            enableBackdropDismiss: false
        });
        modal.present();
        modal.onDidDismiss(() => {
            this.create(opts);
        });
        this.persistenceProvider.setKeyOnboardingFlag();
    }
    create(opts) {
        this.onGoingProcessProvider.set('creatingWallet');
        opts['keyId'] = this.keyId;
        this.profileProvider
            .createWallet(opts)
            .then(wallet => {
            this.onGoingProcessProvider.clear();
            this.walletProvider.updateRemotePreferences(wallet);
            this.pushNotificationsProvider.updateSubscription(wallet);
            if (this.createForm.value.selectedSeed == 'set') {
                this.profileProvider.setBackupGroupFlag(wallet.credentials.keyId);
                this.profileProvider.setWalletBackup(wallet.credentials.walletId);
            }
            this.navCtrl.popToRoot().then(() => {
                this.events.publish('Local/WalletListChange');
                setTimeout(() => {
                    this.events.publish('OpenWallet', wallet);
                }, 1000);
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED') {
                this.logger.error('Create: could not create wallet', err);
                const title = this.translate.instant('Error');
                err = this.bwcErrorProvider.msg(err);
                this.popupProvider.ionicAlert(title, err);
            }
            return;
        });
    }
    openSupportSingleAddress() {
        const url = 'https://support.bitpay.com/hc/en-us/articles/360015920572-Setting-up-the-Single-Address-Feature-for-your-BitPay-Wallet';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Read more in our support page');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
CreateWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-create-wallet',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/add/create-wallet/create-wallet.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{ createLabel }}</ion-title>\n    <ion-buttons end>\n      <button ion-button (click)="setOptsAndCreate()" [disabled]="!createForm.valid">\n        <span translate>Create</span>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n<ion-content no-bounce>\n  <form [formGroup]="createForm">\n    <ion-item>\n      <ion-label floating>{{\'Wallet name\' | translate}}</ion-label>\n      <ion-input type="text" formControlName="walletName"></ion-input>\n    </ion-item>\n\n    <div *ngIf="isShared">\n      <ion-item>\n        <ion-label floating>{{\'Your name\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="myName"></ion-input>\n      </ion-item>\n\n      <ion-item>\n        <ion-label floating>{{\'Total number of copayers\' | translate}}</ion-label>\n        <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="totalCopayers" (ionChange)="setTotalCopayers(createForm.value.totalCopayers)">\n          <ion-option *ngFor="let copayer of copayers" [value]="copayer">{{copayer}}</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <ion-item>\n        <ion-label floating>{{\'Required number of signatures\' | translate}}</ion-label>\n        <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="requiredCopayers">\n          <ion-option *ngFor="let signature of signatures" [value]="signature">{{signature}}</ion-option>\n        </ion-select>\n      </ion-item>\n    </div>\n\n    <button ion-button class="button-standard button-secondary" (click)="showAdvOpts = !showAdvOpts">\n      <span *ngIf="!showAdvOpts">{{\'Show advanced options\' | translate}}</span>\n      <span *ngIf="showAdvOpts">{{\'Hide advanced options\' | translate}}</span>\n    </button>\n\n    <div *ngIf="showAdvOpts" padding-bottom>\n      <ion-item>\n        <ion-label stacked>Wallet Service URL</ion-label>\n        <ion-input type="text" formControlName="bwsURL"></ion-input>\n      </ion-item>\n\n      <ion-item *ngIf="!keyId">\n        <ion-label stacked>{{\'Wallet key\' | translate}}</ion-label>\n        <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="selectedSeed" (ionChange)="seedOptionsChange(createForm.value.selectedSeed)">\n          <ion-option *ngFor="let opt of seedOptions" [value]="opt.id">{{opt.label}}</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <ion-item *ngIf="createForm.value.selectedSeed == \'set\' && !keyId">\n        <ion-label stacked>{{\'Wallet recovery phrase\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="recoveryPhrase"></ion-input>\n      </ion-item>\n\n      <ion-item [ngClass]="{\'with-label\': createForm.value.testnetEnabled}" *ngIf="createForm.value.selectedSeed == \'new\'">\n        <ion-label>Testnet</ion-label>\n        <ion-toggle formControlName="testnetEnabled" (ionChange)="setDerivationPath()"></ion-toggle>\n      </ion-item>\n\n      <label-tip *ngIf="createForm.value.testnetEnabled && createForm.value.selectedSeed == \'new\'" type="warn">\n        <span label-tip-title translate>Testnet Wallet</span>\n        <div label-tip-body translate>\n          The testnet is an alternative Bitcoin block chain, to be used for testing. Testnet coins are separate and distinct from actual bitcoins, and do not have any value. This allows application developers or bitcoin testers to experiment, without having to use real bitcoins.\n        </div>\n      </label-tip>\n\n      <ion-item *ngIf="createForm.value.selectedSeed == \'set\' && !keyId">\n        <ion-label stacked>{{\'Derivation path\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="derivationPath"></ion-input>\n      </ion-item>\n\n      <ion-item *ngIf="!isSingleAddress()" [ngClass]="{\'with-label\': createForm.value.singleAddress}">\n        <ion-label>{{\'Single address\' | translate}}</ion-label>\n        <ion-toggle formControlName="singleAddress"></ion-toggle>\n      </ion-item>\n      <label-tip *ngIf="createForm.value.singleAddress" type="info" header="no-header">\n        <div label-tip-body>\n          <span translate>The single address feature will force the wallet to only use one address rather than generating new addresses.</span>\n          <br>\n          <a class="label-tip-link" (click)="openSupportSingleAddress()" translate>Learn More</a>\n        </div>\n      </label-tip>\n    </div>\n  </form>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/add/create-wallet/create-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_16__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_18__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_17__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_14__providers_persistence_persistence__["b" /* PersistenceProvider */]])
], CreateWalletPage);

//# sourceMappingURL=create-wallet.js.map

/***/ }),

/***/ 322:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletGroupOnboardingPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);



let WalletGroupOnboardingPage = class WalletGroupOnboardingPage {
    constructor(viewCtrl) {
        this.viewCtrl = viewCtrl;
    }
    nextSlide() {
        this.walletGroupOnboardingSlides.slideNext();
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('walletGroupOnboardingSlides'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["r" /* Slides */])
], WalletGroupOnboardingPage.prototype, "walletGroupOnboardingSlides", void 0);
WalletGroupOnboardingPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-group-onboarding',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-onboarding/wallet-group-onboarding.html"*/'<ion-slides #walletGroupOnboardingSlides pager="true" class="key-onboarding-slides">\n  <ion-slide>\n    <div class="img-container">\n      <img src="assets/img/wallet-group-tour1.svg" />\n    </div>\n    <div class="slide-info">\n      <div class="info">\n        <div class="title" translate>Your funds, on your device</div>\n        <div class="text" translate>\n          A wallet is like a vault stored on your device containing your crypto funds. Much like a vault, your wallet will only be accesible with the master key.\n        </div>\n      </div>\n    </div>\n  </ion-slide>\n  <ion-slide>\n    <div class="img-container">\n      <img src="assets/img/wallet-group-tour2.svg" />\n    </div>\n    <div class="slide-info">\n      <div class="info">\n        <div class="title" translate>The "Key" to your funds</div>\n        <div class="text" translate>\n          Your wallet master key is a phrase composed of 12 randomly selected words. If you were to ever lose or damage your device, you can restore access to your wallet as long as you have your 12 word master key.\n        </div>\n      </div>\n    </div>\n  </ion-slide>\n  <ion-slide>\n    <div class="img-container">\n      <img src="assets/img/wallet-group-tour3.svg" />\n    </div>\n    <div class="slide-info">\n      <div class="info">\n        <div class="title" translate>Don\'t loose your key!</div>\n        <div class="text" translate>\n          In order to protect your funds from being accessible to hackers and theives, the Master Key to your wallet must be kept somewhere safe and remain a secret.\n        </div>\n      </div>\n    </div>\n  </ion-slide>\n</ion-slides>\n<div padding>\n  <button ion-button clear class="next-slide-button" (click)="nextSlide()" *ngIf="walletGroupOnboardingSlides.getActiveIndex() < 2" translate>\n    Next\n  </button>\n  <button ion-button clear class="next-slide-button" (click)="close()" *ngIf="walletGroupOnboardingSlides.getActiveIndex() == 2" translate>\n    I understand\n  </button>\n</div>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-group-settings/wallet-group-onboarding/wallet-group-onboarding.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */]])
], WalletGroupOnboardingPage);

//# sourceMappingURL=wallet-group-onboarding.js.map

/***/ }),

/***/ 323:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return JoinWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__scan_scan__ = __webpack_require__(247);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__tabs_tabs__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_clipboard_clipboard__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_push_notifications_push_notifications__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_wallet_wallet__ = __webpack_require__(32);





// Pages


// Providers











let JoinWalletPage = class JoinWalletPage {
    constructor(app, bwcProvider, configProvider, form, navCtrl, navParams, derivationPathHelperProvider, onGoingProcessProvider, popupProvider, profileProvider, walletProvider, logger, translate, events, pushNotificationsProvider, actionSheetProvider, clipboardProvider) {
        this.app = app;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.form = form;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.logger = logger;
        this.translate = translate;
        this.events = events;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.clipboardProvider = clipboardProvider;
        this.updateInvitationCodeHandler = data => {
            const invitationCode = data.value.replace('copay:', '');
            this.onQrCodeScannedJoin(invitationCode);
        };
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.defaults = this.configProvider.getDefaults();
        this.showAdvOpts = false;
        this.keyId = this.navParams.data.keyId;
        this.regex = /^[0-9A-HJ-NP-Za-km-z]{70,80}$/; // For invitationCode
        this.joinForm = this.form.group({
            myName: [null, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required],
            invitationCode: [
                null,
                [__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].pattern(this.regex)]
            ],
            bwsURL: [this.defaults.bws.url],
            selectedSeed: ['new'],
            recoveryPhrase: [null],
            derivationPath: [null]
        });
        this.seedOptions = [
            {
                id: 'new',
                label: this.translate.instant('Random'),
                supportsTestnet: true
            },
            {
                id: 'set',
                label: this.translate.instant('Specify Recovery Phrase'),
                supportsTestnet: false
            }
        ];
        this.events.subscribe('Local/InvitationScan', this.updateInvitationCodeHandler);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: JoinWalletPage');
    }
    ionViewWillEnter() {
        if (this.navParams.data.url) {
            let data = this.navParams.data.url;
            data = data.replace('copay:', '');
            this.onQrCodeScannedJoin(data);
        }
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/InvitationScan', this.updateInvitationCodeHandler);
    }
    onQrCodeScannedJoin(data) {
        if (this.regex.test(data)) {
            this.joinForm.controls['invitationCode'].setValue(data);
            this.processInvitation(data);
        }
        else {
            const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', {
                msg: this.translate.instant('Invalid data'),
                title: this.translate.instant('Error')
            });
            errorInfoSheet.present();
        }
    }
    seedOptionsChange(seed) {
        if (seed === 'set') {
            this.joinForm.get('recoveryPhrase').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required]);
        }
        else {
            this.joinForm.get('recoveryPhrase').setValidators(null);
        }
        this.joinForm.controls['recoveryPhrase'].setValue(null);
        this.joinForm.controls['selectedSeed'].setValue(seed);
        this.processInvitation(this.joinForm.value.invitationCode);
    }
    setDerivationPath(network) {
        const path = network == 'testnet'
            ? this.derivationPathForTestnet
            : this.derivationPathByDefault;
        this.joinForm.controls['derivationPath'].setValue(path);
    }
    processInvitation(invitation) {
        if (this.regex.test(invitation)) {
            this.logger.info('Processing invitation code...');
            let walletData;
            try {
                walletData = this.bwcProvider.parseSecret(invitation);
                this.coin = walletData.coin;
                this.derivationPathForTestnet = this.derivationPathHelperProvider.defaultTestnet;
                this.derivationPathByDefault =
                    this.coin == 'bch'
                        ? this.derivationPathHelperProvider.defaultBCH
                        : this.derivationPathHelperProvider.defaultBTC;
                this.setDerivationPath(walletData.network);
                this.logger.info('Correct invitation code for ' + walletData.network);
            }
            catch (ex) {
                this.logger.warn('Error parsing invitation: ' + ex);
            }
        }
    }
    setOptsAndJoin() {
        const opts = {
            keyId: this.keyId,
            secret: this.joinForm.value.invitationCode,
            myName: this.joinForm.value.myName,
            bwsurl: this.joinForm.value.bwsURL,
            coin: this.coin
        };
        const setSeed = this.joinForm.value.selectedSeed == 'set';
        if (setSeed) {
            const words = this.joinForm.value.recoveryPhrase;
            if (words.indexOf(' ') == -1 &&
                words.indexOf('prv') == 1 &&
                words.length > 108) {
                opts.extendedPrivateKey = words;
            }
            else {
                opts.mnemonic = words;
            }
            const derivationPath = this.joinForm.value.derivationPath;
            opts.networkName = this.derivationPathHelperProvider.getNetworkName(derivationPath);
            opts.derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(derivationPath);
            opts.account = this.derivationPathHelperProvider.getAccount(derivationPath);
            // set opts.useLegacyPurpose
            if (this.derivationPathHelperProvider.parsePath(derivationPath).purpose ==
                "44'") {
                opts.useLegacyPurpose = true;
                this.logger.debug('Using 44 for Multisig');
            }
            // set opts.useLegacyCoinType
            if (this.coin == 'bch' &&
                this.derivationPathHelperProvider.parsePath(derivationPath).coinCode ==
                    "0'") {
                opts.useLegacyCoinType = true;
                this.logger.debug('Using 0 for BCH creation');
            }
            if (!opts.networkName ||
                !opts.derivationStrategy ||
                !Number.isInteger(opts.account)) {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Invalid derivation path');
                this.popupProvider.ionicAlert(title, subtitle);
                return;
            }
            if (!this.derivationPathHelperProvider.isValidDerivationPathCoin(this.joinForm.value.derivationPath, this.coin)) {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Invalid derivation path for selected coin');
                this.popupProvider.ionicAlert(title, subtitle);
                return;
            }
        }
        if (setSeed && !opts.mnemonic && !opts.extendedPrivateKey) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Please enter the wallet recovery phrase');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        this.join(opts);
    }
    join(opts) {
        this.onGoingProcessProvider.set('joiningWallet');
        opts['keyId'] = this.keyId;
        this.profileProvider
            .joinWallet(opts)
            .then(wallet => {
            this.clipboardProvider.clearClipboardIfValidData(['JoinWallet']);
            this.onGoingProcessProvider.clear();
            this.walletProvider.updateRemotePreferences(wallet);
            this.pushNotificationsProvider.updateSubscription(wallet);
            // using setRoot(TabsPage) as workaround when coming from scanner
            this.app
                .getRootNavs()[0]
                .setRoot(__WEBPACK_IMPORTED_MODULE_6__tabs_tabs__["a" /* TabsPage */])
                .then(() => {
                this.events.publish('Local/WalletListChange');
                setTimeout(() => {
                    this.events.publish('OpenWallet', wallet);
                }, 1000);
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            const title = this.translate.instant('Error');
            this.popupProvider.ionicAlert(title, err);
            return;
        });
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__scan_scan__["a" /* ScanPage */], { fromJoin: true });
    }
};
JoinWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-join-wallet',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/add/join-wallet/join-wallet.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Shared Wallet\' | translate}}</ion-title>\n    <ion-buttons end>\n      <button ion-button (click)="setOptsAndJoin()" [disabled]="!joinForm.valid">\n        <span translate>Join</span>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <form [formGroup]="joinForm">\n    <ion-item>\n      <ion-label floating>{{\'Your name\' | translate}}</ion-label>\n      <ion-input type="text" formControlName="myName"></ion-input>\n    </ion-item>\n\n    <ion-item>\n      <ion-label floating>{{\'Wallet invitation\' | translate}}</ion-label>\n      <ion-input type="text" formControlName="invitationCode" (ionChange)="processInvitation(joinForm.value.invitationCode)"></ion-input>\n\n      <ion-icon *ngIf="joinForm.controls[\'invitationCode\'].status == \'VALID\'" name="ios-checkmark-circle" class="check success" item-right></ion-icon>\n\n      <ion-icon class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n    </ion-item>\n\n    <button ion-button class="button-standard button-secondary" (click)="showAdvOpts = !showAdvOpts">\n      <span *ngIf="!showAdvOpts">{{\'Show advanced options\' | translate}}</span>\n      <span *ngIf="showAdvOpts">{{\'Hide advanced options\' | translate}}</span>\n    </button>\n\n    <div *ngIf="showAdvOpts" padding-bottom>\n      <ion-item>\n        <ion-label floating>Wallet Service URL</ion-label>\n        <ion-input type="text" formControlName="bwsURL"></ion-input>\n      </ion-item>\n\n      <ion-item *ngIf="!keyId">\n        <ion-label stacked>{{\'Wallet key\' | translate}}</ion-label>\n        <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="selectedSeed" (ionChange)="seedOptionsChange(joinForm.value.selectedSeed)">\n          <ion-option *ngFor="let opt of seedOptions" [value]="opt.id">{{opt.label}}</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <ion-item *ngIf="joinForm.value.selectedSeed == \'set\' && !keyId">\n        <ion-label stacked>{{\'Wallet recovery phrase\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="recoveryPhrase"></ion-input>\n      </ion-item>\n\n      <ion-item *ngIf="joinForm.value.selectedSeed == \'set\' && !keyId">\n        <ion-label stacked>{{\'Derivation path\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="derivationPath"></ion-input>\n      </ion-item>\n    </div>\n  </form>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/add/join-wallet/join-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_8__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_11__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_16__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_clipboard_clipboard__["a" /* ClipboardProvider */]])
], JoinWalletPage);

//# sourceMappingURL=join-wallet.js.map

/***/ }),

/***/ 324:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__add_wallet_add_wallet__ = __webpack_require__(320);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__add_import_wallet_import_wallet__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__add_join_wallet_join_wallet__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__add_select_currency_select_currency__ = __webpack_require__(326);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers__ = __webpack_require__(35);



// pages




// providers

let AddPage = class AddPage {
    constructor(navCtrl, logger, navParams) {
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.navParams = navParams;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AddPage');
        this.keyId = this.navParams.data.keyId;
        this.isOnboardingFlow = this.navParams.data.isOnboardingFlow;
        this.isZeroState = this.navParams.data.isZeroState;
    }
    goToAddWalletPage(isShared, isJoin, isCreate) {
        if (isCreate) {
            if (this.navParams.data.isMultipleSeed) {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_3__add_wallet_add_wallet__["a" /* AddWalletPage */], {
                    isCreate,
                    isMultipleSeed: true,
                    isShared,
                    url: this.navParams.data.url
                });
            }
            else {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__add_select_currency_select_currency__["a" /* SelectCurrencyPage */], {
                    isShared,
                    isOnboardingFlow: this.isOnboardingFlow,
                    isZeroState: this.isZeroState && !isShared,
                    keyId: this.keyId
                });
            }
        }
        else if (isJoin) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_join_wallet_join_wallet__["a" /* JoinWalletPage */], {
                keyId: this.keyId,
                url: this.navParams.data.url
            });
        }
    }
    goToImportWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__add_import_wallet_import_wallet__["a" /* ImportWalletPage */]);
    }
};
AddPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-add',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/add/add.html"*/'<wide-header-page title="{{isZeroState ? \'Create Key\' : \'Add Wallet\'  | translate}}">\n  <div page-content>\n    <ion-list class="settings-list bp-list">\n      <button class="list-button" ion-item (click)="goToAddWalletPage(false, false, true)">\n        <ion-icon item-start>\n          <img src="assets/img/add-wallet/wallet.svg" />\n        </ion-icon>\n        <div class="item-title" translate>{{isZeroState ? \'New Key\' : \'Simple Wallet\'}}</div>\n        <span class="item-subtitle" translate>Quick and easy setup</span>\n      </button>\n      <button class="list-button" ion-item (click)="goToAddWalletPage(true, false, true)">\n        <ion-icon item-start>\n          <img src="assets/img/add-wallet/multi-device.svg" />\n        </ion-icon>\n        <div class="item-title" translate>Shared Wallet</div>\n        <span class="item-subtitle" translate>Requires multiple devices (most secure)</span>\n      </button>\n      <button class="list-button" ion-item (click)="goToAddWalletPage(false, true, false)" *ngIf="!isZeroState">\n        <ion-icon item-start>\n          <img src="assets/img/add-wallet/multi-user.svg" />\n        </ion-icon>\n        <div class="item-title" translate>Join Shared Wallet</div>\n        <span class="item-subtitle" translate>Requires invitation to join</span>\n      </button>\n      <button class="list-button" ion-item (click)="goToImportWallet()">\n        <ion-icon item-start>\n          <img src="assets/img/add-wallet/import.svg" />\n        </ion-icon>\n        <div class="item-title" translate>Import Wallet</div>\n        <span class="item-subtitle" translate>Recover your wallet using your passphrase</span>\n      </button>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/add/add.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers__["N" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */]])
], AddPage);

//# sourceMappingURL=add.js.map

/***/ }),

/***/ 325:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ImportWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__includes_coin_selector_coin_selector__ = __webpack_require__(983);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__scan_scan__ = __webpack_require__(247);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__tabs_tabs__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_push_notifications_push_notifications__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__ = __webpack_require__(32);





// Pages



// Providers













let ImportWalletPage = class ImportWalletPage {
    constructor(app, navCtrl, navParams, form, bwcProvider, walletProvider, configProvider, currencyProvider, popupProvider, platformProvider, logger, onGoingProcessProvider, profileProvider, translate, events, pushNotificationsProvider, actionSheetProvider, derivationPathHelperProvider, modalCtrl, bwcErrorProvider) {
        this.app = app;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.form = form;
        this.bwcProvider = bwcProvider;
        this.walletProvider = walletProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.popupProvider = popupProvider;
        this.platformProvider = platformProvider;
        this.logger = logger;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.profileProvider = profileProvider;
        this.translate = translate;
        this.events = events;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.modalCtrl = modalCtrl;
        this.bwcErrorProvider = bwcErrorProvider;
        this.updateWordsHandler = data => {
            this.processedInfo = this.processWalletInfo(data.value);
            this.setForm();
        };
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.reader = new FileReader();
        this.defaults = this.configProvider.getDefaults();
        this.isCordova = this.platformProvider.isCordova;
        this.isSafari = this.platformProvider.isSafari;
        this.isIOS = this.platformProvider.isIOS;
        this.selectedTab = 'words';
        this.showAdvOpts = false;
        this.availableCoins = this.currencyProvider.getAvailableChains();
        this.code = this.navParams.data.code;
        this.processedInfo = this.processWalletInfo(this.code);
        this.formFile = null;
        this.importForm = this.form.group({
            words: [null, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required],
            backupText: [null],
            passphrase: [null],
            file: [null],
            filePassword: [null],
            derivationPathEnabled: [false],
            coin: ['btc'],
            derivationPath: [this.derivationPathHelperProvider.defaultBTC],
            bwsURL: [this.defaults.bws.url],
            isMultisig: [false]
        });
        this.events.subscribe('Local/BackupScan', this.updateWordsHandler);
        this.setForm();
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/BackupScan', this.updateWordsHandler);
    }
    setForm() {
        if (this.processedInfo) {
            this.importForm.controls['words'].setValue(this.processedInfo.data);
        }
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    selectTab(tab) {
        this.selectedTab = tab;
        switch (tab) {
            case 'words':
                this.file = null;
                this.formFile = null;
                this.importForm.get('words').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required]);
                this.importForm.get('filePassword').clearValidators();
                if (this.isCordova || this.isSafari)
                    this.importForm.get('backupText').clearValidators();
                else
                    this.importForm.get('file').clearValidators();
                break;
            case 'file':
                if (this.isCordova || this.isSafari)
                    this.importForm
                        .get('backupText')
                        .setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required]);
                else
                    this.importForm.get('file').setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required]);
                this.importForm
                    .get('filePassword')
                    .setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required]);
                this.importForm.get('words').clearValidators();
                break;
            default:
                this.importForm.get('words').clearValidators();
                this.importForm.get('file').clearValidators();
                this.importForm.get('filePassword').clearValidators();
                break;
        }
        this.importForm.get('words').updateValueAndValidity();
        this.importForm.get('file').updateValueAndValidity();
        this.importForm.get('filePassword').updateValueAndValidity();
        this.importForm.get('backupText').updateValueAndValidity();
    }
    processWalletInfo(code) {
        if (!code)
            return undefined;
        const parsedCode = code.split('|');
        const info = {
            type: parsedCode[0],
            data: parsedCode[1],
            network: parsedCode[2],
            derivationPath: parsedCode[3],
            hasPassphrase: parsedCode[4] == 'true' ? true : false,
            coin: parsedCode[5] // deprecated
        };
        if (!info.data) {
            const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', {
                msg: this.translate.instant('Invalid data'),
                title: this.translate.instant('Error')
            });
            errorInfoSheet.present();
            return undefined;
        }
        if (info.type == '1' && info.hasPassphrase) {
            const title = this.translate.instant('Warning');
            const subtitle = this.translate.instant('Password required. Make sure to enter your password in advanced options');
            this.popupProvider.ionicAlert(title, subtitle);
        }
        return info;
    }
    importBlob(str, opts) {
        let str2;
        let err = null;
        try {
            str2 = this.bwcProvider
                .getSJCL()
                .decrypt(this.importForm.value.filePassword, str);
        }
        catch (e) {
            err = this.translate.instant('Could not decrypt file, check your password');
            this.logger.error('Import: could not decrypt file', e);
        }
        if (err) {
            const title = this.translate.instant('Error');
            this.popupProvider.ionicAlert(title, err);
            return;
        }
        this.onGoingProcessProvider.set('importingWallet');
        opts.compressed = null;
        opts.password = null;
        this.profileProvider
            .importFile(str2, opts)
            .then((wallet) => {
            this.onGoingProcessProvider.clear();
            if (wallet)
                this.finish([].concat(wallet));
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            const title = this.translate.instant('Error');
            this.popupProvider.ionicAlert(title, err);
            return;
        });
    }
    finish(wallets) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            wallets.forEach(wallet => {
                this.walletProvider.updateRemotePreferences(wallet);
                this.pushNotificationsProvider.updateSubscription(wallet);
                this.profileProvider.setWalletBackup(wallet.credentials.walletId);
            });
            if (wallets && wallets[0]) {
                this.profileProvider.setBackupGroupFlag(wallets[0].credentials.keyId);
            }
            // using setRoot(TabsPage) as workaround when coming from scanner
            this.app
                .getRootNavs()[0]
                .setRoot(__WEBPACK_IMPORTED_MODULE_7__tabs_tabs__["a" /* TabsPage */])
                .then(() => {
                this.events.publish('Local/WalletListChange');
            });
        });
    }
    importExtendedPrivateKey(xPrivKey, opts) {
        this.onGoingProcessProvider.set('importingWallet');
        this.profileProvider
            .importExtendedPrivateKey(xPrivKey, opts)
            .then((wallets) => {
            this.onGoingProcessProvider.clear();
            this.finish(wallets);
        })
            .catch(err => {
            this.processError(err);
        });
    }
    importWithDerivationPath(opts) {
        this.onGoingProcessProvider.set('importingWallet');
        this.profileProvider
            .importWithDerivationPath(opts)
            .then(wallet => {
            this.onGoingProcessProvider.clear();
            if (wallet)
                this.finish([].concat(wallet));
        })
            .catch(err => {
            this.processError(err);
        });
    }
    importMnemonic(words, opts) {
        this.onGoingProcessProvider.set('importingWallet');
        this.profileProvider
            .importMnemonic(words, opts)
            .then((wallets) => {
            this.onGoingProcessProvider.clear();
            this.finish(wallets);
        })
            .catch(err => {
            this.processError(err);
        });
    }
    processError(err) {
        if (err == 'WALLET_DOES_NOT_EXIST') {
            const noWalletWarningInfoSheet = this.actionSheetProvider.createInfoSheet('import-no-wallet-warning');
            noWalletWarningInfoSheet.present();
            noWalletWarningInfoSheet.onDidDismiss(option => {
                if (option || typeof option === 'undefined') {
                    // Go back
                    this.logger.debug('Go back clicked');
                }
                else {
                    // Continue anyway
                    this.logger.debug('Continue anyway clicked');
                    if (this.importForm.value.derivationPathEnabled) {
                        this.setOptsAndCreate(this.importForm.value.coin);
                    }
                    else {
                        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_5__includes_coin_selector_coin_selector__["a" /* CoinSelectorPage */], {
                            description: this.translate.instant('Please select the coin of the wallet to import:')
                        }, {
                            enableBackdropDismiss: false,
                            cssClass: 'fullscreen-modal'
                        });
                        modal.present({ animate: false });
                        modal.onDidDismiss(data => {
                            if (data.selectedCoin) {
                                this.setOptsAndCreate(data.selectedCoin);
                            }
                        });
                    }
                }
            });
        }
        else {
            const title = this.translate.instant('Error');
            this.showErrorInfoSheet(title, err);
        }
        this.onGoingProcessProvider.clear();
        return;
    }
    setOptsAndCreate(coin) {
        const opts = {
            keyId: undefined,
            name: this.currencyProvider.getCoinName(coin),
            m: 1,
            n: 1,
            myName: null,
            networkName: 'livenet',
            bwsurl: this.importForm.value.bwsURL,
            singleAddress: this.currencyProvider.isSingleAddress(coin),
            coin: __WEBPACK_IMPORTED_MODULE_12__providers_currency_currency__["a" /* Coin */][coin.toUpperCase()]
        };
        const words = this.importForm.value.words;
        if (words.indexOf(' ') == -1 &&
            words.indexOf('prv') == 1 &&
            words.length > 108) {
            opts.extendedPrivateKey = words;
        }
        else {
            opts.mnemonic = words;
        }
        const derivationPath = this.importForm.value.derivationPath;
        opts.networkName = this.derivationPathHelperProvider.getNetworkName(derivationPath);
        opts.derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(derivationPath);
        opts.account = this.derivationPathHelperProvider.getAccount(derivationPath);
        // set opts.useLegacyPurpose
        if (this.derivationPathHelperProvider.parsePath(this.importForm.value.derivationPath).purpose == "44'" &&
            opts.n > 1) {
            opts.useLegacyPurpose = true;
            this.logger.debug('Using 44 for Multisig');
        }
        // set opts.useLegacyCoinType
        if (coin == 'bch' &&
            this.derivationPathHelperProvider.parsePath(this.importForm.value.derivationPath).coinCode == "0'") {
            opts.useLegacyCoinType = true;
            this.logger.debug('Using 0 for BCH creation');
        }
        if (!opts.networkName ||
            !opts.derivationStrategy ||
            !Number.isInteger(opts.account)) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Invalid derivation path');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        if (!opts.mnemonic && !opts.extendedPrivateKey) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Please enter the wallet recovery phrase');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        if (!this.derivationPathHelperProvider.isValidDerivationPathCoin(this.importForm.value.derivationPath, coin)) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Invalid derivation path for selected coin');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        this.createSpecifyingwords(opts);
    }
    createSpecifyingwords(opts) {
        this.logger.debug('Creating from import');
        this.onGoingProcessProvider.set('creatingWallet');
        this.profileProvider
            .createWallet(opts)
            .then(wallet => {
            this.onGoingProcessProvider.clear();
            if (wallet)
                this.finish([].concat(wallet));
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED') {
                this.logger.error('Create: could not create wallet', err);
                const title = this.translate.instant('Error');
                err = this.bwcErrorProvider.msg(err);
                this.popupProvider.ionicAlert(title, err);
            }
            return;
        });
    }
    import() {
        if (this.selectedTab === 'file') {
            this.importFromFile();
        }
        else {
            this.importFromMnemonic();
        }
    }
    importFromFile() {
        if (!this.importForm.valid) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('There is an error in the form');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        const backupFile = this.file;
        const backupText = this.importForm.value.backupText;
        if (!backupFile && !backupText) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Please, select your backup file');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        if (backupFile) {
            this.reader.readAsBinaryString(backupFile);
        }
        else {
            const opts = {};
            opts.bwsurl = this.importForm.value.bwsURL;
            this.importBlob(backupText, opts);
        }
    }
    importFromMnemonic() {
        if (!this.importForm.valid) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('There is an error in the form');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        const opts = {};
        if (this.importForm.value.bwsURL)
            opts.bwsurl = this.importForm.value.bwsURL;
        if (this.importForm.value.derivationPathEnabled) {
            const derivationPath = this.importForm.value.derivationPath;
            opts.networkName = this.derivationPathHelperProvider.getNetworkName(derivationPath);
            opts.derivationStrategy = this.derivationPathHelperProvider.getDerivationStrategy(derivationPath);
            opts.account = this.derivationPathHelperProvider.getAccount(derivationPath);
            /* TODO: opts.n is just used to determinate if the wallet is multisig (m/48'/xx) or single sig (m/44')
              we should change the name to 'isMultisig'.
              isMultisig is used to allow import old multisig wallets with derivation strategy = 'BIP44'
            */
            opts.n = this.importForm.value.isMultisig
                ? 2
                : opts.derivationStrategy == 'BIP48'
                    ? 2
                    : 1;
            opts.coin = this.importForm.value.coin;
            // set opts.useLegacyPurpose
            if (this.derivationPathHelperProvider.parsePath(derivationPath).purpose ==
                "44'" &&
                opts.n > 1) {
                opts.useLegacyPurpose = true;
                this.logger.debug('Using 44 for Multisig');
            }
            // set opts.useLegacyCoinType
            if (opts.coin == 'bch' &&
                this.derivationPathHelperProvider.parsePath(derivationPath).coinCode ==
                    "0'") {
                opts.useLegacyCoinType = true;
                this.logger.debug('Using 0 for BCH creation');
            }
            if (!opts.networkName ||
                !opts.derivationStrategy ||
                !Number.isInteger(opts.account)) {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Invalid derivation path');
                this.popupProvider.ionicAlert(title, subtitle);
                return;
            }
            if (!this.derivationPathHelperProvider.isValidDerivationPathCoin(this.importForm.value.derivationPath, this.importForm.value.coin)) {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Invalid derivation path for selected coin');
                this.popupProvider.ionicAlert(title, subtitle);
                return;
            }
        }
        opts.passphrase = this.importForm.value.passphrase || null;
        const words = this.importForm.value.words || null;
        if (!words) {
            const title = this.translate.instant('Error');
            const subtitle = this.translate.instant('Please enter the recovery phrase');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        else if (words.indexOf('xprv') == 0 || words.indexOf('tprv') == 0) {
            opts.extendedPrivateKey = words;
            return this.importForm.value.derivationPathEnabled
                ? this.importWithDerivationPath(opts)
                : this.importExtendedPrivateKey(words, opts);
        }
        else {
            const wordList = words.trim().split(/[\u3000\s]+/);
            if (wordList.length % 3 != 0) {
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Wrong number of recovery words:');
                this.popupProvider.ionicAlert(title, subtitle + ' ' + wordList.length);
                return;
            }
        }
        opts.mnemonic = words;
        this.importForm.value.derivationPathEnabled
            ? this.importWithDerivationPath(opts)
            : this.importMnemonic(words, opts);
    }
    fileChangeEvent($event) {
        this.file = $event.target
            ? $event.target.files[0]
            : $event.srcElement.files[0];
        this.formFile = $event.target.value;
        // Most browsers return `C:\fakepath\FILENAME`
        this.prettyFileName = this.formFile.split('\\').pop();
        this.getFile();
    }
    getFile() {
        // If we use onloadend, we need to check the readyState.
        this.reader.onloadend = () => {
            if (this.reader.readyState === 2) {
                // DONE === 2
                const opts = {};
                opts.bwsurl = this.importForm.value.bwsURL;
                const reader = this.reader.result.toString();
                this.importBlob(reader, opts);
            }
        };
    }
    setDerivationPath(coin) {
        const defaultCoin = `default${coin.toUpperCase()}`;
        const derivationPath = this.derivationPathHelperProvider[defaultCoin];
        this.importForm.controls['derivationPath'].setValue(derivationPath);
    }
    changeDerivationPathValidators() {
        if (this.importForm.value.derivationPathEnabled) {
            this.importForm
                .get('derivationPath')
                .setValidators([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required]);
            this.setDerivationPath(this.importForm.value.coin);
        }
        else {
            this.importForm.get('derivationPath').clearValidators();
        }
        this.importForm.get('derivationPath').updateValueAndValidity();
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__scan_scan__["a" /* ScanPage */], { fromImport: true });
    }
    showErrorInfoSheet(title, msg) {
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg, title });
        errorInfoSheet.present();
    }
};
ImportWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-import-wallet',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/add/import-wallet/import-wallet.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{ \'Import Wallet\' | translate }}</ion-title>\n    <ion-buttons end>\n      <button ion-button (click)="import()" [disabled]="!importForm.valid">\n        <span translate>Import</span>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div [attr.padding]="isIOS ? \'\' : null">\n    <ion-segment [(ngModel)]="selectedTab" color="primary" (ionChange)="selectTab(selectedTab)">\n      <ion-segment-button value="words">\n        {{ \'Recovery Phrase\' | translate }}\n      </ion-segment-button>\n      <ion-segment-button value="file">\n        {{ \'File/Text\' | translate }}\n      </ion-segment-button>\n    </ion-segment>\n  </div>\n\n  <form [formGroup]="importForm">\n    <ion-item *ngIf="selectedTab == \'words\'">\n      <ion-label stacked>{{\'Type the recovery phrase (usually 12 words)\' | translate}}</ion-label>\n      <ion-textarea formControlName="words" [value]="importForm.value.words" autocapitalize="none">\n      </ion-textarea>\n      <ion-icon class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n    </ion-item>\n\n    <div *ngIf="selectedTab == \'file\'">\n      <ion-item class="hide-validation" *ngIf="!isSafari && !isCordova">\n        <ion-input class="upload-hidden" type="file" accept="json" [(ngModel)]="formFile" (change)="fileChangeEvent($event)" formControlName="file"></ion-input>\n        <div item-content class="upload-ui">\n          <div class="empty-message">{{\'Choose a backup file from your computer\' | translate}}&hellip;</div>\n          <div class="filled-message">{{prettyFileName}}</div>\n        </div>\n      </ion-item>\n\n      <ion-item *ngIf="isSafari || isCordova">\n        <ion-label floating>{{\'Paste the backup plain text code\' | translate}}</ion-label>\n        <ion-textarea formControlName="backupText" rows="7" [value]="importForm.value.backupText"></ion-textarea>\n      </ion-item>\n\n      <ion-item>\n        <ion-label floating>{{\'Password\' | translate}}</ion-label>\n        <ion-input type="password" formControlName="filePassword"></ion-input>\n      </ion-item>\n    </div>\n\n    <button ion-button class="button-standard button-secondary" (click)="showAdvOpts = !showAdvOpts">\n      <span *ngIf="!showAdvOpts">{{\'Show advanced options\' | translate}}</span>\n      <span *ngIf="showAdvOpts">{{\'Hide advanced options\' | translate}}</span>\n    </button>\n\n    <div *ngIf="showAdvOpts" padding-bottom>\n      <ion-item>\n        <ion-label floating>Wallet Service URL</ion-label>\n        <ion-input type="text" formControlName="bwsURL"></ion-input>\n      </ion-item>\n\n      <div *ngIf="selectedTab == \'words\'">\n        <ion-item>\n          <ion-label>{{\'Specify derivation path\' | translate}}</ion-label>\n          <ion-toggle formControlName="derivationPathEnabled" (ionChange)="changeDerivationPathValidators();"></ion-toggle>\n        </ion-item>\n\n        <ion-item *ngIf="importForm.value.derivationPathEnabled">\n          <ion-label floating>{{\'Coin\' | translate}}</ion-label>\n          <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="coin" (ionChange)="setDerivationPath($event)">\n            <div *ngFor="let coin of availableCoins">\n              <ion-option value="{{coin}}"> {{ getCoinName(coin) }} ({{ coin.toUpperCase() }})</ion-option>\n            </div>\n          </ion-select>\n        </ion-item>\n\n        <ion-item *ngIf="importForm.value.derivationPathEnabled">\n          <ion-label floating>{{\'Derivation path\' | translate}}</ion-label>\n          <ion-input type="text" formControlName="derivationPath" [value]="importForm.value.derivationPath"></ion-input>\n        </ion-item>\n\n        <ion-item *ngIf="importForm.value.derivationPathEnabled && importForm.value.derivationPath === this.derivationPathHelperProvider.defaultBTC">\n          <ion-label>{{\'Shared Wallet\' | translate}}</ion-label>\n          <ion-checkbox formControlName="isMultisig"></ion-checkbox>\n        </ion-item>\n\n        <ion-item class="with-label">\n          <ion-label floating>{{\'Password\' | translate}}</ion-label>\n          <ion-input type="password" formControlName="passphrase"></ion-input>\n        </ion-item>\n\n        <label-tip type="info" header="no-header">\n          <div label-tip-body translate>\n            This field is only for users who, in previous versions (it\'s not supported anymore), set a password to protect their recovery phrase. This field is not for your encrypt password.\n          </div>\n        </label-tip>\n      </div>\n\n    </div>\n  </form>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/add/import-wallet/import-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_15__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_19__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */]])
], ImportWalletPage);

//# sourceMappingURL=import-wallet.js.map

/***/ }),

/***/ 326:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SelectCurrencyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__add_import_wallet_import_wallet__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__settings_wallet_group_settings_wallet_group_onboarding_wallet_group_onboarding__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__create_wallet_create_wallet__ = __webpack_require__(321);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__ = __webpack_require__(25);





// pages



// providers


let SelectCurrencyPage = class SelectCurrencyPage {
    constructor(actionSheetProvider, currencyProvider, navCtrl, logger, navParam, profileProvider, onGoingProcessProvider, walletProvider, pushNotificationsProvider, bwcErrorProvider, translate, popupProvider, modalCtrl, persistenceProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.currencyProvider = currencyProvider;
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.navParam = navParam;
        this.profileProvider = profileProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.walletProvider = walletProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.translate = translate;
        this.popupProvider = popupProvider;
        this.modalCtrl = modalCtrl;
        this.persistenceProvider = persistenceProvider;
        this.coinsSelected = {};
        this.tokensSelected = {};
        this.tokenDisabled = {};
        this.availableChains = this.navParam.data.isShared
            ? this.currencyProvider.getMultiSigCoins()
            : this.currencyProvider.getAvailableChains();
        this.availableTokens = this.currencyProvider.getAvailableTokens();
        for (const chain of this.availableChains) {
            this.coinsSelected[chain] = true;
        }
        this.shouldShowKeyOnboarding();
        this.setTokens();
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SelectCurrencyPage');
        this.isOnboardingFlow = this.navParam.data.isOnboardingFlow;
        this.isZeroState = this.navParam.data.isZeroState;
        this.title = this.isZeroState
            ? this.translate.instant('Select currencies')
            : this.translate.instant('Select currency');
    }
    shouldShowKeyOnboarding() {
        this.persistenceProvider.getKeyOnboardingFlag().then(value => {
            if (!value) {
                this.showKeyOnboarding = true;
                const wallets = this.profileProvider.getWallets();
                const walletsGroups = __WEBPACK_IMPORTED_MODULE_4_lodash__["values"](__WEBPACK_IMPORTED_MODULE_4_lodash__["groupBy"](wallets, 'keyId'));
                walletsGroups.forEach((walletsGroup) => {
                    if (walletsGroup[0].canAddNewAccount)
                        this.showKeyOnboarding = false;
                });
            }
            else {
                this.showKeyOnboarding = false;
            }
        });
    }
    showKeyOnboardingSlides(coins) {
        this.logger.debug('Showing key onboarding');
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__settings_wallet_group_settings_wallet_group_onboarding_wallet_group_onboarding__["a" /* WalletGroupOnboardingPage */], null, {
            showBackdrop: false,
            enableBackdropDismiss: false
        });
        modal.present();
        modal.onDidDismiss(() => {
            this._createWallets(coins);
        });
        this.persistenceProvider.setKeyOnboardingFlag();
    }
    goToCreateWallet(coin) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__create_wallet_create_wallet__["a" /* CreateWalletPage */], {
            isShared: this.navParam.data.isShared,
            coin,
            keyId: this.navParam.data.keyId,
            showKeyOnboarding: this.showKeyOnboarding
        });
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    goToImportWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_import_wallet_import_wallet__["a" /* ImportWalletPage */]);
    }
    _createWallets(coins) {
        const selectedCoins = __WEBPACK_IMPORTED_MODULE_4_lodash__["keys"](__WEBPACK_IMPORTED_MODULE_4_lodash__["pickBy"](this.coinsSelected));
        coins = coins || selectedCoins;
        const selectedTokens = __WEBPACK_IMPORTED_MODULE_4_lodash__["keys"](__WEBPACK_IMPORTED_MODULE_4_lodash__["pickBy"](this.tokensSelected));
        this.onGoingProcessProvider.set('creatingWallet');
        this.profileProvider
            .createMultipleWallets(coins, selectedTokens)
            .then(wallets => {
            this.walletProvider.updateRemotePreferences(wallets);
            this.pushNotificationsProvider.updateSubscription(wallets);
            this.endProcess();
        })
            .catch(e => {
            this.showError(e);
        });
    }
    createWallets(coins) {
        if (this.showKeyOnboarding) {
            this.showKeyOnboardingSlides(coins);
            return;
        }
        else if (this.isZeroState) {
            this.showInfoSheet(coins);
            return;
        }
        this._createWallets(coins);
    }
    showError(err) {
        this.onGoingProcessProvider.clear();
        if (err &&
            err.message != 'FINGERPRINT_CANCELLED' &&
            err.message != 'PASSWORD_CANCELLED') {
            this.logger.error('Create: could not create wallet', err);
            const title = this.translate.instant('Error');
            err = this.bwcErrorProvider.msg(err);
            this.popupProvider.ionicAlert(title, err);
        }
        return;
    }
    endProcess() {
        this.onGoingProcessProvider.clear();
        this.navCtrl.popToRoot();
    }
    createAndBindTokenWallet(pairedWallet, token) {
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](pairedWallet)) {
            this.profileProvider.createTokenWallet(pairedWallet, token).then(() => {
                // store preferences for the paired eth wallet
                this.walletProvider.updateRemotePreferences(pairedWallet);
                this.endProcess();
            });
        }
    }
    showPairedWalletSelector(token) {
        const eligibleWallets = this.navParam.data.keyId
            ? this.profileProvider.getWalletsFromGroup({
                keyId: this.navParam.data.keyId,
                network: 'livenet',
                pairFor: token
            })
            : [];
        const walletSelector = this.actionSheetProvider.createInfoSheet('addTokenWallet', {
            wallets: eligibleWallets,
            token
        });
        walletSelector.present();
        walletSelector.onDidDismiss(pairedWallet => {
            return this.createAndBindTokenWallet(pairedWallet, token);
        });
    }
    setTokens(coin) {
        if (coin === 'eth' || !coin) {
            for (const token of this.availableTokens) {
                if (this.isZeroState) {
                    this.tokensSelected[token.symbol] = false;
                }
                else {
                    let canCreateit = __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.profileProvider.getWalletsFromGroup({
                        keyId: this.navParam.data.keyId,
                        network: 'livenet',
                        pairFor: token
                    }));
                    this.tokenDisabled[token.symbol] = canCreateit;
                }
            }
        }
    }
    showInfoSheet(coins) {
        const infoSheet = this.actionSheetProvider.createInfoSheet('new-key');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                this.showKeyOnboardingSlides(coins);
                return;
            }
            this._createWallets(coins);
        });
    }
};
SelectCurrencyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-select-currency',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/add/select-currency/select-currency.html"*/'<wide-header-page title="{{title}}">\n  <div page-content *ngIf="!isZeroState">\n    <span class="list-subtitle" translate>Featured Currencies</span>\n    <ion-list class="settings-list bp-list">\n      <div *ngFor="let coin of availableChains">\n        <button class="list-button" ion-item (click)="goToCreateWallet(coin)">\n          <ion-icon item-start>\n            <img src="assets/img/currencies/{{coin}}.svg" />\n          </ion-icon>\n          <div class="item-title">{{ getCoinName(coin) }} ({{ coin.toUpperCase() }})</div>\n        </button>\n      </div>\n      <div *ngIf="!navParam.data.isShared">\n        <span class="list-subtitle" translate>Tokens</span>\n        <button *ngFor="let token of availableTokens" class="list-button" [disabled]="tokenDisabled[token.symbol]" ion-item (click)="showPairedWalletSelector(token)">\n          <ion-icon item-start>\n            <img src="assets/img/currencies/{{token.symbol.toLowerCase()}}.svg" />\n          </ion-icon>\n          <div class="item-title">{{ token.name }} ({{ token.symbol }})</div>\n        </button>\n      </div>\n    </ion-list>\n  </div>\n  <div page-content *ngIf="isZeroState" class="zero-page">\n    <span class="list-subtitle" translate>Featured Currencies</span>\n    <div class="flex-content">\n      <ion-list class="settings-list bp-list">\n        <div *ngFor="let coin of availableChains">\n          <ion-item class="list-button">\n            <ion-icon item-start>\n              <img src="assets/img/currencies/{{coin}}.svg" />\n            </ion-icon>\n            <ion-label class="item-title">{{ getCoinName(coin) }} ({{coin.toUpperCase() }})</ion-label>\n            <ion-toggle [(ngModel)]="coinsSelected[coin]" (ngModelChange)="setTokens(coin)"></ion-toggle>\n          </ion-item>\n        </div>\n        <div *ngIf="!navParam.data.isShared">\n          <span class="list-subtitle" translate>Tokens</span>\n          <ion-item *ngFor="let token of availableTokens" class="list-button">\n            <ion-icon item-start>\n              <img src="assets/img/currencies/{{token.symbol.toLowerCase()}}.svg" />\n            </ion-icon>\n            <ion-label class="item-title">\n              {{ token.name }} ({{ token.symbol }})\n            </ion-label>\n            <ion-toggle [(ngModel)]="tokensSelected[token.symbol]" [disabled]="!coinsSelected.eth"></ion-toggle>\n          </ion-item>\n        </div>\n      </ion-list>\n      <div>\n        <button ion-button class="button-standard" [disabled]="!coinsSelected.btc && !coinsSelected.bch && !coinsSelected.eth" (click)="createWallets()">\n          {{\'Create\' | translate}}\n        </button>\n        <button ion-button clear class="button-standard" (click)="goToImportWallet()" *ngIf="isOnboardingFlow">\n          {{ \'Import existing wallet\' | translate }}\n        </button>\n      </div>\n    </div>\n  </div>\n</wide-header-page>\n'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/add/select-currency/select-currency.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["N" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["U" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["O" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["_13" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["V" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["l" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["S" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["Q" /* PersistenceProvider */]])
], SelectCurrencyPage);

//# sourceMappingURL=select-currency.js.map

/***/ }),

/***/ 327:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayCardPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__send_amount_amount__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bitpay_card_bitpay_card__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_bitpay_bitpay__ = __webpack_require__(246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_time_time__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_moment__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_moment__);






// Pages

// providers








const TIMEOUT_FOR_REFRESHER = 1000;
let BitPayCardPage = class BitPayCardPage {
    constructor(translate, bitPayProvider, bitPayCardProvider, logger, popupProvider, timeProvider, externalLinkProvider, navParams, navCtrl, statusBar, platformProvider) {
        this.translate = translate;
        this.bitPayProvider = bitPayProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.timeProvider = timeProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.statusBar = statusBar;
        this.platformProvider = platformProvider;
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.dateRange = {
            value: 'last30Days'
        };
        this.network = this.bitPayProvider.getEnvironment().network;
        this.cardId = this.navParams.data.id;
        if (!this.cardId)
            this.navCtrl.pop();
        this.bitPayCardProvider
            .get({
            cardId: this.cardId
        })
            .then(cards => {
            if (cards && cards[0]) {
                this.lastFourDigits = cards[0].lastFourDigits;
                this.balance = cards[0].balance;
                this.updatedOn = cards[0].updatedOn;
                this.currency = cards[0].currency;
                this.setDateTime(cards[0].history);
                this.setHistory(cards[0].history);
            }
            this.update();
        });
    }
    ionViewWillEnter() {
        if (this.platformProvider.isIOS) {
            this.statusBar.styleLightContent();
        }
    }
    ionViewDidEnter() {
        this.bitPayCardProvider.logEvent('legacycard_view', {});
    }
    ionViewWillLeave() {
        if (this.platformProvider.isIOS) {
            this.statusBar.styleDefault();
        }
    }
    logLegacyCardTopupStartEvent() {
        this.bitPayCardProvider.logEvent('legacycard_topup_start', {});
    }
    logLegacyCardViewAmountItem() {
        this.bitPayCardProvider.logEvent('view_item', {
            items: [
                {
                    name: 'legacyCard',
                    category: 'debitCard'
                }
            ]
        });
    }
    setDateRange(preset) {
        let startDate;
        let endDate;
        preset = preset || 'last30Days';
        switch (preset) {
            case 'last30Days':
                startDate = __WEBPACK_IMPORTED_MODULE_14_moment__()
                    .subtract(30, 'days')
                    .toISOString();
                endDate = __WEBPACK_IMPORTED_MODULE_14_moment__().toISOString();
                break;
            case 'lastMonth':
                startDate = __WEBPACK_IMPORTED_MODULE_14_moment__()
                    .startOf('month')
                    .subtract(1, 'month')
                    .toISOString();
                endDate = __WEBPACK_IMPORTED_MODULE_14_moment__()
                    .startOf('month')
                    .toISOString();
                break;
            case 'all':
                startDate = null;
                endDate = null;
                break;
            default:
                return undefined;
        }
        return {
            startDate,
            endDate
        };
    }
    setGetStarted(history, cb) {
        // Is the card new?
        if (!__WEBPACK_IMPORTED_MODULE_13_lodash__["isEmpty"](history.transactionList))
            return cb();
        let dateRange = this.setDateRange('all');
        this.bitPayCardProvider.updateHistory(this.cardId, dateRange, (err, history) => {
            if (!err && __WEBPACK_IMPORTED_MODULE_13_lodash__["isEmpty"](history.transactionList))
                this.getStarted = true;
            return cb();
        });
    }
    update() {
        let dateRange = this.setDateRange(this.dateRange.value);
        this.loadingHistory = true;
        this.bitPayCardProvider.updateHistory(this.cardId, dateRange, (err, history) => {
            this.loadingHistory = false;
            if (err) {
                this.logger.error(err);
                this.bitpayCardTransactionHistoryCompleted = null;
                this.bitpayCardTransactionHistoryConfirming = null;
                this.bitpayCardTransactionHistoryPreAuth = null;
                this.balance = null;
                this.popupProvider
                    .ionicAlert(err, this.translate.instant('Could not get transactions'))
                    .then(() => {
                    this.navCtrl.pop();
                });
                return;
            }
            this.setGetStarted(history, () => {
                let txs = __WEBPACK_IMPORTED_MODULE_13_lodash__["clone"](history.txs);
                this.setDateTime(txs);
                this.setHistory(txs);
                this.balance = history.currentCardBalance;
                this.updatedOn = null;
                if (this.dateRange.value == 'last30Days') {
                    // TODO?
                    // $log.debug('BitPay Card: storing cache history');
                    // let cacheHistory = {
                    //   balance: history.currentCardBalance,
                    //   transactions: history.txs
                    // };
                    // this.bitPayCardProvider.setHistory($scope.cardId, cacheHistory, {}, (err) => {
                    //   if (err) $log.error(err);
                    //   $scope.historyCached = true;
                    // });
                }
            });
        });
    }
    setHistory(txs) {
        if (!txs)
            return;
        this.bitpayCardTransactionHistoryConfirming = this.bitPayCardProvider.filterTransactions('confirming', txs);
        this.bitpayCardTransactionHistoryCompleted = this.bitPayCardProvider.filterTransactions('completed', txs);
        this.bitpayCardTransactionHistoryPreAuth = this.bitPayCardProvider.filterTransactions('preAuth', txs);
    }
    setDateTime(txs) {
        if (!txs)
            return;
        let txDate, txDateUtc;
        let newDate;
        for (let i = 0; i < txs.length; i++) {
            txDate = new Date(txs[i].date);
            if (txDate == 'Invalid Date')
                return; // iOS
            txDateUtc = new Date(txs[i].date.replace('Z', ''));
            let amTime = this.createdWithinPastDay(txs[i]);
            newDate = amTime
                ? __WEBPACK_IMPORTED_MODULE_14_moment__(txDateUtc).fromNow()
                : __WEBPACK_IMPORTED_MODULE_14_moment__(txDate)
                    .utc()
                    .format('MMM D, YYYY');
            txs[i].date = newDate;
        }
    }
    createdWithinPastDay(tx) {
        let result = false;
        if (tx.date) {
            result = this.timeProvider.withinPastDay(tx.date);
        }
        return result;
    }
    openExternalLink(url) {
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Help and support information is available at the website.');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    topUp() {
        this.logLegacyCardTopupStartEvent();
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__send_amount_amount__["a" /* AmountPage */], {
            id: this.cardId,
            nextPage: 'BitPayCardTopUpPage',
            currency: this.currency
        });
    }
    doRefresh(refresher) {
        this.update();
        setTimeout(() => {
            refresher.complete();
        }, TIMEOUT_FOR_REFRESHER);
    }
};
BitPayCardPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-bitpay-card',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/bitpay-card/bitpay-card.html"*/'<ion-header no-border>\n  <ion-navbar class="app-color">\n    <ion-title>\n      BitPay Visa <sup>&reg;</sup> Card ({{lastFourDigits}})\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce #scrollArea [fixed-scroll-bg-color]="\'#14245E\'">\n  <ion-refresher (ionRefresh)="doRefresh($event)" [ngStyle]="{\'background\': \'#14245E\'}" pullMin="90" pullMax="180">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="wrapper wrapper--feather">\n    <expandable-header class="balance-card" [scrollArea]="scrollArea">\n      <expandable-header-primary class="balance-header">\n        <div class="balance-str" *ngIf="balance">\n          {{balance | number:\'1.2-2\' }} {{currency}}\n        </div>\n        <button class="add-funds-button" ion-button color="light" clear (click)="topUp()" *ngIf="balance" no-low-fee>\n          <span translate>Add funds</span>\n          <ion-icon name="arrow-forward"></ion-icon>\n        </button>\n        <div class="card-info">\n          <ion-spinner *ngIf="!balance || loadingHistory"></ion-spinner>\n        </div>\n      </expandable-header-primary>\n    </expandable-header>\n\n  <div *ngIf="getStarted" class="initial-message">\n    <h1 translate>Get started</h1>\n    <div translate>\n      Your BitPay Card is ready. Add funds to your card to start using it at stores.\n    </div>\n  </div>\n\n  <ion-list *ngIf="!getStarted">\n    <ion-item-divider>\n      <ion-label>\n        <span translate>Activity</span>\n      </ion-label>\n      <ion-select okText="{{okText}}" cancelText="{{cancelText}}" padding-horizontal [(ngModel)]="dateRange.value" (ionChange)="update()">\n        <ion-option value="last30Days" selected translate>Recent</ion-option>\n        <ion-option value="lastMonth" translate>Last Month</ion-option>\n        <ion-option value="all" translate>All</ion-option>\n      </ion-select>\n    </ion-item-divider>\n\n    <ion-item-divider *ngIf="bitpayCardTransactionHistoryConfirming && bitpayCardTransactionHistoryConfirming[0]">\n      <ion-icon item-end (click)="openExternalLink(\'https://support.bitpay.com/hc/en-us/articles/115003014526-Why-do-you-require-one-blockchain-confirmation-for-BitPay-Card-loads-\')">\n        <img src="assets/img/icon-help-support.svg" />\n      </ion-icon>\n      <span translate>Confirming</span>\n    </ion-item-divider>\n    <ion-list>\n      <div *ngFor="let card of bitpayCardTransactionHistoryConfirming">\n        <page-card-item [card]="card" [currency]="currency"></page-card-item>\n      </div>\n    </ion-list>\n\n    <ion-item-divider *ngIf="bitpayCardTransactionHistoryPreAuth && bitpayCardTransactionHistoryPreAuth[0]">\n      <ion-icon item-end (click)="openExternalLink(\'https://support.bitpay.com/hc/en-us/articles/115003003563-Why-was-I-overcharged-on-my-BitPay-Card-account-Why-is-there-a-hold-on-my-account-\')">\n        <img src="assets/img/icon-help-support.svg" />\n      </ion-icon>\n      <span translate>Pre-Auth Holds</span>\n    </ion-item-divider>\n    <ion-list>\n      <div *ngFor="let card of bitpayCardTransactionHistoryPreAuth">\n        <page-card-item [card]="card" [currency]="currency"></page-card-item>\n      </div>\n    </ion-list>\n\n    <ion-item-divider *ngIf="(bitpayCardTransactionHistoryPreAuth && bitpayCardTransactionHistoryPreAuth[0]) || (bitpayCardTransactionHistoryConfirming && bitpayCardTransactionHistoryConfirming[0])">\n      <span translate>Completed</span>\n    </ion-item-divider>\n    <ion-list>\n      <div *ngFor="let card of bitpayCardTransactionHistoryCompleted">\n        <page-card-item [card]="card" [currency]="currency"></page-card-item>\n      </div>\n    </ion-list>\n  </ion-list>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/bitpay-card/bitpay-card.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers_bitpay_bitpay__["a" /* BitPayProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */]])
], BitPayCardPage);

//# sourceMappingURL=bitpay-card.js.map

/***/ }),

/***/ 328:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CardDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations__ = __webpack_require__(256);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_social_sharing__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_operators__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_operators___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_operators__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_gift_card_gift_card__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_gift_card_gift_card_types__ = __webpack_require__(1985);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__printable_card_printable_card__ = __webpack_require__(989);












let CardDetailsPage = class CardDetailsPage {
    constructor(actionSheetProvider, externalLinkProvider, giftCardProvider, nav, navParams, events, socialSharing, platformProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.giftCardProvider = giftCardProvider;
        this.nav = nav;
        this.navParams = navParams;
        this.events = events;
        this.socialSharing = socialSharing;
        this.platformProvider = platformProvider;
        this.ClaimCodeType = __WEBPACK_IMPORTED_MODULE_9__providers_gift_card_gift_card_types__["a" /* ClaimCodeType */];
        this.bwsEventHandler = (_, type) => {
            if (type == 'NewBlock') {
                this.updateGiftCard();
            }
        };
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.card = this.navParams.get('card');
            this.barcodeData = this.card.barcodeData || this.card.claimCode;
            this.barcodeFormat = getBarcodeFormat(this.card.barcodeFormat);
            this.cardConfig = yield this.giftCardProvider.getCardConfig(this.card.name);
            this.updateGiftCard();
        });
    }
    ionViewWillEnter() {
        this.events.subscribe('bwsEvent', this.bwsEventHandler);
    }
    ionViewWillLeave() {
        this.events.unsubscribe('bwsEvent', this.bwsEventHandler);
    }
    updateGiftCard() {
        this.giftCardProvider
            .updatePendingGiftCards([this.card], this.cardConfig.defaultClaimCodeType === __WEBPACK_IMPORTED_MODULE_9__providers_gift_card_gift_card_types__["a" /* ClaimCodeType */].barcode &&
            !this.card.barcodeImage)
            .pipe(Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_operators__["take"])(1))
            .subscribe(card => (this.card = card));
    }
    doRefresh(refresher) {
        this.updateGiftCard();
        setTimeout(() => {
            refresher.complete();
        }, 2000);
    }
    copyCode(code) {
        this.actionSheetProvider
            .createInfoSheet('copied-gift-card-claim-code', {
            cardConfig: this.cardConfig,
            claimCode: code
        })
            .present();
    }
    showClaimLinkUI() {
        return (this.cardConfig &&
            this.card &&
            (this.cardConfig.defaultClaimCodeType === 'link' ||
                !this.card.claimCode) &&
            this.card.status === 'SUCCESS');
    }
    showBarcode() {
        return (this.cardConfig &&
            this.cardConfig.defaultClaimCodeType === __WEBPACK_IMPORTED_MODULE_9__providers_gift_card_gift_card_types__["a" /* ClaimCodeType */].barcode);
    }
    archive() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.giftCardProvider.archiveCard(this.card);
            this.nav.pop();
        });
    }
    unarchive() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.giftCardProvider.unarchiveCard(this.card);
        });
    }
    logRedeemCardEvent(isManuallyClaimed) {
        if (!isManuallyClaimed) {
            this.giftCardProvider.logEvent('giftcards_redeem', {
                brand: this.cardConfig.name,
                usdAmount: this.card.amount
            });
        }
        else {
            this.giftCardProvider.logEvent('giftcards_mark_used', {
                brand: this.cardConfig.name,
                usdAmount: this.card.amount
            });
        }
    }
    hasPin() {
        const legacyCards = [
            'Amazon.com',
            'Amazon.co.jp',
            'Mercado Livre'
        ];
        const shouldHidePin = this.cardConfig && this.cardConfig.hidePin;
        const pin = this.card && this.card.pin;
        return !shouldHidePin && pin && legacyCards.indexOf(this.card.name) === -1
            ? true
            : false;
    }
    openArchiveSheet() {
        this.showInfoSheet('archive-gift-card', () => this.archive());
    }
    showInfoSheet(sheetName, onDidDismiss = () => { }) {
        const sheet = this.actionSheetProvider.createInfoSheet(sheetName);
        sheet.present();
        sheet.onDidDismiss(confirm => {
            if (confirm) {
                const isManuallyClaimed = true;
                this.logRedeemCardEvent(isManuallyClaimed);
                onDidDismiss(confirm);
            }
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    redeem() {
        const redeemUrl = `${this.cardConfig.redeemUrl}${this.card.claimCode}`;
        this.cardConfig.redeemUrl
            ? this.redeemWithUrl(redeemUrl)
            : this.claimManually();
    }
    claimManually() {
        this.cardConfig.printRequired
            ? this.print()
            : this.copyCode(this.card.claimCode);
    }
    redeemWithUrl(redeemUrl) {
        const isManuallyClaimed = false;
        this.logRedeemCardEvent(isManuallyClaimed);
        this.externalLinkProvider.open(redeemUrl);
    }
    print() {
        this.platformProvider.isCordova ? this.printCordova() : window.print();
    }
    printCordova() {
        const image = this.printableCard.getPrintableImage();
        this.platformProvider.isAndroid
            ? this.openExternalLink(this.card.claimLink)
            : this.socialSharing.share(null, 'gift-card', image);
    }
    viewRedemptionCode() {
        this.externalLinkProvider.open(this.card.claimLink);
    }
    showInvoice() {
        this.externalLinkProvider.open(this.card.invoiceUrl);
    }
    shareCode() {
        this.socialSharing.share(this.card.claimLink || this.card.claimCode);
    }
    showMoreOptions() {
        const showShare = this.platformProvider.isCordova &&
            (this.card.claimLink || this.card.claimCode);
        const hidePrint = !this.card.claimLink && this.platformProvider.isAndroid;
        const sheet = this.actionSheetProvider.createOptionsSheet('gift-card-options', {
            card: this.card,
            hidePrint,
            showShare
        });
        sheet.present();
        sheet.onDidDismiss(data => {
            switch (data) {
                case 'archive':
                    return this.openArchiveSheet();
                case 'unarchive':
                    return this.unarchive();
                case 'view-invoice':
                    return this.showInvoice();
                case 'share-code':
                    return this.shareCode();
                case 'print-card':
                    return setTimeout(() => this.print(), 200);
            }
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_11__printable_card_printable_card__["a" /* PrintableCardComponent */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_11__printable_card_printable_card__["a" /* PrintableCardComponent */])
], CardDetailsPage.prototype, "printableCard", void 0);
CardDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Component"])({
        selector: 'card-details-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/card-details/card-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{cardConfig?.displayName}}</ion-title>\n    <ion-buttons right>\n      <button (click)="showMoreOptions()" ion-button icon-only>\n        <ion-icon class="horizontal-lg" name="more"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content class="gift-card-content">\n  <ion-refresher (ionRefresh)="doRefresh($event)" pullMin="90" pullMax="180">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="wrapper">\n    <div class="header-extension"></div>\n    <div class="main-content">\n      <div class="balance">{{card.amount | formatCurrency:card.currency}}</div>\n      <img-loader class="card-image" src="{{cardConfig?.cardImage}}"></img-loader>\n      <div class="card-info" [ngClass]="{\'has-pin\': hasPin()}" *ngIf="!showClaimLinkUI()">\n        <div *ngIf="card.claimCode">\n          <div *ngIf="card.status !== \'Canceled\'">\n            <div (click)="copyCode(card.claimCode)" [copy-to-clipboard]="card.claimCode" [hide-toast]="true" tappable>\n              <div class="card-info__title">Claim Code</div>\n              <div class="card-info__body" *ngIf="!showBarcode()">\n                {{card.claimCode}}\n              </div>\n              <ng-container *ngIf="showBarcode()">\n                <ngx-barcode *ngIf="!card.barcodeImage && barcodeFormat !== \'QR\'" class="card-info__body"\n                  [bc-value]="barcodeData" [bc-format]="barcodeFormat" bc-display-value="false" bc-element-type="canvas"\n                  bc-height="70" [bc-width]="1.8" bc-background="#f7f7f7" bc-font="Roboto" bc-text-margin="8"\n                  bc-text-position="bottom" bc-font-size="20"></ngx-barcode>\n                <ngx-qrcode *ngIf="!card.barcodeImage && barcodeFormat === \'QR\'" hide-toast="true"\n                  [qrc-value]="barcodeData" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n                <img *ngIf="card.barcodeImage" [src]="card.barcodeImage" class="card-info__body barcode-image">\n              </ng-container>\n              <div class="card-info__body" [ngClass]="{long: card.claimCode.length > 20 }" *ngIf="showBarcode()">\n                {{card.claimCode}}\n              </div>\n              <div class="card-info__date" *ngIf="!hasPin()">Created {{card.date | amTimeAgo}}</div>\n            </div>\n            <div *ngIf="hasPin()">\n              <div class="separator"></div>\n              <div (click)="copyCode(card.pin)" [copy-to-clipboard]="card.pin" [hide-toast]="true" tappable>\n                <div class="card-info__title">Pin</div>\n                <div class="card-info__body pin">\n                  {{card.pin}}\n                </div>\n              </div>\n            </div>\n          </div>\n          <div *ngIf="card.status == \'Canceled\'" class="card-info__body" translate>\n            Gift card canceled\n          </div>\n        </div>\n\n        <div *ngIf="!card.claimCode" class="card-info__status-message">\n          <div *ngIf="card.status === \'PENDING\' || card.status === \'invalid\' || card.status === \'expired\'"\n            class="card-info__body" translate>\n            Awaiting payment to confirm\n          </div>\n          <div *ngIf="card.status == \'FAILURE\' || card.status == \'RESEND\'" class="card-info__body" translate>\n            Could not get claim code. Please contact BitPay support.\n          </div>\n        </div>\n      </div>\n\n      <div class="card-info__date card-info__date--outside-card-info" *ngIf="hasPin() || showClaimLinkUI()">Created\n        {{card.date |\n        amTimeAgo}}</div>\n\n      <div class="actions-wrapper" [@preventInitialChildAnimations]>\n        <div class="actions" *ngIf="card.status !== \'PENDING\' && !card.archived && (card.claimCode || card.claimLink)"\n          [@enterAnimation]>\n          <button ion-button *ngIf="!showClaimLinkUI() && cardConfig?.redeemUrl" class="button-standard"\n            (click)="redeem()">\n            {{\'Redeem Now\' | translate}}\n          </button>\n          <button ion-button *ngIf="!showClaimLinkUI() && !cardConfig?.redeemUrl && cardConfig" class="button-standard"\n            (click)="redeem()" [copy-to-clipboard]="card.claimCode" [hide-toast]="true">\n            <ng-container *ngIf="!cardConfig.printRequired">{{\'Copy Code\' | translate}}</ng-container>\n            <ng-container *ngIf="cardConfig.printRequired">{{\'Print\' | translate}}</ng-container>\n          </button>\n          <button ion-button *ngIf="showClaimLinkUI()" class="button-standard" (click)="viewRedemptionCode()">\n            {{ cardConfig.redeemButtonText || \'View Redemption Code\' | translate}}\n          </button>\n          <button ion-button class="button-standard button-secondary" (click)="openArchiveSheet()">\n            {{"I\'ve used this card" | translate}}\n          </button>\n        </div>\n      </div>\n    </div>\n    <card-terms [cardName]="card.name"></card-terms>\n\n  </div>\n</ion-content>\n\n<printable-card *ngIf="cardConfig" [card]="card" [cardConfig]="cardConfig"></printable-card>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/card-details/card-details.html"*/,
        animations: [
            Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* trigger */])('enterAnimation', [
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["i" /* transition */])(':enter', [
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["h" /* style */])({ opacity: 0 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["e" /* animate */])('400ms 250ms ease', Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["h" /* style */])({ opacity: 1 }))
                ]),
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["i" /* transition */])(':leave', [
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["h" /* style */])({ opacity: 1 }),
                    Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["e" /* animate */])('400ms 250ms ease', Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["h" /* style */])({ opacity: 0 }))
                ])
            ]),
            Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["j" /* trigger */])('preventInitialChildAnimations', [
                Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["i" /* transition */])(':enter', [Object(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["f" /* query */])(':enter', [], { optional: true })])
            ])
        ]
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_gift_card_gift_card__["a" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */]])
], CardDetailsPage);

function getBarcodeFormat(barcodeFormat = '') {
    const lowercaseFormats = ['pharmacode', 'codabar'];
    const supportedFormats = [
        'CODE128',
        'CODE128A',
        'CODE128B',
        'CODE128C',
        'EAN',
        'UPC',
        'EAN8',
        'EAN5',
        'EAN2',
        'CODE39',
        'ITF14',
        'MSI',
        'MSI10',
        'MSI11',
        'MSI1010',
        'MSI1110',
        'QR',
        ...lowercaseFormats
    ];
    const normalizedFormat = lowercaseFormats.includes(barcodeFormat.toLowerCase())
        ? barcodeFormat.toLowerCase()
        : barcodeFormat.replace(/\s/g, '').toUpperCase();
    return supportedFormats.includes(normalizedFormat)
        ? normalizedFormat
        : 'CODE128';
}
//# sourceMappingURL=card-details.js.map

/***/ }),

/***/ 329:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return PurchasedCardsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__buy_card_buy_card__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__card_details_card_details__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__card_list_item_card_list_item__ = __webpack_require__(1986);









let PurchasedCardsPage = class PurchasedCardsPage {
    constructor(actionSheetProvider, giftCardProvider, logger, navCtrl, navParams) {
        this.actionSheetProvider = actionSheetProvider;
        this.giftCardProvider = giftCardProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const cardName = this.navParams.get('cardName');
            this.cardConfig = yield this.giftCardProvider.getCardConfig(cardName);
            yield this.getCards();
            this.listenForUpdates();
        });
    }
    ionViewDidLoad() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.logger.info('Loaded: PurchasedCardsPage');
        });
    }
    listenForUpdates() {
        this.giftCardProvider.cardUpdates$.subscribe(card => this.updateCard(card));
    }
    updateCard(card) {
        this.allGiftCards = this.allGiftCards.map(oldCard => oldCard.invoiceId === card.invoiceId ? card : oldCard);
        this.setGiftCards(this.allGiftCards);
    }
    addCard() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__buy_card_buy_card__["a" /* BuyCardPage */], { cardConfig: this.cardConfig });
        });
    }
    archive() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const archiveSheet = this.actionSheetProvider.createInfoSheet('archive-all-gift-cards', { brand: this.cardConfig.displayName });
            archiveSheet.present();
            archiveSheet.onDidDismiss((confirm) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
                if (!confirm)
                    return;
                yield this.navCtrl.pop();
                this.giftCardProvider.archiveAllCards(this.cardConfig.name);
            }));
        });
    }
    getCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.giftCardProvider
                .getPurchasedCards(this.cardConfig.name)
                .then(cards => this.setGiftCards(cards))
                .catch(err => this.logger.error(err));
            this.giftCardProvider.updatePendingGiftCards(this.currentGiftCards);
        });
    }
    setGiftCards(allCards) {
        this.allGiftCards = allCards;
        this.currentGiftCards = allCards.filter(gc => !gc.archived);
        this.archivedGiftCards = allCards.filter(gc => gc.archived);
    }
    goToCardDetails(card) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__card_details_card_details__["a" /* CardDetailsPage */], { card });
            this.currentGiftCards.length === 1 && this.removePageFromHistory();
        });
    }
    removePageFromHistory() {
        const startIndex = this.navCtrl.getActive().index - 1;
        this.navCtrl.remove(startIndex, 1);
    }
};
PurchasedCardsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'purchased-cards-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/purchased-cards/purchased-cards.html"*/'<wide-header-page title="{{cardConfig?.displayName}}">\n  <ion-buttons right>\n    <button clear wide-header-bar-button (click)="archive()" ion-button>\n      Archive\n    </button>\n  </ion-buttons>\n  <div page-content>\n    <ion-list class="bp-list">\n      <ion-item-divider *ngIf="currentGiftCards && currentGiftCards.length">{{\'Current Cards\' | translate}}\n        <button clear item-right ion-button class="settings-list bp-list__divider-button" (click)="addCard()">\n          <ion-icon ios="md-add" md="md-add"></ion-icon>\n        </button>\n      </ion-item-divider>\n      <card-list-item *ngFor="let card of currentGiftCards" [card]="card" (click)="goToCardDetails(card)"\n        type="purchased"></card-list-item>\n      <ion-item-divider></ion-item-divider>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/purchased-cards/purchased-cards.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__["a" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */]])
], PurchasedCardsPage);

const PURCHASED_CARDS_PAGE_COMPONENTS = [
    PurchasedCardsPage,
    __WEBPACK_IMPORTED_MODULE_8__card_list_item_card_list_item__["a" /* CardListItemComponent */]
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PURCHASED_CARDS_PAGE_COMPONENTS;

//# sourceMappingURL=purchased-cards.js.map

/***/ }),

/***/ 330:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BuyCardPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__send_amount_amount__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__confirm_card_purchase_confirm_card_purchase__ = __webpack_require__(468);







let BuyCardPage = class BuyCardPage {
    constructor(actionSheetProvider, nav, navParams, zone) {
        this.actionSheetProvider = actionSheetProvider;
        this.nav = nav;
        this.navParams = navParams;
        this.zone = zone;
        this.printAlertShown = false;
        this.hasPercentageDiscount = false;
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.cardConfig = this.navParams.get('cardConfig');
            this.hasPercentageDiscount = Object(__WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__["e" /* hasVisibleDiscount */])(this.cardConfig);
        });
    }
    ionViewWillEnter() {
        if (this.cardConfig.printRequired && !this.printAlertShown) {
            this.printAlertShown = true;
            this.actionSheetProvider
                .createInfoSheet('print-required', {
                displayName: this.cardConfig.displayName
            })
                .present();
        }
    }
    cancel() {
        this.nav.pop();
    }
    enterAmount() {
        this.nav.push(__WEBPACK_IMPORTED_MODULE_5__send_amount_amount__["a" /* AmountPage */], {
            nextPage: 'ConfirmCardPurchasePage',
            cardName: this.cardConfig.name,
            currency: this.cardConfig.currency,
            fixedUnit: true,
            onlyIntegers: this.cardConfig.currency === 'JPY'
        });
    }
    onAmountChange(amount) {
        this.zone.run(() => (this.amount = amount));
    }
    onAmountClick() {
        if (this.cardConfig.supportedAmounts) {
            return;
        }
        this.enterAmount();
    }
    continue() {
        const data = {
            amount: this.amount,
            currency: this.cardConfig.currency,
            cardName: this.cardConfig.name
        };
        this.nav.push(__WEBPACK_IMPORTED_MODULE_6__confirm_card_purchase_confirm_card_purchase__["a" /* ConfirmCardPurchasePage */], data);
    }
    checkForActivationFee() {
        const activationFee = Object(__WEBPACK_IMPORTED_MODULE_4__providers_gift_card_gift_card__["b" /* getActivationFee */])(this.amount, this.cardConfig);
        return activationFee > 0
            ? this.showActivationFeeSheet(activationFee)
            : this.continue();
    }
    showActivationFeeSheet(fee) {
        const sheet = this.actionSheetProvider.createInfoSheet('activation-fee-included', {
            currency: this.cardConfig.currency,
            displayName: this.cardConfig.displayName,
            fee
        });
        this.zone.run(() => sheet.present());
        sheet.onDidDismiss(ok => ok && this.continue());
    }
    next() {
        this.cardConfig && this.cardConfig.supportedAmounts
            ? this.checkForActivationFee()
            : this.enterAmount();
    }
};
BuyCardPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'buy-card-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/buy-card/buy-card.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Buy {{cardConfig?.displayName}} Gift Card</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content class="gift-card-content">\n  <div class="wrapper">\n    <div class="amount-box">\n      <div>\n        <img-loader class="card-image" src="{{cardConfig?.cardImage}}">\n          <div class="discount" *ngIf="hasPercentageDiscount">\n            Save <gift-card-discount-text [cardConfig]="cardConfig" [discount]="cardConfig.discounts[0]">\n            </gift-card-discount-text>\n          </div>\n        </img-loader>\n      </div>\n      <amount-picker *ngIf="cardConfig" [currency]="cardConfig.currency"\n        [supportedAmounts]="cardConfig.supportedAmounts" (amountChange)="onAmountChange($event)"\n        (click)="onAmountClick()"></amount-picker>\n    </div>\n    <div class="buy-box">\n      <card-description class="buy-box__terms" [cardConfig]="cardConfig"></card-description>\n    </div>\n  </div>\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar>\n    <button ion-button full class="button-footer" (click)="next()">\n      <ng-container *ngIf="cardConfig?.supportedAmounts">{{\'Continue\' | translate}}</ng-container>\n      <ng-container *ngIf="!cardConfig?.supportedAmounts">{{\'Enter Amount\' | translate}}</ng-container>\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/buy-card/buy-card.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]])
], BuyCardPage);

//# sourceMappingURL=buy-card.js.map

/***/ }),

/***/ 331:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__shapeshift_details_shapeshift_details__ = __webpack_require__(992);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__shapeshift_shift_shapeshift_shift__ = __webpack_require__(993);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_shapeshift_shapeshift__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_time_time__ = __webpack_require__(148);







// Pages


// Providers







let ShapeshiftPage = class ShapeshiftPage {
    constructor(events, externalLinkProvider, logger, modalCtrl, navCtrl, shapeshiftProvider, timeProvider, navParams, formBuilder, onGoingProcessProvider, translate, popupProvider, platformProvider, statusBar) {
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.shapeshiftProvider = shapeshiftProvider;
        this.timeProvider = timeProvider;
        this.navParams = navParams;
        this.formBuilder = formBuilder;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.translate = translate;
        this.popupProvider = popupProvider;
        this.platformProvider = platformProvider;
        this.statusBar = statusBar;
        this.bwsEventHandler = (_, type) => {
            if (type == 'NewBlock')
                this.updateShift(this.shifts);
        };
        this.updateShift = __WEBPACK_IMPORTED_MODULE_5_lodash__["debounce"](shifts => {
            if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](shifts.data))
                return;
            __WEBPACK_IMPORTED_MODULE_5_lodash__["forEach"](shifts.data, dataFromStorage => {
                if (!this.checkIfShiftNeedsUpdate(dataFromStorage))
                    return;
                this.shapeshiftProvider.getStatus(dataFromStorage.address, this.accessToken, (err, st) => {
                    if (err)
                        return;
                    this.shifts.data[st.address].status = st.status;
                    this.shifts.data[st.address].transaction = st.transaction || null;
                    this.shifts.data[st.address].incomingCoin = st.incomingCoin || null;
                    this.shifts.data[st.address].incomingType = st.incomingType || null;
                    this.shifts.data[st.address].outgoingCoin = st.outgoingCoin || null;
                    this.shifts.data[st.address].outgoingType = st.outgoingType || null;
                    this.shapeshiftProvider.saveShapeshift(this.shifts.data[st.address], null, () => {
                        this.logger.debug('Saved shift with status: ' + st.status);
                    });
                });
            });
        }, 1000, {
            leading: true
        });
        this.oauthCodeForm = this.formBuilder.group({
            code: [
                '',
                __WEBPACK_IMPORTED_MODULE_9__angular_forms__["f" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_9__angular_forms__["f" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_9__angular_forms__["f" /* Validators */].required])
            ]
        });
        this.showOauthForm = false;
        this.network = this.shapeshiftProvider.getNetwork();
        this.shifts = { data: {} };
        this.headerColor = '#0d172c';
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ShapeshiftPage');
    }
    ionViewWillEnter() {
        if (this.platformProvider.isCordova) {
            this.statusBar.styleBlackOpaque();
        }
        if (this.navParams.data.code) {
            this.shapeshiftProvider.getStoredToken((at) => {
                at ? this.init() : this.submitOauthCode(this.navParams.data.code);
            });
        }
        else {
            this.init();
        }
        this.events.subscribe('bwsEvent', this.bwsEventHandler);
    }
    ionViewWillLeave() {
        if (this.platformProvider.isCordova) {
            this.statusBar.styleDefault();
        }
        this.events.unsubscribe('bwsEvent', this.bwsEventHandler);
    }
    init() {
        this.loading = true;
        this.shapeshiftProvider.getStoredToken((at) => {
            this.accessToken = at;
            // Update Access Token if necessary
            this.shapeshiftProvider.init((err, data) => {
                if (err || __WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](data)) {
                    this.loading = false;
                    if (err) {
                        this.logger.error(err);
                        this.loading = false;
                        if (err == 'unverified_account') {
                            this.openShafeShiftWindow();
                        }
                        else {
                            this.popupProvider
                                .ionicAlert(this.translate.instant('Error connecting to ShapeShift'), err)
                                .then(() => {
                                this.shapeshiftProvider.logout(this.accessToken);
                                this.navCtrl.popToRoot();
                            });
                        }
                    }
                    return;
                }
                this.shapeshiftProvider.getShapeshift((err, ss) => {
                    this.loading = false;
                    if (err)
                        this.logger.error(err);
                    if (ss)
                        this.shifts = { data: ss };
                    this.updateShift(this.shifts);
                });
            });
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    checkIfShiftNeedsUpdate(shiftData) {
        // Continues normal flow (update shiftData)
        if (shiftData.status == 'received') {
            return true;
        }
        // Check if shiftData status FAILURE for 24 hours
        if ((shiftData.status == 'failed' || shiftData.status == 'no_deposits') &&
            this.timeProvider.withinPastDay(shiftData.date)) {
            return true;
        }
        // If status is complete: do not update
        // If status fails or do not receive deposits for more than 24 hours: do not update
        return false;
    }
    update() {
        this.updateShift(this.shifts);
    }
    openShiftModal(ssData) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_7__shapeshift_details_shapeshift_details__["a" /* ShapeshiftDetailsPage */], { ssData });
        modal.present();
        modal.onDidDismiss(() => {
            this.init();
        });
    }
    goTo(page) {
        switch (page) {
            case 'Shift':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__shapeshift_shift_shapeshift_shift__["a" /* ShapeshiftShiftPage */]);
                break;
        }
    }
    openAuthenticateWindow() {
        this.showOauthForm = true;
        const oauthUrl = this.shapeshiftProvider.getOauthCodeUrl();
        this.externalLinkProvider.open(oauthUrl);
    }
    openShafeShiftWindow() {
        const url = 'https://portal.shapeshift.io/me/fox/dashboard';
        const optIn = true;
        const title = this.translate.instant('Unverified Account');
        const message = this.translate.instant('Do you want to verify your account now?');
        const okText = this.translate.instant('Verify Account');
        const cancelText = this.translate.instant('Cancel');
        this.externalLinkProvider
            .open(url, optIn, title, message, okText, cancelText)
            .then(() => {
            this.navCtrl.popToRoot();
        });
    }
    openSignupWindow() {
        const url = this.shapeshiftProvider.getSignupUrl();
        const optIn = true;
        const title = 'Sign Up for ShapeShift';
        const message = 'This will open shapeshift.io, where you can create an account.';
        const okText = 'Go to ShapeShift';
        const cancelText = 'Back';
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    submitOauthCode(code) {
        this.onGoingProcessProvider.set('connectingShapeshift');
        this.shapeshiftProvider.getToken(code, (err, accessToken) => {
            this.onGoingProcessProvider.clear();
            if (err) {
                this.error = err;
                this.logger.error('Error connecting to ShapeShift: ' + err);
                return;
            }
            this.navCtrl.pop();
            this.accessToken = accessToken;
            this.init();
        });
    }
};
ShapeshiftPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-shapeshift',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/shapeshift/shapeshift.html"*/'<ion-header class="wide-header">\n  <ion-navbar [navbar-bg]="headerColor">\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        <img width="140" src="assets/img/shapeshift/logo-white-shapeshift.svg" alt="ShapeShift">\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea [fixed-scroll-bg-color]="headerColor" [ion-content-background-color]="headerColor">\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar [navbar-bg]="headerColor" class="wide-header__title">\n        <expandable-header-primary>\n          <img margin-left width="155" src="assets/img/shapeshift/logo-white-shapeshift.svg" alt="ShapeShift">\n          \n        </expandable-header-primary>\n        <ion-buttons end>\n          <button class="shift-button" *ngIf="accessToken" clear no-low-fee (click)="goTo(\'Shift\')" [disabled]="disabled">\n            Shift\n            <ion-icon name="arrow-forward"></ion-icon>\n          </button>\n        </ion-buttons>\n      </ion-toolbar>\n    </expandable-header>\n  \n    <div class="container" *ngIf="!accessToken">\n      <div class="center-header">\n        <div>\n          <h4 translate>The Safest, Fastest Asset Exchange on Earth</h4>\n          <p translate>Trade any leading blockchain asset for any other. Protection by Design.</p>\n        </div>\n\n        <button *ngIf="!showOauthForm" ion-button outline class="button-standard" no-low-fee (click)="openAuthenticateWindow()">\n          {{\'Connect to ShapeShift Account\' | translate}}\n        </button>\n        <button *ngIf="!showOauthForm" ion-button clear small color="grey" (click)="openSignupWindow()">\n          {{\'Sign Up for ShapeShift\' | translate}} &rarr;\n        </button>\n        <button ion-button clear small color="grey" (click)="openExternalLink(\'https://shapeshift.io\')">\n          {{\'Visit ShapeShift.io\' | translate}} &rarr;\n        </button>\n        <div *ngIf="error">\n          <span ion-text color="danger">{{error}}</span>\n        </div>\n        <form *ngIf="showOauthForm" class="form-container" [formGroup]="oauthCodeForm" (ngSubmit)="submitOauthCode(oauthCodeForm.value.code)">\n          <ion-label stacked>OAuth Code</ion-label>\n          <ion-input type="text" formControlName="code" [value]="oauthCodeForm.value.code" placeholder="{{\'Enter OAuth Code\'}}" required></ion-input>\n          <button ion-button outline type="submit" class="button-standard" [disabled]="!oauthCodeForm.valid">{{\'Connect to ShapeShift Account\' | translate}}</button>\n        </form>\n\n        <button ion-button clear small color="light-grey" class="bottom-position" (click)="openExternalLink(\'https://info.shapeshift.io/blog/2018/09/04/introducing-shapeshift-membership/\')">\n          {{\'Why does this require authentication?\' | translate}} &rarr;\n        </button>\n      </div>\n    </div>\n\n    <div class="container" *ngIf="accessToken">\n      <div *ngIf="disabled" padding-horizontal ion-text color="danger">\n        Shapeshift is temporally disabled for this device. You can try it on our Desktop versions.\n      </div>\n\n      <ion-list>\n        <ion-item-divider>{{\'Transactions\' | translate}}\n          <ion-spinner item-end name="crescent" *ngIf="loading"></ion-spinner>\n        </ion-item-divider>\n        <button ion-item *ngFor="let item of (shifts.data | keys : \'date\') | orderBy : [\'-order\']" (click)="openShiftModal(item.value)">\n          <ion-label>\n            <div class="ellipsis">{{item.value.title || item.value.address}}</div>\n            <div class="status">\n              <span class="assertive" *ngIf="item.value.status == \'failed\'" translate>Failed</span>\n              <span class="balanced" *ngIf="item.value.status == \'complete\'" translate>Completed</span>\n              <span class="royal" *ngIf="item.value.status == \'received\'" translate>Pending</span>\n              <span class="calm" *ngIf="item.value.status == \'no_deposits\'" translate>Pending</span>\n            </div>\n          </ion-label>\n          <div item-content text-end>\n            <div class="text-bold">{{ item.value.amount }}</div>\n            <div class="date calm">{{item.value.date | amTimeAgo}}</div>\n          </div>\n        </button>\n      </ion-list>\n    </div>\n  </div>\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar *ngIf="shifts.data">\n    <div class="shift-problems">\n      <span translate>Having problems with a ShapeShift?</span>\n      <br>\n      <a (click)="openExternalLink(\'https://shapeshift.zendesk.com/hc/en-us/requests/new\')" translate>\n        Contact the ShapeShift support team.\n      </a>\n    </div>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/shapeshift/shapeshift.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_14__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_13__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */]])
], ShapeshiftPage);

//# sourceMappingURL=shapeshift.js.map

/***/ }),

/***/ 332:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PinModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_vibration__ = __webpack_require__(853);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_animate_animate__ = __webpack_require__(469);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__ = __webpack_require__(12);










let PinModalPage = class PinModalPage {
    constructor(configProvider, logger, platform, navParams, persistenceProvider, statusBar, vibration, viewCtrl, platformProvider) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.platform = platform;
        this.navParams = navParams;
        this.persistenceProvider = persistenceProvider;
        this.statusBar = statusBar;
        this.vibration = vibration;
        this.viewCtrl = viewCtrl;
        this.platformProvider = platformProvider;
        this.ATTEMPT_LIMIT = 3;
        this.ATTEMPT_LOCK_OUT_TIME = 2 * 60;
        this.currentAttempts = 0;
        this.currentPin = '';
        this.firstPinEntered = '';
        this.confirmingPin = false;
        this.action = '';
        this.disableButtons = false;
        this.expires = '';
        this.incorrect = false;
        this.unregister = this.platform.registerBackButtonAction(() => { });
        this.action = this.navParams.get('action');
        if (this.action === 'checkPin' || this.action === 'lockSetUp') {
            this.checkIfLocked();
        }
    }
    ionViewWillEnter() {
        if (this.platformProvider.isIOS) {
            this.statusBar.styleDefault();
        }
    }
    ionViewWillLeave() {
        if (this.platformProvider.isIOS) {
            this.statusBar.styleLightContent();
        }
    }
    ionViewDidLoad() {
        this.onPauseSubscription = this.platform.pause.subscribe(() => {
            this.lockReleaseTimeout.unref();
            this.countDown.unref();
            this.currentPin = this.firstPinEntered = '';
        });
        this.onResumeSubscription = this.platform.resume.subscribe(() => {
            this.disableButtons = true;
            setTimeout(() => {
                this.checkIfLocked();
            }, 1000);
        });
    }
    ngOnDestroy() {
        this.onPauseSubscription.unsubscribe();
        this.onResumeSubscription.unsubscribe();
    }
    checkIfLocked() {
        this.persistenceProvider.getLockStatus().then((isLocked) => {
            if (!isLocked) {
                this.disableButtons = null;
                return;
            }
            if (this.action === 'checkPin') {
                this.showLockTimer();
                this.setLockRelease();
            }
        });
    }
    close(cancelClicked) {
        if (this.countDown) {
            clearInterval(this.countDown);
        }
        this.unregister();
        this.viewCtrl.dismiss(cancelClicked);
    }
    newEntry(value) {
        if (this.disableButtons)
            return;
        if (value === 'delete') {
            return this.delete();
        }
        this.incorrect = false;
        this.currentPin = this.currentPin + value;
        if (!this.isComplete())
            return;
        if (this.action === 'checkPin' || this.action === 'lockSetUp') {
            setTimeout(() => {
                this.checkIfCorrect();
            }, 100);
        }
        if (this.action === 'pinSetUp') {
            setTimeout(() => {
                if (!this.confirmingPin) {
                    this.confirmingPin = true;
                    this.firstPinEntered = this.currentPin;
                    this.currentPin = '';
                }
                else if (this.firstPinEntered === this.currentPin)
                    this.save();
                else {
                    this.firstPinEntered = this.currentPin = '';
                    this.incorrect = true;
                    this.confirmingPin = false;
                    this.shakeCode();
                }
            }, 100);
        }
    }
    checkAttempts() {
        this.currentAttempts += 1;
        this.logger.info('Attempts to unlock:', this.currentAttempts);
        this.incorrect = true;
        if (this.currentAttempts == this.ATTEMPT_LIMIT &&
            this.action !== 'lockSetUp') {
            this.countDown = this.lockReleaseTimeout = null;
            this.currentAttempts = 0;
            this.persistenceProvider.setLockStatus('locked');
            this.showLockTimer();
            this.setLockRelease();
        }
        else {
            this.disableButtons = null;
        }
    }
    showLockTimer() {
        this.disableButtons = true;
        if (this.countDown) {
            this.countDown.ref();
            return;
        }
        const bannedUntil = Math.floor(Date.now() / 1000) + this.ATTEMPT_LOCK_OUT_TIME;
        this.countDown = setInterval(() => {
            const now = Math.floor(Date.now() / 1000);
            const totalSecs = bannedUntil - now;
            const m = Math.floor(totalSecs / 60);
            const s = totalSecs % 60;
            this.expires = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
        }, 1000);
    }
    setLockRelease() {
        if (this.lockReleaseTimeout) {
            this.lockReleaseTimeout.ref();
            return;
        }
        this.lockReleaseTimeout = setTimeout(() => {
            clearInterval(this.countDown);
            this.expires = this.disableButtons = null;
            this.currentPin = this.firstPinEntered = '';
            this.persistenceProvider.removeLockStatus();
        }, this.ATTEMPT_LOCK_OUT_TIME * 1000);
    }
    delete() {
        if (this.disableButtons)
            return;
        this.currentPin = this.currentPin.substring(0, this.currentPin.length - 1);
    }
    isComplete() {
        if (this.currentPin.length < 4)
            return false;
        if (this.action != 'pinSetUp')
            this.disableButtons = true;
        return true;
    }
    save() {
        const lock = { method: 'pin', value: this.currentPin, bannedUntil: null };
        this.configProvider.set({ lock });
        this.close();
    }
    checkIfCorrect() {
        const config = this.configProvider.get();
        const pinValue = config.lock && config.lock.value;
        if (pinValue == this.currentPin) {
            if (this.action === 'checkPin' || this.action === 'lockSetUp') {
                this.close();
            }
        }
        else {
            this.currentPin = '';
            this.checkAttempts();
            this.shakeCode();
        }
    }
    shakeCode() {
        this.pinCode.animate('shake');
        this.vibration.vibrate(100);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_5__directives_animate_animate__["a" /* Animate */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_5__directives_animate_animate__["a" /* Animate */])
], PinModalPage.prototype, "pinCode", void 0);
PinModalPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-pin',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/pin/pin-modal/pin-modal.html"*/'<ion-header>\n  <ion-navbar transparent>\n    <ion-buttons right>\n      <button (click)="close(true)" ion-button color="primary" *ngIf="action === \'pinSetUp\' || action === \'lockSetUp\'">\n        {{\'Cancel\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce fullscreen>\n  <div class="pin-header">\n    <div class="title">\n      <div *ngIf="!disableButtons">\n        <span class="message" *ngIf="!confirmingPin && !incorrect" translate>Please enter your PIN</span>\n        <span class="message" *ngIf="confirmingPin && !incorrect" translate>Confirm your PIN</span>\n        <span class="message" *ngIf="incorrect" translate>Incorrect PIN, try again.</span>\n      </div>\n      <div *ngIf="disableButtons">\n        <span class="message" *ngIf="expires" translate>Try again in {{expires}}</span>\n      </div>\n    </div>\n    <div class="icon-container">\n      <ion-icon class="app-icon">\n        <img src="assets/img/app/icon-flat.svg" />\n      </ion-icon>\n    </div>\n  </div>\n  <div class="code-wrapper">\n    <pin-dots [pin]="currentPin" animate></pin-dots>\n    <pin-pad (keystroke)="newEntry($event)" type="pin"></pin-pad>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/pin/pin-modal/pin-modal.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["q" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_vibration__["a" /* Vibration */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__["a" /* PlatformProvider */]])
], PinModalPage);

//# sourceMappingURL=pin-modal.js.map

/***/ }),

/***/ 333:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressbookAddPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_address_address__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__validators_address__ = __webpack_require__(1987);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__scan_scan__ = __webpack_require__(247);




// providers





// validators


let AddressbookAddPage = class AddressbookAddPage {
    constructor(navCtrl, navParams, events, ab, addressProvider, appProvider, formBuilder, logger, popupProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.events = events;
        this.ab = ab;
        this.addressProvider = addressProvider;
        this.appProvider = appProvider;
        this.formBuilder = formBuilder;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.updateAddressHandler = data => {
            this.addressBookAdd.controls['address'].setValue(this.parseAddress(data.value));
        };
        this.addressBookAdd = this.formBuilder.group({
            name: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required])
            ],
            email: ['', this.emailOrEmpty],
            address: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].compose([
                    __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required,
                    new __WEBPACK_IMPORTED_MODULE_9__validators_address__["a" /* AddressValidator */](this.addressProvider).isValid
                ])
            ]
        });
        if (this.navParams.data.addressbookEntry) {
            this.addressBookAdd.controls['address'].setValue(this.navParams.data.addressbookEntry);
        }
        this.appName = this.appProvider.info.nameCase;
        this.events.subscribe('Local/AddressScan', this.updateAddressHandler);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: AddressbookAddPage');
    }
    ngOnDestroy() {
        this.events.unsubscribe('Local/AddressScan', this.updateAddressHandler);
    }
    emailOrEmpty(control) {
        return control.value === '' ? null : __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].email(control);
    }
    save() {
        this.addressBookAdd.controls['address'].setValue(this.parseAddress(this.addressBookAdd.value.address));
        this.ab
            .add(this.addressBookAdd.value)
            .then(() => {
            this.navCtrl.pop();
        })
            .catch(err => {
            this.popupProvider.ionicAlert('Error', err);
        });
    }
    parseAddress(str) {
        return this.addressProvider.extractAddress(str);
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__scan_scan__["a" /* ScanPage */], { fromAddressbook: true });
    }
};
AddressbookAddPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-addressbook-add',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/addressbook/add/add.html"*/'<ion-header>\n\n  <ion-navbar>\n    <ion-title>{{ \'Add Contact\' | translate }}</ion-title>\n  </ion-navbar>\n\n</ion-header>\n\n\n<ion-content>\n\n  <form [formGroup]="addressBookAdd">\n    <ion-item>\n      <ion-label stacked>{{ \'Name\' | translate }}</ion-label>\n      <ion-input formControlName="name" type="text"></ion-input>\n    </ion-item>\n\n    <ion-item>\n      <ion-label stacked>{{ \'Email\' | translate }}</ion-label>\n      <ion-input formControlName="email" type="email"></ion-input>\n    </ion-item>\n\n    <ion-item>\n      <ion-label stacked>{{\'Wallet Address\' | translate }}</ion-label>\n      <ion-input formControlName="address" type="text" [value]="addressBookAdd.value.address" address-validator></ion-input>\n\n      <ion-icon *ngIf="addressBookAdd.controls[\'address\'].status == \'VALID\'" name="ios-checkmark-circle" class="check success" item-right></ion-icon>\n      <ion-icon *ngIf="addressBookAdd.value.address && addressBookAdd.controls[\'address\'].status == \'INVALID\'" class="check fail" name="ios-close-circle" item-right></ion-icon>\n\n      <ion-icon class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n    </ion-item>\n    <label-tip type="danger" header="no-header" *ngIf="addressBookAdd.value.address && addressBookAdd.controls[\'address\'].status == \'INVALID\'">\n      <div label-tip-body>\n        <span>{{\'This field only accepts addresses supported by {appName} Wallet\' | translate:{appName: appName} }}</span>\n      </div>\n    </label-tip>\n  </form>\n\n  <button ion-button class="button-standard" (click)="save()" [disabled]="addressBookAdd.invalid">\n    {{\'Save\' | translate}}\n  </button>\n\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/addressbook/add/add.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */]])
], AddressbookAddPage);

//# sourceMappingURL=add.js.map

/***/ }),

/***/ 334:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackupKeyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__backup_game_backup_game__ = __webpack_require__(1015);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(15);





// pages

// providers





let BackupKeyPage = class BackupKeyPage {
    constructor(navCtrl, navParams, logger, profileProvider, bwcErrorProvider, translate, actionSheetProvider, keyProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.translate = translate;
        this.actionSheetProvider = actionSheetProvider;
        this.keyProvider = keyProvider;
        this.keyId = this.navParams.data.keyId;
        this.walletGroup = this.profileProvider.getWalletGroup(this.keyId);
        this.credentialsEncrypted = this.walletGroup.isPrivKeyEncrypted;
    }
    ionViewDidEnter() {
        if (!this.walletGroup.canSign) {
            this.showNoRecoveryPhraseError();
            return;
        }
        this.keyProvider
            .handleEncryptedWallet(this.keyId)
            .then((password) => {
            const keys = this.keyProvider.get(this.keyId, password);
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](keys)) {
                this.logger.warn('Empty keys');
            }
            this.credentialsEncrypted = false;
            this.keys = keys;
            if (!this.keys || !this.keys.mnemonic) {
                this.showNoRecoveryPhraseError();
                return;
            }
            this.showSafeguardMessage();
            this.setFlow();
        })
            .catch(err => {
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED') {
                const title = this.translate.instant('Could not decrypt wallet');
                this.showErrorInfoSheet(this.bwcErrorProvider.msg(err), title);
            }
            this.navCtrl.pop();
        });
    }
    showNoRecoveryPhraseError() {
        const title = this.translate.instant('Wallet recovery phrase not available');
        let err = this.translate.instant('You can still export it from "Export Wallet" option.');
        this.showErrorInfoSheet(err, title);
        this.navCtrl.pop();
        this.logger.warn('no mnemonics');
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.warn('Could not get keys:', err);
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: err, title: infoSheetTitle });
        errorInfoSheet.present();
    }
    goToBackupGame() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__backup_game_backup_game__["a" /* BackupGamePage */], {
            words: this.mnemonicWords,
            keys: this.keys,
            keyId: this.keyId
        });
    }
    setFlow() {
        if (!this.keys)
            return;
        let words = this.keys.mnemonic;
        this.mnemonicWords = words.split(/[\u3000\s]+/);
        this.wordToShow = 0;
    }
    showSafeguardMessage() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('backup-safeguard-warning');
        infoSheet.present();
    }
    showDoThisLaterMessage() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('backup-later-warning');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option) {
                this.navCtrl.pop();
            }
        });
    }
    nextWord() {
        this.wordToShow++;
    }
    previousWord() {
        this.wordToShow--;
    }
};
BackupKeyPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-backup-key',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/backup/backup-key/backup-key.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Recovery Phrase\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n\n<ion-content no-bounce>\n  <div class="key-container" *ngIf="walletGroup.canSign && mnemonicWords && mnemonicWords[0]">\n    <div class="word-container">\n      <div class="word-title" translate>Write down each word.</div>\n      <div class="word">\n        <span>{{mnemonicWords[wordToShow]}}</span>\n      </div>\n      <div class="word-number">\n        {{wordToShow + 1}} / {{mnemonicWords.length}}\n      </div>\n    </div>\n  </div>\n  <div class="bottom-absolute" [ngClass]="{\'right-align\': wordToShow == 0}" *ngIf="walletGroup.canSign && mnemonicWords && mnemonicWords[0]">\n    <button *ngIf="wordToShow > 0" ion-button clear class="button-left" [disabled]="credentialsEncrypted" (click)="previousWord()">\n      {{\'Previous\' | translate}}\n    </button>\n    <button *ngIf="wordToShow < mnemonicWords.length - 1" ion-button clear class="button-right" [disabled]="credentialsEncrypted" (click)="nextWord()">\n      {{\'Next\' | translate}}\n    </button>\n    <button *ngIf="wordToShow == mnemonicWords.length - 1" ion-button clear class="button-right" [disabled]="credentialsEncrypted" (click)="goToBackupGame()">\n      {{\'Continue\' | translate}}\n    </button>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/backup/backup-key/backup-key.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_key_key__["a" /* KeyProvider */]])
], BackupKeyPage);

//# sourceMappingURL=backup-key.js.map

/***/ }),

/***/ 34:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OnGoingProcessProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);






let OnGoingProcessProvider = class OnGoingProcessProvider {
    constructor(loadingCtrl, logger, translate) {
        this.loadingCtrl = loadingCtrl;
        this.logger = logger;
        this.translate = translate;
        this.logger.debug('OnGoingProcessProvider initialized');
        // TODO GET - CLEAR - CHECK DecimalPipe for FILTER WITH TRANSLATE
        this.ongoingProcess = [];
    }
    getProcessNames() {
        const processNames = {
            broadcastingTx: this.translate.instant('Broadcasting transaction...'),
            calculatingFee: this.translate.instant('Calculating fee...'),
            calculatingSendMax: this.translate.instant('Calculating send max...'),
            connectingCoinbase: this.translate.instant('Connecting to Coinbase...'),
            connectingShapeshift: this.translate.instant('Connecting to ShapeShift...'),
            creatingTx: this.translate.instant('Creating transaction...'),
            creatingWallet: this.translate.instant('Creating Wallet...'),
            deletingWallet: this.translate.instant('Deleting Wallet...'),
            extractingWalletInfo: this.translate.instant('Extracting Wallet information...'),
            fetchingPayPro: this.translate.instant('Fetching payment information...'),
            generatingCSV: this.translate.instant('Generating .csv file...'),
            gettingFeeLevels: this.translate.instant('Getting fee levels...'),
            importingWallet: this.translate.instant('Importing Wallet...'),
            joiningWallet: this.translate.instant('Joining Wallet...'),
            recreating: this.translate.instant('Recreating Wallet...'),
            rejectTx: this.translate.instant('Rejecting payment proposal...'),
            removeTx: this.translate.instant('Deleting payment proposal...'),
            retrievingInputs: this.translate.instant('Retrieving inputs information...'),
            scanning: this.translate.instant('Scanning Wallet funds...'),
            sendingTx: this.translate.instant('Sending transaction...'),
            signingTx: this.translate.instant('Signing transaction...'),
            sweepingWallet: this.translate.instant('Sweeping Wallet...'),
            validatingWords: this.translate.instant('Validating recovery phrase...'),
            loadingTxInfo: this.translate.instant('Loading transaction info...'),
            sendingFeedback: this.translate.instant('Sending feedback...'),
            generatingNewAddress: this.translate.instant('Generating new address...'),
            sendingByEmail: this.translate.instant('Preparing addresses...'),
            sending2faCode: this.translate.instant('Sending 2FA code...'),
            buyingBitcoin: this.translate.instant('Buying Bitcoin...'),
            sellingBitcoin: this.translate.instant('Selling Bitcoin...'),
            fetchingBitPayAccount: this.translate.instant('Fetching BitPay Account...'),
            fetchingBitPayCards: this.translate.instant('Fetching BitPay Cards...'),
            updatingGiftCards: this.translate.instant('Updating Gift Cards...'),
            updatingGiftCard: this.translate.instant('Updating Gift Card...'),
            cancelingGiftCard: this.translate.instant('Canceling Gift Card...'),
            creatingGiftCard: this.translate.instant('Creating Gift Card...'),
            buyingGiftCard: this.translate.instant('Buying Gift Card...'),
            topup: this.translate.instant('Top up in progress...'),
            duplicatingWallet: this.translate.instant('Duplicating wallet...')
        };
        return processNames;
    }
    clear() {
        this.ongoingProcess = [];
        try {
            this.loading.dismiss();
        }
        catch (e) {
            // No problem
            this.logger.warn('no active on-going-process. No problem.', e);
        }
        this.loading = null;
        this.logger.debug('ongoingProcess clear');
    }
    pause() {
        this.pausedOngoingProcess = this.ongoingProcess;
        this.clear();
    }
    resume() {
        this.ongoingProcess = this.pausedOngoingProcess;
        __WEBPACK_IMPORTED_MODULE_4_lodash__["forEach"](this.pausedOngoingProcess, v => {
            this.set(v);
            return;
        });
        this.pausedOngoingProcess = [];
    }
    set(processName) {
        this.logger.debug('ongoingProcess active: ', processName);
        this.ongoingProcess.push(processName);
        let showName = this.getProcessNames()[processName] || processName;
        if (!this.loading) {
            this.loading = this.loadingCtrl.create();
        }
        this.loading.setContent(showName);
        this.loading.present();
    }
};
OnGoingProcessProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* LoadingController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], OnGoingProcessProvider);

//# sourceMappingURL=on-going-process.js.map

/***/ }),

/***/ 35:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ionic_native_android_fingerprint_auth__ = __webpack_require__(849);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_0__ionic_native_android_fingerprint_auth__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_clipboard__ = __webpack_require__(284);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_1__ionic_native_clipboard__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__ = __webpack_require__(182);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_fcm_ng__ = __webpack_require__(426);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_fcm_ng___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_fcm_ng__);
/* harmony reexport (binding) */ if(__webpack_require__.o(__WEBPACK_IMPORTED_MODULE_3_fcm_ng__, "FCMNG")) __webpack_require__.d(__webpack_exports__, "z", function() { return __WEBPACK_IMPORTED_MODULE_3_fcm_ng__["FCMNG"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_file__ = __webpack_require__(151);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return __WEBPACK_IMPORTED_MODULE_4__ionic_native_file__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_launch_review__ = __webpack_require__(850);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "M", function() { return __WEBPACK_IMPORTED_MODULE_5__ionic_native_launch_review__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_qr_scanner__ = __webpack_require__(851);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "W", function() { return __WEBPACK_IMPORTED_MODULE_6__ionic_native_qr_scanner__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_screen_orientation__ = __webpack_require__(847);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_0", function() { return __WEBPACK_IMPORTED_MODULE_7__ionic_native_screen_orientation__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ionic_native_social_sharing__ = __webpack_require__(120);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_2", function() { return __WEBPACK_IMPORTED_MODULE_8__ionic_native_social_sharing__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ionic_native_splash_screen__ = __webpack_require__(425);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_3", function() { return __WEBPACK_IMPORTED_MODULE_9__ionic_native_splash_screen__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_4", function() { return __WEBPACK_IMPORTED_MODULE_10__ionic_native_status_bar__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ionic_native_toast__ = __webpack_require__(1470);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_6", function() { return __WEBPACK_IMPORTED_MODULE_11__ionic_native_toast__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ionic_native_touch_id__ = __webpack_require__(852);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_7", function() { return __WEBPACK_IMPORTED_MODULE_12__ionic_native_touch_id__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ionic_native_vibration__ = __webpack_require__(853);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_12", function() { return __WEBPACK_IMPORTED_MODULE_13__ionic_native_vibration__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ionic_native_user_agent__ = __webpack_require__(848);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_11", function() { return __WEBPACK_IMPORTED_MODULE_14__ionic_native_user_agent__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_15__providers_action_sheet_action_sheet__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_address_book_address_book__ = __webpack_require__(121);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_16__providers_address_book_address_book__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_address_address__ = __webpack_require__(108);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_17__providers_address_address__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_analytics_analytics__ = __webpack_require__(243);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_18__providers_analytics_analytics__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_app_identity_app_identity__ = __webpack_require__(317);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_19__providers_app_identity_app_identity__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_app_app__ = __webpack_require__(28);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_20__providers_app_app__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_backup_backup__ = __webpack_require__(975);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_21__providers_backup_backup__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_bitpay_account_bitpay_account__ = __webpack_require__(463);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_22__providers_bitpay_account_bitpay_account__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_bitpay_card_bitpay_card__ = __webpack_require__(146);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_23__providers_bitpay_card_bitpay_card__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_bitpay_bitpay__ = __webpack_require__(246);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_24__providers_bitpay_bitpay__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_25__providers_bwc_error_bwc_error__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_26__providers_bwc_bwc__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_clipboard_clipboard__ = __webpack_require__(195);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_27__providers_clipboard_clipboard__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_coinbase_coinbase__ = __webpack_require__(172);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_28__providers_coinbase_coinbase__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_config_config__ = __webpack_require__(16);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_29__providers_config_config__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_currency_currency__ = __webpack_require__(25);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_30__providers_currency_currency__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(169);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_31__providers_derivation_path_helper_derivation_path_helper__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__providers_dom_dom__ = __webpack_require__(427);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return __WEBPACK_IMPORTED_MODULE_32__providers_dom_dom__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__providers_download_download__ = __webpack_require__(462);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return __WEBPACK_IMPORTED_MODULE_33__providers_download_download__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__providers_email_notifications_email_notifications__ = __webpack_require__(147);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return __WEBPACK_IMPORTED_MODULE_34__providers_email_notifications_email_notifications__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return __WEBPACK_IMPORTED_MODULE_35__providers_external_link_external_link__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__providers_fee_fee__ = __webpack_require__(114);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return __WEBPACK_IMPORTED_MODULE_36__providers_fee_fee__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__providers_feedback_feedback__ = __webpack_require__(464);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return __WEBPACK_IMPORTED_MODULE_37__providers_feedback_feedback__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__providers_filter_filter__ = __webpack_require__(245);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return __WEBPACK_IMPORTED_MODULE_38__providers_filter_filter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__providers_gift_card_gift_card__ = __webpack_require__(86);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return __WEBPACK_IMPORTED_MODULE_39__providers_gift_card_gift_card__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__providers_home_integrations_home_integrations__ = __webpack_require__(113);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return __WEBPACK_IMPORTED_MODULE_40__providers_home_integrations_home_integrations__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__providers_http_requests_http_requests__ = __webpack_require__(977);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return __WEBPACK_IMPORTED_MODULE_41__providers_http_requests_http_requests__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__providers_incoming_data_incoming_data__ = __webpack_require__(170);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return __WEBPACK_IMPORTED_MODULE_42__providers_incoming_data_incoming_data__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__providers_invoice_invoice__ = __webpack_require__(976);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return __WEBPACK_IMPORTED_MODULE_43__providers_invoice_invoice__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__providers_key_key__ = __webpack_require__(66);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return __WEBPACK_IMPORTED_MODULE_44__providers_key_key__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__providers_language_loader_language_loader__ = __webpack_require__(978);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return __WEBPACK_IMPORTED_MODULE_45__providers_language_loader_language_loader__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__providers_language_language__ = __webpack_require__(244);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "L", function() { return __WEBPACK_IMPORTED_MODULE_46__providers_language_language__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__providers_logger_logger__ = __webpack_require__(7);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "N", function() { return __WEBPACK_IMPORTED_MODULE_47__providers_logger_logger__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__providers_electron_electron__ = __webpack_require__(286);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return __WEBPACK_IMPORTED_MODULE_48__providers_electron_electron__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "O", function() { return __WEBPACK_IMPORTED_MODULE_49__providers_on_going_process_on_going_process__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__providers_paypro_paypro__ = __webpack_require__(171);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "P", function() { return __WEBPACK_IMPORTED_MODULE_50__providers_paypro_paypro__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Q", function() { return __WEBPACK_IMPORTED_MODULE_51__providers_persistence_persistence__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__providers_platform_platform__ = __webpack_require__(12);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return __WEBPACK_IMPORTED_MODULE_52__providers_platform_platform__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__providers_popup_popup__ = __webpack_require__(18);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return __WEBPACK_IMPORTED_MODULE_53__providers_popup_popup__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__providers_price_price__ = __webpack_require__(1984);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return __WEBPACK_IMPORTED_MODULE_54__providers_price_price__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__providers_profile_profile__ = __webpack_require__(15);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "U", function() { return __WEBPACK_IMPORTED_MODULE_55__providers_profile_profile__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__providers_push_notifications_push_notifications__ = __webpack_require__(115);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "V", function() { return __WEBPACK_IMPORTED_MODULE_56__providers_push_notifications_push_notifications__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__providers_rate_rate__ = __webpack_require__(145);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "X", function() { return __WEBPACK_IMPORTED_MODULE_57__providers_rate_rate__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__providers_replace_parameters_replace_parameters__ = __webpack_require__(101);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Y", function() { return __WEBPACK_IMPORTED_MODULE_58__providers_replace_parameters_replace_parameters__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__providers_scan_scan__ = __webpack_require__(981);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Z", function() { return __WEBPACK_IMPORTED_MODULE_59__providers_scan_scan__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__providers_shapeshift_shapeshift__ = __webpack_require__(174);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_1", function() { return __WEBPACK_IMPORTED_MODULE_60__providers_shapeshift_shapeshift__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__providers_time_time__ = __webpack_require__(148);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_5", function() { return __WEBPACK_IMPORTED_MODULE_61__providers_time_time__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__providers_touchid_touchid__ = __webpack_require__(173);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_8", function() { return __WEBPACK_IMPORTED_MODULE_62__providers_touchid_touchid__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__providers_tx_confirm_notification_tx_confirm_notification__ = __webpack_require__(466);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_9", function() { return __WEBPACK_IMPORTED_MODULE_63__providers_tx_confirm_notification_tx_confirm_notification__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_10", function() { return __WEBPACK_IMPORTED_MODULE_64__providers_tx_format_tx_format__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_65__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_13", function() { return __WEBPACK_IMPORTED_MODULE_65__providers_wallet_wallet__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_66__pages_wallet_tabs_wallet_tabs_provider__ = __webpack_require__(90);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_14", function() { return __WEBPACK_IMPORTED_MODULE_66__pages_wallet_tabs_wallet_tabs_provider__["a"]; });
/* Native modules */















/* Providers */




















































//# sourceMappingURL=index.js.map

/***/ }),

/***/ 39:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Network; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return PersistenceProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_file__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__storage_file_storage__ = __webpack_require__(1471);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__storage_local_storage__ = __webpack_require__(1472);








// TODO import { RamStorage } from './storage/ram-storage';
var Network;
(function (Network) {
    Network["livenet"] = "livenet";
    Network["testnet"] = "testnet";
})(Network || (Network = {}));
const Keys = {
    ADDRESS_BOOK: network => 'addressbook-' + network,
    AGREE_DISCLAIMER: 'agreeDisclaimer',
    GIFT_CARD_USER_INFO: 'amazonUserInfo',
    APP_IDENTITY: network => 'appIdentity-' + network,
    BACKUP: walletId => 'backup-' + walletId,
    BACKUP_WALLET_GROUP: keyId => 'walletGroupBackup-' + keyId,
    BALANCE_CACHE: cardId => 'balanceCache-' + cardId,
    HISTORY_CACHE: cardId => 'historyCache-' + cardId,
    BITPAY_ACCOUNTS_V2: network => 'bitpayAccounts-v2-' + network,
    CLEAN_AND_SCAN_ADDRESSES: 'CleanAndScanAddresses',
    COINBASE_REFRESH_TOKEN: network => 'coinbaseRefreshToken-' + network,
    COINBASE_TOKEN: network => 'coinbaseToken-' + network,
    COINBASE_TXS: network => 'coinbaseTxs-' + network,
    CONFIG: 'config',
    FEEDBACK: 'feedback',
    SURVEY: 'survey',
    ETH_LIVE_CARD: 'ethLiveCard',
    FOCUSED_WALLET_ID: 'focusedWalletId',
    GIFT_CARD_CONFIG_CACHE: (network) => {
        const suffix = network === Network.livenet ? '' : `-${network}`;
        return `giftCardConfigCache${suffix}`;
    },
    ACTIVE_GIFT_CARDS: (network) => {
        return `activeGiftCards-${network}`;
    },
    GIFT_CARDS: (cardName, network) => {
        const legacyGiftCardKey = getLegacyGiftCardKey(cardName, network);
        return legacyGiftCardKey || `giftCards-${cardName}-${network}`;
    },
    HIDE_GIFT_CARD_DISCOUNT_ITEM: 'hideGiftCardDiscountItem',
    HIDE_BALANCE: walletId => 'hideBalance-' + walletId,
    HIDE_WALLET: walletId => 'hideWallet-' + walletId,
    KEY_ONBOARDING: 'keyOnboarding',
    KEYS: 'keys',
    LAST_ADDRESS: walletId => 'lastAddress-' + walletId,
    LAST_CURRENCY_USED: 'lastCurrencyUsed',
    PROFILE: 'profile',
    PROFILE_OLD: 'profileOld',
    REMOTE_PREF_STORED: 'remotePrefStored',
    TX_CONFIRM_NOTIF: txid => 'txConfirmNotif-' + txid,
    TX_HISTORY: walletId => 'txsHistory-' + walletId,
    ORDER_WALLET: walletId => 'order-' + walletId,
    SERVER_MESSAGE_DISMISSED: messageId => 'serverMessageDismissed-' + messageId,
    SHAPESHIFT_TOKEN: network => 'shapeshiftToken-' + network,
    WALLET_GROUP_NAME: keyId => `Key-${keyId}`
};
let PersistenceProvider = class PersistenceProvider {
    constructor(logger, platform, file) {
        this.logger = logger;
        this.platform = platform;
        this.file = file;
        this.logger.debug('PersistenceProvider initialized');
    }
    load() {
        this.storage = this.platform.isCordova
            ? new __WEBPACK_IMPORTED_MODULE_6__storage_file_storage__["a" /* FileStorage */](this.file, this.logger)
            : new __WEBPACK_IMPORTED_MODULE_7__storage_local_storage__["a" /* LocalStorage */](this.logger);
    }
    storeProfileLegacy(profileOld) {
        return this.storage.set(Keys.PROFILE_OLD, profileOld);
    }
    getProfileLegacy() {
        return this.storage.get(Keys.PROFILE_OLD);
    }
    removeProfileLegacy() {
        return this.storage.remove(Keys.PROFILE_OLD);
    }
    storeNewProfile(profile) {
        return this.storage.create(Keys.PROFILE, profile);
    }
    storeProfile(profile) {
        return this.storage.set(Keys.PROFILE, profile);
    }
    getProfile() {
        return new Promise(resolve => {
            this.storage.get(Keys.PROFILE).then(profile => {
                resolve(profile);
            });
        });
    }
    setKeys(keys) {
        return this.storage.set(Keys.KEYS, keys);
    }
    getKeys() {
        return this.storage.get(Keys.KEYS);
    }
    setFeedbackInfo(feedbackValues) {
        return this.storage.set(Keys.FEEDBACK, feedbackValues);
    }
    getFeedbackInfo() {
        return this.storage.get(Keys.FEEDBACK);
    }
    setSurveyFlag() {
        return this.storage.set(Keys.SURVEY, true);
    }
    getSurveyFlag() {
        return this.storage.get(Keys.SURVEY);
    }
    setEthLiveCardFlag() {
        return this.storage.set(Keys.ETH_LIVE_CARD, true);
    }
    getEthLiveCardFlag() {
        return this.storage.get(Keys.ETH_LIVE_CARD);
    }
    setKeyOnboardingFlag() {
        return this.storage.set(Keys.KEY_ONBOARDING, true);
    }
    getKeyOnboardingFlag() {
        return this.storage.get(Keys.KEY_ONBOARDING);
    }
    storeFocusedWalletId(walletId) {
        return this.storage.set(Keys.FOCUSED_WALLET_ID, walletId || '');
    }
    getFocusedWalletId() {
        return this.storage.get(Keys.FOCUSED_WALLET_ID);
    }
    getLastAddress(walletId) {
        return this.storage.get(Keys.LAST_ADDRESS(walletId));
    }
    storeLastAddress(walletId, address) {
        return this.storage.set(Keys.LAST_ADDRESS(walletId), address);
    }
    clearLastAddress(walletId) {
        return this.storage.remove(Keys.LAST_ADDRESS(walletId));
    }
    setBackupFlag(walletId) {
        return this.storage.set(Keys.BACKUP(walletId), Date.now());
    }
    getBackupFlag(walletId) {
        return this.storage.get(Keys.BACKUP(walletId));
    }
    clearBackupFlag(walletId) {
        return this.storage.remove(Keys.BACKUP(walletId));
    }
    setBackupGroupFlag(keyId, timestamp) {
        timestamp = timestamp || Date.now();
        return this.storage.set(Keys.BACKUP_WALLET_GROUP(keyId), timestamp);
    }
    getBackupGroupFlag(keyId) {
        return this.storage.get(Keys.BACKUP_WALLET_GROUP(keyId));
    }
    clearBackupGroupFlag(keyId) {
        return this.storage.remove(Keys.BACKUP_WALLET_GROUP(keyId));
    }
    setCleanAndScanAddresses(walletId) {
        return this.storage.set(Keys.CLEAN_AND_SCAN_ADDRESSES, walletId);
    }
    getCleanAndScanAddresses() {
        return this.storage.get(Keys.CLEAN_AND_SCAN_ADDRESSES);
    }
    removeCleanAndScanAddresses() {
        return this.storage.remove(Keys.CLEAN_AND_SCAN_ADDRESSES);
    }
    getConfig() {
        return this.storage.get(Keys.CONFIG);
    }
    storeConfig(config) {
        return this.storage.set(Keys.CONFIG, config);
    }
    clearConfig() {
        return this.storage.remove(Keys.CONFIG);
    }
    setHideBalanceFlag(walletId, val) {
        return this.storage.set(Keys.HIDE_BALANCE(walletId), val);
    }
    getHideBalanceFlag(walletId) {
        return this.storage.get(Keys.HIDE_BALANCE(walletId));
    }
    setHideWalletFlag(walletId, val) {
        return this.storage.set(Keys.HIDE_WALLET(walletId), val);
    }
    getHideWalletFlag(walletId) {
        return this.storage.get(Keys.HIDE_WALLET(walletId));
    }
    setDisclaimerAccepted() {
        return this.storage.set(Keys.AGREE_DISCLAIMER, true);
    }
    // for compatibility
    getCopayDisclaimerFlag() {
        return this.storage.get(Keys.AGREE_DISCLAIMER);
    }
    setRemotePrefsStoredFlag() {
        return this.storage.set(Keys.REMOTE_PREF_STORED, true);
    }
    getRemotePrefsStoredFlag() {
        return this.storage.get(Keys.REMOTE_PREF_STORED);
    }
    setCoinbaseToken(network, token) {
        return this.storage.set(Keys.COINBASE_TOKEN(network), token);
    }
    getCoinbaseToken(network) {
        return this.storage.get(Keys.COINBASE_TOKEN(network));
    }
    removeCoinbaseToken(network) {
        return this.storage.remove(Keys.COINBASE_TOKEN(network));
    }
    setCoinbaseRefreshToken(network, token) {
        return this.storage.set(Keys.COINBASE_REFRESH_TOKEN(network), token);
    }
    getCoinbaseRefreshToken(network) {
        return this.storage.get(Keys.COINBASE_REFRESH_TOKEN(network));
    }
    removeCoinbaseRefreshToken(network) {
        return this.storage.remove(Keys.COINBASE_REFRESH_TOKEN(network));
    }
    setCoinbaseTxs(network, ctx) {
        return this.storage.set(Keys.COINBASE_TXS(network), ctx);
    }
    getCoinbaseTxs(network) {
        return this.storage.get(Keys.COINBASE_TXS(network));
    }
    removeCoinbaseTxs(network) {
        return this.storage.remove(Keys.COINBASE_TXS(network));
    }
    setAddressBook(network, addressbook) {
        return this.storage.set(Keys.ADDRESS_BOOK(network), addressbook);
    }
    getAddressBook(network) {
        return this.storage.get(Keys.ADDRESS_BOOK(network));
    }
    removeAddressbook(network) {
        return this.storage.remove(Keys.ADDRESS_BOOK(network));
    }
    setLastCurrencyUsed(lastCurrencyUsed) {
        return this.storage.set(Keys.LAST_CURRENCY_USED, lastCurrencyUsed);
    }
    getLastCurrencyUsed() {
        return this.storage.get(Keys.LAST_CURRENCY_USED);
    }
    checkQuota() {
        let block = '';
        // 50MB
        for (let i = 0; i < 1024 * 1024; ++i) {
            block += '12345678901234567890123456789012345678901234567890';
        }
        this.storage.set('test', block).catch(err => {
            this.logger.error('CheckQuota Return:' + err);
        });
    }
    setTxHistory(walletId, txs) {
        return this.storage.set(Keys.TX_HISTORY(walletId), txs).catch(err => {
            this.logger.error('Error saving tx History. Size:' + txs.length);
            this.logger.error(err);
        });
    }
    getTxHistory(walletId) {
        return this.storage.get(Keys.TX_HISTORY(walletId));
    }
    removeTxHistory(walletId) {
        return this.storage.remove(Keys.TX_HISTORY(walletId));
    }
    setLastKnownHistory(id, txs) {
        let updatedOn = Math.floor(Date.now() / 1000);
        return this.storage.set(Keys.HISTORY_CACHE(id), {
            updatedOn,
            txs
        });
    }
    getLastKnownHistory(id) {
        return this.storage.get(Keys.HISTORY_CACHE(id));
    }
    setLastKnownBalance(id, balance) {
        let updatedOn = Math.floor(Date.now() / 1000);
        return this.storage.set(Keys.BALANCE_CACHE(id), {
            updatedOn,
            balance
        });
    }
    getLastKnownBalance(id) {
        return this.storage.get(Keys.BALANCE_CACHE(id));
    }
    removeLastKnownBalance(id) {
        return this.storage.remove(Keys.BALANCE_CACHE(id));
    }
    setAppIdentity(network, data) {
        return this.storage.set(Keys.APP_IDENTITY(network), data);
    }
    getAppIdentity(network) {
        return this.storage.get(Keys.APP_IDENTITY(network));
    }
    removeAppIdentity(network) {
        return this.storage.remove(Keys.APP_IDENTITY(network));
    }
    removeAllWalletData(walletId) {
        this.clearLastAddress(walletId);
        this.removeTxHistory(walletId);
        this.clearBackupFlag(walletId);
        this.removeWalletOrder(walletId);
    }
    removeAllWalletGroupData(keyId) {
        this.clearBackupGroupFlag(keyId);
    }
    getActiveGiftCards(network) {
        return this.storage.get(Keys.ACTIVE_GIFT_CARDS(network));
    }
    setActiveGiftCards(network, data) {
        return this.storage.set(Keys.ACTIVE_GIFT_CARDS(network), data);
    }
    getGiftCardConfigCache(network) {
        return this.storage.get(Keys.GIFT_CARD_CONFIG_CACHE(network));
    }
    removeGiftCardConfigCache(network) {
        return this.storage.remove(Keys.GIFT_CARD_CONFIG_CACHE(network));
    }
    setGiftCardConfigCache(network, data) {
        return this.storage.set(Keys.GIFT_CARD_CONFIG_CACHE(network), data);
    }
    setGiftCardUserInfo(data) {
        return this.storage.set(Keys.GIFT_CARD_USER_INFO, data);
    }
    getGiftCardUserInfo() {
        return this.storage.get(Keys.GIFT_CARD_USER_INFO);
    }
    removeGiftCardUserInfo() {
        return this.storage.remove(Keys.GIFT_CARD_USER_INFO);
    }
    setHideGiftCardDiscountItem(data) {
        return this.storage.set(Keys.HIDE_GIFT_CARD_DISCOUNT_ITEM, data);
    }
    getHideGiftCardDiscountItem() {
        return this.storage.get(Keys.HIDE_GIFT_CARD_DISCOUNT_ITEM);
    }
    removeHideGiftCardDiscountItem() {
        return this.storage.remove(Keys.HIDE_GIFT_CARD_DISCOUNT_ITEM);
    }
    setTxConfirmNotification(txid, val) {
        return this.storage.set(Keys.TX_CONFIRM_NOTIF(txid), val);
    }
    getTxConfirmNotification(txid) {
        return this.storage.get(Keys.TX_CONFIRM_NOTIF(txid));
    }
    removeTxConfirmNotification(txid) {
        return this.storage.remove(Keys.TX_CONFIRM_NOTIF(txid));
    }
    getBitpayAccounts(network) {
        return this.storage.get(Keys.BITPAY_ACCOUNTS_V2(network));
    }
    setBitpayAccount(network, data) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            allAccounts = allAccounts || {};
            let account = allAccounts[data.email] || {};
            account.token = data.token;
            account.familyName = data.familyName;
            account.givenName = data.givenName;
            allAccounts[data.email] = account;
            this.logger.info('Storing BitPay accounts with new account:' + data.email);
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    removeBitpayAccount(network, email) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            allAccounts = allAccounts || {};
            delete allAccounts[email];
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    setBitpayDebitCards(network, email, cards) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            allAccounts = allAccounts || {};
            if (!allAccounts[email])
                throw new Error('Cannot set cards for unknown account ' + email);
            allAccounts[email].cards = cards;
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    // cards: [
    //   eid: card id
    //   id: card id
    //   lastFourDigits: card number
    //   token: card token
    //   email: account email
    // ]
    getBitpayDebitCards(network) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            let allCards = [];
            __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](allAccounts, (account, email) => {
                if (account.cards) {
                    // Add account's email to each card
                    var cards = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](account.cards);
                    __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](cards, x => {
                        x.email = email;
                    });
                    allCards = allCards.concat(cards);
                }
            });
            return allCards;
        });
    }
    removeBitpayDebitCard(network, cardEid) {
        return this.getBitpayAccounts(network)
            .then(allAccounts => {
            return __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](allAccounts, account => {
                account.cards = __WEBPACK_IMPORTED_MODULE_3_lodash__["reject"](account.cards, {
                    eid: cardEid
                });
            });
        })
            .then(allAccounts => {
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    setGiftCards(cardName, network, gcs) {
        return this.storage.set(Keys.GIFT_CARDS(cardName, network), gcs);
    }
    getGiftCards(cardName, network) {
        return this.storage.get(Keys.GIFT_CARDS(cardName, network));
    }
    setServerMessageDismissed(id) {
        return this.storage.set(Keys.SERVER_MESSAGE_DISMISSED(id), 'dismissed');
    }
    getServerMessageDismissed(id) {
        return this.storage.get(Keys.SERVER_MESSAGE_DISMISSED(id));
    }
    removeServerMessageDismissed(id) {
        return this.storage.remove(Keys.SERVER_MESSAGE_DISMISSED(id));
    }
    setShapeshift(network, gcs) {
        return this.storage.set('shapeShift-' + network, gcs);
    }
    getShapeshift(network) {
        return this.storage.get('shapeShift-' + network);
    }
    removeShapeshift(network) {
        return this.storage.remove('shapeShift-' + network);
    }
    setShapeshiftToken(network, token) {
        return this.storage.set(Keys.SHAPESHIFT_TOKEN(network), token);
    }
    getShapeshiftToken(network) {
        return this.storage.get(Keys.SHAPESHIFT_TOKEN(network));
    }
    removeShapeshiftToken(network) {
        return this.storage.remove(Keys.SHAPESHIFT_TOKEN(network));
    }
    setWalletOrder(walletId, order) {
        return this.storage.set(Keys.ORDER_WALLET(walletId), order);
    }
    getWalletOrder(walletId) {
        return this.storage.get(Keys.ORDER_WALLET(walletId));
    }
    removeWalletOrder(walletId) {
        return this.storage.remove(Keys.ORDER_WALLET(walletId));
    }
    setLockStatus(isLocked) {
        return this.storage.set('lockStatus', isLocked);
    }
    getLockStatus() {
        return this.storage.get('lockStatus');
    }
    removeLockStatus() {
        return this.storage.remove('lockStatus');
    }
    setEmailLawCompliance(value) {
        return this.storage.set('emailLawCompliance', value);
    }
    getEmailLawCompliance() {
        return this.storage.get('emailLawCompliance');
    }
    removeEmailLawCompliance() {
        return this.storage.remove('emailLawCompliance');
    }
    setHiddenFeaturesFlag(value) {
        this.logger.debug('Hidden features: ', value);
        return this.storage.set('hiddenFeatures', value);
    }
    getHiddenFeaturesFlag() {
        return this.storage.get('hiddenFeatures');
    }
    removeHiddenFeaturesFlag() {
        return this.storage.remove('hiddenFeatures');
    }
    setWalletGroupName(keyId, name) {
        return this.storage.set(Keys.WALLET_GROUP_NAME(keyId), name);
    }
    getWalletGroupName(keyId) {
        return this.storage.get(Keys.WALLET_GROUP_NAME(keyId));
    }
    removeWalletGroupName(keyId) {
        return this.storage.remove(Keys.WALLET_GROUP_NAME(keyId));
    }
};
PersistenceProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_file__["a" /* File */]])
], PersistenceProvider);

function getLegacyGiftCardKey(cardName, network) {
    switch (cardName + network) {
        case 'Amazon.com' + Network.livenet:
            return 'amazonGiftCards-livenet';
        case 'Amazon.com' + Network.testnet:
            return 'amazonGiftCards-testnet';
        case 'Amazon.co.jp' + Network.livenet:
            return 'amazonGiftCards-livenet-japan';
        case 'Amazon.co.jp' + Network.testnet:
            return 'amazonGiftCards-testnet-japan';
        case 'Mercado Livre' + Network.livenet:
            return 'MercadoLibreGiftCards-livenet';
        case 'Mercado Livre' + Network.testnet:
            return 'MercadoLibreGiftCards-testnet';
        default:
            return undefined;
    }
}
//# sourceMappingURL=persistence.js.map

/***/ }),

/***/ 424:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__prod__ = __webpack_require__(1466);

/**
 * Environment: dev
 */
const env = Object.assign({}, __WEBPACK_IMPORTED_MODULE_0__prod__["a" /* default */], { 
    // override for development:
    name: 'development' });
/* harmony default export */ __webpack_exports__["a"] = (env);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 427:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DomProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let DomProvider = class DomProvider {
    constructor(componentFactoryResolver, injector, appRef) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.appRef = appRef;
    }
    appendComponentToBody(component) {
        const componentRef = this.componentFactoryResolver
            .resolveComponentFactory(component)
            .create(this.injector);
        this.appRef.attachView(componentRef.hostView);
        const domElem = componentRef.hostView
            .rootNodes[0];
        this.appendToDom(domElem);
        return componentRef;
    }
    appendToDom(domElem) {
        document.getElementsByTagName('ion-app')[0].appendChild(domElem);
    }
    removeComponent(componentRef) {
        this.appRef.detachView(componentRef.hostView);
        componentRef.destroy();
    }
};
DomProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ComponentFactoryResolver"],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["Injector"],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["ApplicationRef"]])
], DomProvider);

//# sourceMappingURL=dom.js.map

/***/ }),

/***/ 46:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BwcProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client__ = __webpack_require__(1473);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client__);




let BwcProvider = class BwcProvider {
    constructor(logger) {
        this.logger = logger;
        this.parseSecret = __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.parseSecret;
        this.Client = __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a;
        this.logger.debug('BwcProvider initialized');
    }
    getBitcore() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.Bitcore;
    }
    getBitcoreCash() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.BitcoreCash;
    }
    getCore() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.Core;
    }
    getErrors() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.errors;
    }
    getSJCL() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.sjcl;
    }
    getUtils() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.Utils;
    }
    getKey() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.Key;
    }
    getPayProV2() {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.PayProV2;
    }
    upgradeCredentialsV1(x) {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.upgradeCredentialsV1(x);
    }
    upgradeMultipleCredentialsV1(x) {
        return __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a.upgradeMultipleCredentialsV1(x);
    }
    getClient(walletData, opts) {
        opts = opts || {};
        // note opts use `bwsurl` all lowercase;
        let bwc = new __WEBPACK_IMPORTED_MODULE_3_bitcore_wallet_client___default.a({
            baseUrl: opts.bwsurl || 'https://bws.bitpay.com/bws/api',
            verbose: opts.verbose,
            timeout: 100000,
            transports: ['polling'],
            bp_partner: opts.bp_partner,
            bp_partner_version: opts.bp_partner_version
        });
        if (walletData)
            bwc.fromString(walletData);
        return bwc;
    }
};
BwcProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], BwcProvider);

//# sourceMappingURL=bwc.js.map

/***/ }),

/***/ 462:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DownloadProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);




let DownloadProvider = class DownloadProvider {
    constructor(logger) {
        this.logger = logger;
        this.logger.debug('DownloadProvider initialized');
    }
    download(ew, fileName) {
        return new Promise((resolve) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield __WEBPACK_IMPORTED_MODULE_2_rxjs__["Observable"].timer(1000).toPromise();
            let a = document.createElement('a');
            let blob = this.newBlob(ew, 'text/plain;charset=utf-8');
            let url = window.URL.createObjectURL(blob);
            document.body.appendChild(a);
            a.href = url;
            a.download = fileName;
            a.click();
            window.URL.revokeObjectURL(url);
            return resolve();
        }));
    }
    newBlob(data, datatype) {
        let out;
        try {
            this.logger.debug('Trying to blob data');
            out = new Blob([data], {
                type: datatype
            });
        }
        catch (e) {
            if (e.name == 'InvalidStateError') {
                // InvalidStateError (tested on FF13 WinXP)
                this.logger.debug('Invalid state Error: Trying to blob data again');
                out = new Blob([data], {
                    type: datatype
                });
            }
            else {
                // We're screwed, blob constructor unsupported entirely
                this.logger.error('Error: blob constructor unsupported entirely');
            }
        }
        return out;
    }
};
DownloadProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], DownloadProvider);

//# sourceMappingURL=download.js.map

/***/ }),

/***/ 463:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayAccountProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app_identity_app_identity__ = __webpack_require__(317);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__bitpay_bitpay__ = __webpack_require__(246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__replace_parameters_replace_parameters__ = __webpack_require__(101);




// native

// providers








let BitPayAccountProvider = class BitPayAccountProvider {
    /*
     * Pair this app with the bitpay server using the specified pairing data.
     * An app identity will be created if one does not already exist.
     * Pairing data is provided by an input URI provided by the bitpay server.
     *
     * pairData - data needed to complete the pairing process
     * {
     *   secret: shared pairing secret
     *   email: email address associated with bitpay account
     *   otp: two-factor one-time use password
     * }
     *
     * pairingReason - text string to be embedded into popup message.  If `null` then the reason
     * message is not shown to the UI.
     *   "To {{reason}} you must pair this app with your BitPay account ({{email}})."
     *
     * cb - callback after completion
     *   callback(err, paired, apiContext)
     *
     *   err - something unexpected happened which prevented the pairing
     *
     *   paired - boolean indicating whether the pairing was compledted by the user
     *
     *   apiContext - the context needed for making future api calls
     *   {
     *     token: api token for use in future calls
     *     pairData: the input pair data
     *     appIdentity: the identity of this app
     *   }
     */
    constructor(platformProvider, replaceParametersProvider, bitPayProvider, logger, onGoingProcessProvider, popupProvider, persistenceProvider, appIdentityProvider, device, translate) {
        this.platformProvider = platformProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.bitPayProvider = bitPayProvider;
        this.logger = logger;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.persistenceProvider = persistenceProvider;
        this.appIdentityProvider = appIdentityProvider;
        this.device = device;
        this.translate = translate;
        this.logger.debug('BitPayAccountProvider initialized');
    }
    pair(pairData, pairingReason, cb) {
        this.checkOtp(pairData, otp => {
            pairData.otp = otp;
            let deviceName = 'Unknown device';
            if (this.platformProvider.isElectron) {
                deviceName = this.platformProvider.getOS().OSName;
            }
            else if (this.platformProvider.isCordova) {
                deviceName = this.device.model;
            }
            let json = {
                method: 'createToken',
                params: {
                    secret: pairData.secret,
                    version: 2,
                    deviceName,
                    code: pairData.otp
                }
            };
            this.onGoingProcessProvider.set('fetchingBitPayAccount');
            this.bitPayProvider.postAuth(json, data => {
                if (data && data.error) {
                    this.onGoingProcessProvider.clear();
                    return cb(data.error);
                }
                let apiContext = {
                    token: data.data,
                    pairData,
                    appIdentity: data.appIdentity
                };
                this.logger.info('BitPay service BitAuth create token: SUCCESS');
                this.fetchBasicInfo(apiContext, (err, basicInfo) => {
                    this.onGoingProcessProvider.clear();
                    if (err)
                        return cb(err);
                    let title = this.translate.instant('Add BitPay Account?');
                    let msg;
                    if (pairingReason) {
                        let reason = pairingReason;
                        let email = pairData.email;
                        msg = this.replaceParametersProvider.replace(this.translate.instant('To {{reason}} you must first add your BitPay account - {{email}}'), { reason, email });
                    }
                    else {
                        let email = pairData.email;
                        msg = this.replaceParametersProvider.replace(this.translate.instant('Add this BitPay account ({{email}})?'), { email });
                    }
                    let ok = this.translate.instant('Add account');
                    let cancel = this.translate.instant('Go Back');
                    this.popupProvider
                        .ionicConfirm(title, msg, ok, cancel)
                        .then(res => {
                        if (res) {
                            let acctData = {
                                token: apiContext.token,
                                email: pairData.email,
                                givenName: basicInfo.givenName,
                                familyName: basicInfo.familyName
                            };
                            this.setBitpayAccount(acctData);
                            return cb(null, true, apiContext);
                        }
                        else {
                            this.logger.info('User cancelled BitPay pairing process');
                            return cb(null, false);
                        }
                    });
                });
            }, data => {
                return cb(this._setError('BitPay service BitAuth create token: ERROR ', data));
            });
        });
    }
    checkOtp(pairData, cb) {
        if (pairData.otp) {
            let msg = this.translate.instant('Enter Two Factor for your BitPay account');
            this.popupProvider.ionicPrompt(null, msg, null).then(res => {
                cb(res);
            });
        }
        else {
            cb();
        }
    }
    fetchBasicInfo(apiContext, cb) {
        let json = {
            method: 'getBasicInfo'
        };
        // Get basic account information
        this.bitPayProvider.post('/api/v2/' + apiContext.token, json, data => {
            if (data && data.error)
                return cb(data.error);
            this.logger.info('BitPay Account Get Basic Info: SUCCESS');
            return cb(null, data.data);
        }, data => {
            return cb(this._setError('BitPay Account Error: Get Basic Info', data));
        });
    }
    // Returns account objects as stored.
    getAccountsAsStored(cb) {
        this.persistenceProvider
            .getBitpayAccounts(this.bitPayProvider.getEnvironment().network)
            .then(accounts => {
            return cb(null, accounts);
        })
            .catch(err => {
            return cb(err, []);
        });
    }
    // Returns an array where each element represents an account including all information required for fetching data
    // from the server for each account (apiContext).
    getAccounts(cb) {
        this.getAccountsAsStored((err, accounts) => {
            if (err || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](accounts)) {
                return cb(err, []);
            }
            this.appIdentityProvider.getIdentity(this.bitPayProvider.getEnvironment().network, (err, appIdentity) => {
                if (err) {
                    return cb(err);
                }
                let accountsArray = [];
                __WEBPACK_IMPORTED_MODULE_3_lodash__["forEach"](Object.keys(accounts), key => {
                    accounts[key].cards = accounts[key].cards;
                    accounts[key].email = key;
                    accounts[key].givenName = accounts[key].givenName || '';
                    accounts[key].familyName = accounts[key].familyName || '';
                    accounts[key].apiContext = {
                        token: accounts[key].token,
                        pairData: {
                            email: key
                        },
                        appIdentity
                    };
                    accountsArray.push(accounts[key]);
                });
                return cb(null, accountsArray);
            });
        });
    }
    setBitpayAccount(account) {
        this.persistenceProvider.setBitpayAccount(this.bitPayProvider.getEnvironment().network, account);
    }
    removeAccount(email, cb) {
        this.persistenceProvider
            .removeBitpayAccount(this.bitPayProvider.getEnvironment().network, email)
            .then(() => {
            return cb();
        });
    }
    _setError(msg, e) {
        this.logger.error(msg);
        let error = e && e.data && e.data.error ? e.data.error : msg;
        return error;
    }
};
BitPayAccountProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_12__replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_6__bitpay_bitpay__["a" /* BitPayProvider */],
        __WEBPACK_IMPORTED_MODULE_7__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_11__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_9__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_5__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__["a" /* Device */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], BitPayAccountProvider);

//# sourceMappingURL=bitpay-account.js.map

/***/ }),

/***/ 464:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeedbackProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);



// providers


let FeedbackProvider = class FeedbackProvider {
    constructor(http, logger, appProvider) {
        this.http = http;
        this.logger = logger;
        this.appProvider = appProvider;
        // Get more info: https://mashe.hawksey.info/2014/07/google-sheets-as-a-database-insert-with-apps-script-using-postget-methods-with-ajax-example/
        this.URL =
            this.appProvider.servicesInfo &&
                this.appProvider.servicesInfo.feedbackSheetURL
                ? this.appProvider.servicesInfo.feedbackSheetURL
                : null;
    }
    send(dataSrc) {
        return new Promise((resolve, reject) => {
            if (!this.URL)
                return resolve();
            const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            });
            const urlSearchParams = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["d" /* HttpParams */]()
                .set('Email', dataSrc.email)
                .set('Feedback', dataSrc.feedback)
                .set('Score', dataSrc.score)
                .set('AppVersion', dataSrc.appVersion)
                .set('Platform', dataSrc.platform)
                .set('DeviceVersion', dataSrc.deviceVersion);
            this.http
                .post(this.URL, null, {
                params: urlSearchParams,
                headers
            })
                .subscribe(() => {
                this.logger.info('SUCCESS: Feedback sent');
                return resolve();
            }, err => {
                this.logger.warn('ERROR: Feedback sent anyway.');
                return reject(err);
            });
        });
    }
    isVersionUpdated(currentVersion, savedVersion) {
        let verifyTagFormat = tag => {
            let regex = /^v?\d+\.\d+\.\d+$/i;
            return regex.exec(tag);
        };
        let formatTagNumber = tag => {
            let formattedNumber = tag.replace(/^v/i, '').split('.');
            return {
                major: +formattedNumber[0],
                minor: +formattedNumber[1],
                patch: +formattedNumber[2]
            };
        };
        if (!verifyTagFormat(currentVersion)) {
            return 'Cannot verify the format of version tag: ' + currentVersion;
        }
        if (!verifyTagFormat(savedVersion)) {
            return ('Cannot verify the format of the saved version tag: ' + savedVersion);
        }
        let current = formatTagNumber(currentVersion);
        let saved = formatTagNumber(savedVersion);
        if (saved.major == current.major) {
            return true;
        }
        return false;
    }
};
FeedbackProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__providers_app_app__["a" /* AppProvider */]])
], FeedbackProvider);

//# sourceMappingURL=feedback.js.map

/***/ }),

/***/ 466:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxConfirmNotificationProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__persistence_persistence__ = __webpack_require__(39);



// providers

let TxConfirmNotificationProvider = class TxConfirmNotificationProvider {
    constructor(logger, persistenceProvider) {
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.logger.debug('TxConfirmNotificationProvider initialized');
    }
    checkIfEnabled(txid) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getTxConfirmNotification(txid)
                .then(res => {
                return resolve(!!res);
            })
                .catch(err => {
                this.logger.error(err);
                return reject(err);
            });
        });
    }
    subscribe(client, opts) {
        client.txConfirmationSubscribe(opts, err => {
            if (err)
                this.logger.error(err);
            this.persistenceProvider
                .setTxConfirmNotification(opts.txid, true)
                .catch(err => {
                this.logger.error(err);
                return;
            });
        });
    }
    unsubscribe(client, txId) {
        client.txConfirmationUnsubscribe(txId, err => {
            if (err)
                this.logger.error(err);
            this.persistenceProvider.removeTxConfirmNotification(txId).catch(err => {
                this.logger.error(err);
                return;
            });
        });
    }
};
TxConfirmNotificationProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__persistence_persistence__["b" /* PersistenceProvider */]])
], TxConfirmNotificationProvider);

//# sourceMappingURL=tx-confirm-notification.js.map

/***/ }),

/***/ 467:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PaperWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__finish_finish__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__tabs_tabs__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_fee_fee__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_wallet_wallet__ = __webpack_require__(32);





// pages


// providers










let PaperWalletPage = class PaperWalletPage {
    constructor(app, actionSheetProvider, navCtrl, navParams, bwcProvider, onGoingProcessProvider, popupProvider, logger, walletProvider, feeProvider, profileProvider, modalCtrl, translate, platformProvider, bwcErrorProvider) {
        this.app = app;
        this.actionSheetProvider = actionSheetProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.bwcProvider = bwcProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.feeProvider = feeProvider;
        this.profileProvider = profileProvider;
        this.modalCtrl = modalCtrl;
        this.translate = translate;
        this.platformProvider = platformProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.wallet = {};
        this.balances = [];
        this.bitcore = this.bwcProvider.getBitcore();
        this.isCordova = this.platformProvider.isCordova;
        this.isOpenSelector = false;
        this.scannedKey = this.navParams.data.privateKey;
        this.isPkEncrypted = this.scannedKey
            ? this.scannedKey.substring(0, 2) == '6P'
            : null;
        this.error = false;
        this.wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: 'livenet'
        });
        this.wallets = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](this.wallets), wallet => {
            return !wallet.needsBackup && wallet.coin !== 'eth';
        });
        this.coins = __WEBPACK_IMPORTED_MODULE_4_lodash__["uniq"](__WEBPACK_IMPORTED_MODULE_4_lodash__["map"](this.wallets, (wallet) => wallet.coin));
        for (const coin of this.coins) {
            this.wallet[coin] = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.wallets, w => {
                return w.coin == coin;
            })[0];
        }
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.navCtrl.swipeBackEnabled = false;
    }
    ionViewDidEnter() {
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.wallets)) {
            this.popupProvider
                .ionicAlert('Error', this.translate.instant('No wallets available to receive funds'))
                .then(() => {
                this.navCtrl.pop();
            });
            return;
        }
        if (!this.isPkEncrypted) {
            this.onGoingProcessProvider.set('scanning');
            setTimeout(() => {
                this.scanFunds();
            }, 200);
        }
        else {
            let message = this.translate.instant('Private key encrypted. Enter password');
            let opts = {
                type: 'password',
                enableBackdropDismiss: false
            };
            this.popupProvider.ionicPrompt(null, message, opts).then(res => {
                if (res === null) {
                    this.navCtrl.popToRoot();
                    return;
                }
                this.passphrase = res;
                this.onGoingProcessProvider.set('scanning');
                setTimeout(() => {
                    this.scanFunds();
                }, 200);
            });
        }
    }
    getPrivateKey(scannedKey, privateKeyIsEncrypted, passphrase, coin, cb) {
        if (!privateKeyIsEncrypted) {
            return cb(null, scannedKey);
        }
        this.wallet[coin].decryptBIP38PrivateKey(scannedKey, passphrase, null, cb);
    }
    getBalance(privateKey, coin, cb) {
        this.wallet[coin].getBalanceFromPrivateKey(privateKey, coin, cb);
    }
    checkPrivateKey(privateKey) {
        try {
            new this.bitcore.PrivateKey(privateKey, 'livenet');
        }
        catch (err) {
            return false;
        }
        return true;
    }
    _scanFunds(coin) {
        return new Promise((resolve, reject) => {
            this.getPrivateKey(this.scannedKey, this.isPkEncrypted, this.passphrase, coin, (err, privateKey) => {
                if (err)
                    return reject(err);
                if (!this.checkPrivateKey(privateKey))
                    return reject(new Error('Invalid private key'));
                this.getBalance(privateKey, coin, (err, balance) => {
                    if (err)
                        return reject(err);
                    return resolve({ privateKey, coin, balance });
                });
            });
        });
    }
    scanFunds() {
        let scans = __WEBPACK_IMPORTED_MODULE_4_lodash__["map"](this.coins, (coin) => this._scanFunds(coin));
        Promise.all(scans)
            .then(data => {
            this.onGoingProcessProvider.clear();
            __WEBPACK_IMPORTED_MODULE_4_lodash__["each"](data, d => {
                this.balances.push(d);
            });
            let available = {};
            this.balances = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](this.balances), b => {
                let nonzero = b.balance > 0;
                available[b.coin] = nonzero;
                return nonzero;
            });
            this.wallets = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](this.wallets), w => available[w.coin]);
            this.selectedWallet = this.wallets[0];
            if (this.balances.length == 0) {
                this.popupProvider
                    .ionicAlert('Error', this.translate.instant('No funds found'))
                    .then(() => {
                    this.navCtrl.pop();
                });
            }
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error(err);
            this.popupProvider
                .ionicAlert(this.translate.instant('Error scanning funds:'), this.bwcErrorProvider.msg(err))
                .then(() => {
                this.navCtrl.pop();
            });
        });
    }
    _sweepWallet() {
        return new Promise((resolve, reject) => {
            let balanceToSweep = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](this.balances, b => {
                return b.coin === this.selectedWallet.coin;
            })[0];
            this.walletProvider
                .getAddress(this.selectedWallet, true)
                .then((destinationAddress) => {
                let opts = {};
                opts.coin = balanceToSweep.coin;
                this.selectedWallet.buildTxFromPrivateKey(balanceToSweep.privateKey, destinationAddress, opts, (err, testTx) => {
                    if (err)
                        return reject(err);
                    let rawTxLength = testTx.serialize().length;
                    this.feeProvider
                        .getFeeRate(balanceToSweep.coin, 'livenet', this.feeProvider.getCurrentFeeLevel())
                        .then((feePerKb) => {
                        opts.fee = Math.round((feePerKb * rawTxLength) / 2000);
                        this.selectedWallet.buildTxFromPrivateKey(balanceToSweep.privateKey, destinationAddress, opts, (err, tx) => {
                            if (err)
                                return reject(err);
                            this.selectedWallet.broadcastRawTx({
                                rawTx: tx.serialize(),
                                network: 'livenet',
                                coin: balanceToSweep.coin
                            }, (err, txid) => {
                                if (err)
                                    return reject(err);
                                return resolve({ destinationAddress, txid });
                            });
                        });
                    });
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    sweepWallet() {
        this.onGoingProcessProvider.set('sweepingWallet');
        this._sweepWallet()
            .then(data => {
            this.onGoingProcessProvider.clear();
            this.logger.debug('Success sweep. Destination address:' +
                data.destinationAddress +
                ' - transaction id: ' +
                data.txid);
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error(err);
            this.popupProvider.ionicAlert(this.translate.instant('Error sweeping wallet:'), this.bwcErrorProvider.msg(err));
        });
    }
    onWalletSelect(wallet) {
        this.selectedWallet = wallet;
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.selectedWallet
            ? this.selectedWallet.credentials.walletId
            : null;
        const params = {
            wallets: this.wallets,
            selectedWalletId: id,
            title: 'Transfer to'
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.isOpenSelector = false;
        });
    }
    openFinishModal() {
        let finishComment = this.translate.instant('Check the transaction on your wallet details');
        let finishText = this.translate.instant('Sweep Completed');
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_5__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => {
            // using setRoot(TabsPage) as workaround when coming from scanner
            this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_6__tabs_tabs__["a" /* TabsPage */]);
            this.navCtrl.popToRoot();
        });
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], PaperWalletPage.prototype, "slideButton", void 0);
PaperWalletPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-paper-wallet',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/paper-wallet/paper-wallet.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Sweep paper wallet\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <h4 class="title" *ngIf="balances && balances.length > 0">\n    <span translate>Funds found</span>:\n    <div *ngFor="let b of balances">\n      {{b.balance | satToUnit: b.coin}}\n    </div>\n  </h4>\n  <div *ngIf="selectedWallet">\n    <ion-item-divider>{{\'Funds will be transferred to\' | translate}}</ion-item-divider>\n    <button ion-item detail-none (click)="showWallets()">\n      <ion-icon item-start>\n        <img class="icon-wallet" [ngClass]="{ testnet: selectedWallet.network === \'testnet\' }" src="assets/img/currencies/{{selectedWallet.coin}}.svg" />\n      </ion-icon>\n      <h2>{{selectedWallet.name}}\n        <span *ngIf="selectedWallet.credentials.m > 1">{{selectedWallet.credentials.m}}-{{selectedWallet.credentials.n}}</span>\n      </h2>\n      <span *ngIf="!selectedWallet.balanceHidden"> {{selectedWallet.cachedStatus.totalBalanceStr}} </span>\n      <span *ngIf="selectedWallet.balanceHidden" translate>[Balance Hidden]</span>\n      <span class="assertive" *ngIf="error">{{error}}</span>\n      <div item-end>\n        <button ion-button clear color="grey" icon-only>\n          <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n          <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n        </button>\n      </div>\n    </button>\n  </div>\n</ion-content>\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="balances.length == 0" buttonText="{{\'Sweep\' | translate}}" (slideDone)="sweepWallet()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button block class="button-footer" (click)="sweepWallet()" [disabled]="balances.length == 0">\n      {{\'Sweep\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/paper-wallet/paper-wallet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_16__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */]])
], PaperWalletPage);

//# sourceMappingURL=paper-wallet.js.map

/***/ }),

/***/ 468:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfirmCardPurchasePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__finish_finish__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__send_confirm_confirm__ = __webpack_require__(249);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__gift_cards_card_details_card_details__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__purchased_cards_purchased_cards__ = __webpack_require__(329);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__angular_common__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_clipboard_clipboard__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_paypro_paypro__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_replace_parameters_replace_parameters__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_wallet_wallet__ = __webpack_require__(32);








// Pages




// Provider




















let ConfirmCardPurchasePage = class ConfirmCardPurchasePage extends __WEBPACK_IMPORTED_MODULE_9__send_confirm_confirm__["a" /* ConfirmPage */] {
    constructor(addressProvider, app, actionSheetProvider, bwcErrorProvider, bwcProvider, configProvider, currencyProvider, decimalPipe, feeProvider, giftCardProvider, incomingDataProvider, keyProvider, replaceParametersProvider, emailNotificationsProvider, externalLinkProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, popupProvider, profileProvider, txConfirmNotificationProvider, txFormatProvider, walletProvider, translate, payproProvider, platformProvider, walletTabsProvider, clipboardProvider, events, AppProvider, statusBar) {
        super(addressProvider, app, actionSheetProvider, bwcErrorProvider, bwcProvider, configProvider, currencyProvider, decimalPipe, externalLinkProvider, feeProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, platformProvider, profileProvider, popupProvider, replaceParametersProvider, translate, txConfirmNotificationProvider, txFormatProvider, walletProvider, walletTabsProvider, clipboardProvider, events, AppProvider, keyProvider, statusBar);
        this.giftCardProvider = giftCardProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.payproProvider = payproProvider;
        this.displayNameIncludesGiftCard = false;
        this.hideSlideButton = false;
        this.configWallet = this.configProvider.get().wallet;
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.amount = this.navParams.data.amount;
            this.currency = this.navParams.data.currency;
            this.cardConfig = yield this.giftCardProvider.getCardConfig(this.navParams.get('cardName'));
            this.displayNameIncludesGiftCard = this.cardConfig.displayName
                .toLowerCase()
                .includes('gift card');
            this.onlyIntegers = this.cardConfig.currency === 'JPY';
            this.activationFee = Object(__WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__["b" /* getActivationFee */])(this.amount, this.cardConfig);
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ConfirmCardPurchasePage');
    }
    ionViewWillEnter() {
        if (this.navCtrl.getPrevious().name == 'SelectInvoicePage') {
            this.navCtrl.remove(this.navCtrl.getPrevious().index);
        }
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.network = this.giftCardProvider.getNetwork();
        this.wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            hasFunds: true
        });
        if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](this.wallets)) {
            this.showErrorInfoSheet(this.translate.instant('No wallets available'), null, true);
            return;
        }
        this.showWallets(); // Show wallet selector
    }
    logGiftCardPurchaseEvent(isSlideConfirmFinished, transactionCurrency, giftData) {
        if (!isSlideConfirmFinished) {
            this.giftCardProvider.logEvent('giftcards_purchase_start', {
                brand: this.cardConfig.name,
                usdAmount: this.amount,
                transactionCurrency
            });
            this.giftCardProvider.logEvent('add_to_cart', {
                brand: this.cardConfig.name,
                category: 'giftCards'
            });
        }
        else {
            this.giftCardProvider.logEvent('giftcards_purchase_finish', {
                brand: this.cardConfig.name,
                usdAmount: this.amount,
                transactionCurrency
            });
            this.giftCardProvider.logEvent('set_checkout_option', {
                transactionCurrency,
                checkout_step: 1
            });
            this.giftCardProvider.logEvent('purchase', {
                value: giftData.amount,
                items: [
                    {
                        name: this.cardConfig.name,
                        category: 'giftCards',
                        quantity: 1,
                        price: giftData.amount.toString(10)
                    }
                ]
            });
        }
    }
    cancel() {
        this.navCtrl.popToRoot();
    }
    checkFeeHigh(amount, fee) {
        if (this.isHighFee(amount, fee)) {
            this.showHighFeeSheet();
        }
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    resetValues() {
        this.totalAmountStr = this.invoiceFee = this.networkFee = this.totalAmount = this.wallet = null;
        this.tx = this.message = this.invoiceId = null;
    }
    publishAndSign(wallet, txp) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (!wallet.canSign) {
                const err = this.translate.instant('No signing proposal: No private key');
                return Promise.reject(err);
            }
            if (wallet.isPrivKeyEncrypted) {
                this.hideSlideButton = true;
            }
            yield this.walletProvider.publishAndSign(wallet, txp);
            this.hideSlideButton = false;
            return this.onGoingProcessProvider.clear();
        });
    }
    satToFiat(coin, sat) {
        return this.txFormatProvider.toFiat(coin, sat, this.currencyIsoCode);
    }
    setTotalAmount(wallet, amountSat, invoiceFeeSat, networkFeeSat) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const amount = yield this.satToFiat(wallet.coin, amountSat);
            this.amount = Number(amount);
            const invoiceFee = yield this.satToFiat(wallet.coin, invoiceFeeSat);
            this.invoiceFee = Number(invoiceFee);
            const chain = this.currencyProvider.getChain(wallet.coin).toLowerCase();
            const networkFee = yield this.satToFiat(chain, networkFeeSat);
            this.networkFee = Number(networkFee);
            this.totalAmount =
                this.amount -
                    this.totalDiscount +
                    this.activationFee +
                    this.invoiceFee +
                    this.networkFee;
        });
    }
    isCryptoCurrencySupported(wallet, invoice) {
        const COIN = wallet.coin.toUpperCase();
        return ((invoice['supportedTransactionCurrencies'][COIN] &&
            invoice['supportedTransactionCurrencies'][COIN].enabled) ||
            false);
    }
    handleCreateInvoiceError(err) {
        let err_title = this.translate.instant('Error creating the invoice');
        let err_msg;
        const errMessage = err && err.error && err.error.message;
        if (errMessage && errMessage.match(/suspended/i)) {
            err_title = this.translate.instant('Service not available');
            err_msg = this.translate.instant(`${this.cardConfig.displayName} gift card purchases are not available at this time. Please try again later.`);
        }
        else if (errMessage) {
            err_msg = errMessage;
        }
        else {
            err_msg = this.translate.instant(`Unable to complete your purchase at this time. Please try again later.`);
        }
        throw {
            title: err_title,
            message: err_msg
        };
    }
    createInvoice(data) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const cardOrder = yield this.giftCardProvider
                .createBitpayInvoice(data)
                .catch(err => {
                throw this.handleCreateInvoiceError(err);
            });
            const accessKey = cardOrder && cardOrder.accessKey;
            const totalDiscount = cardOrder && cardOrder.totalDiscount;
            if (!accessKey) {
                throw {
                    message: this.translate.instant('No access key defined')
                };
            }
            const invoice = yield this.giftCardProvider
                .getBitPayInvoice(cardOrder.invoiceId)
                .catch(() => {
                throw {
                    message: this.translate.instant('Could not get the invoice')
                };
            });
            return { invoice, accessKey, totalDiscount };
        });
    }
    createTx(wallet, invoice, message) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const COIN = wallet.coin.toUpperCase();
            const paymentCode = this.currencyProvider.getPaymentCode(wallet.coin);
            const protocolUrl = invoice.paymentCodes[COIN][paymentCode];
            const payProUrl = this.incomingDataProvider.getPayProUrl(protocolUrl);
            if (!payProUrl) {
                throw {
                    title: this.translate.instant('Error in Payment Protocol'),
                    message: this.translate.instant('Invalid URL')
                };
            }
            const details = yield this.payproProvider
                .getPayProDetails(payProUrl, wallet.coin)
                .catch(err => {
                throw {
                    title: this.translate.instant('Error in Payment Protocol'),
                    message: err
                };
            });
            const { instructions } = details;
            const txp = {
                coin: wallet.coin,
                amount: __WEBPACK_IMPORTED_MODULE_5_lodash__["sumBy"](instructions, 'amount'),
                toAddress: instructions[0].toAddress,
                outputs: [],
                message,
                customData: {
                    giftCardName: this.cardConfig.name,
                    service: 'giftcards'
                },
                payProUrl,
                excludeUnconfirmedUtxos: this.configWallet.spendUnconfirmed ? false : true
            };
            for (const instruction of instructions) {
                txp.outputs.push({
                    toAddress: instruction.toAddress,
                    amount: instruction.amount,
                    message: instruction.message,
                    data: instruction.data
                });
            }
            if (wallet.credentials.token) {
                txp.tokenAddress = wallet.credentials.token.address;
            }
            if (details.requiredFeeRate) {
                const requiredFeeRate = !this.currencyProvider.isUtxoCoin(wallet.coin)
                    ? details.requiredFeeRate
                    : Math.ceil(details.requiredFeeRate * 1024);
                txp.feePerKb = requiredFeeRate;
                this.logger.debug('Using merchant fee rate:' + txp.feePerKb);
            }
            else {
                txp.feeLevel = this.configWallet.settings.feeLevel || 'normal';
            }
            txp['origToAddress'] = txp.toAddress;
            if (wallet.coin && wallet.coin == 'bch') {
                txp.toAddress = this.bitcoreCash.Address(txp.toAddress).toString(true);
                txp.outputs[0].toAddress = txp.toAddress;
            }
            return this.walletProvider
                .getAddress(this.wallet, false)
                .then(address => {
                txp.from = address;
                return this.walletProvider.createTx(wallet, txp);
            })
                .catch(err => {
                throw {
                    title: this.translate.instant('Could not create transaction'),
                    message: this.bwcErrorProvider.msg(err)
                };
            });
        });
    }
    redeemGiftCard(initialCard) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.onGoingProcessProvider.set('buyingGiftCard');
            const card = yield this.giftCardProvider
                .createGiftCard(initialCard)
                .catch(() => (Object.assign({}, initialCard, { status: 'FAILURE' })));
            yield this.giftCardProvider.saveGiftCard(card);
            this.onGoingProcessProvider.clear();
            this.logger.debug('Saved new gift card with status: ' + card.status);
            this.logDiscountedPurchase();
            this.finish(card);
        });
    }
    logDiscountedPurchase() {
        if (!Object(__WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__["d" /* getVisibleDiscount */])(this.cardConfig))
            return;
        const params = Object.assign({}, this.giftCardProvider.getDiscountEventParams(this.cardConfig), { discounted: true });
        this.giftCardProvider.logEvent('purchasedGiftCard', params);
    }
    promptEmail() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (!this.cardConfig.emailRequired) {
                const notificationEmail = this.emailNotificationsProvider.getEmailIfEnabled();
                return Promise.resolve(notificationEmail);
            }
            const email = yield this.giftCardProvider.getUserEmail();
            if (email)
                return Promise.resolve(email);
            const title = this.translate.instant('Enter email address');
            const message = this.translate.instant('Where do you want to receive your purchase receipt?');
            const opts = { type: 'email', defaultText: '' };
            const newEmail = yield this.popupProvider.ionicPrompt(title, message, opts);
            if (!this.giftCardProvider.emailIsValid(newEmail)) {
                this.throwEmailRequiredError();
            }
            this.giftCardProvider.storeEmail(newEmail);
            return newEmail;
        });
    }
    throwEmailRequiredError() {
        const title = this.translate.instant('Error');
        const msg = this.translate.instant('An email address is required for this purchase.');
        this.onGoingProcessProvider.clear();
        this.showErrorInfoSheet(msg, title, true);
        throw new Error('email required');
    }
    initialize(wallet) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const COIN = wallet.coin.toUpperCase();
            const parsedAmount = this.txFormatProvider.parseAmount(wallet.coin, this.amount, this.currency, this.onlyIntegers);
            this.currencyIsoCode = parsedAmount.currency;
            this.amountUnitStr = parsedAmount.amountUnitStr;
            const email = yield this.promptEmail();
            this.hideSlideButton = false;
            const discount = Object(__WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__["d" /* getVisibleDiscount */])(this.cardConfig);
            const dataSrc = {
                amount: parsedAmount.amount,
                currency: parsedAmount.currency,
                discounts: discount ? [discount.code] : [],
                uuid: wallet.id,
                email,
                buyerSelectedTransactionCurrency: COIN,
                cardName: this.cardConfig.name
            };
            this.onGoingProcessProvider.set('loadingTxInfo');
            const data = yield this.createInvoice(dataSrc).catch(err => {
                this.onGoingProcessProvider.clear();
                throw this.showErrorInfoSheet(err.message, err.title, true);
            });
            const invoice = data.invoice;
            const accessKey = data.accessKey;
            this.totalDiscount = data.totalDiscount || 0;
            if (!this.isCryptoCurrencySupported(wallet, invoice)) {
                this.onGoingProcessProvider.clear();
                let msg = this.translate.instant('Purchases with this cryptocurrency are not enabled');
                this.showErrorInfoSheet(msg, null, true);
                return;
            }
            // Sometimes API does not return this element;
            invoice['minerFees'][COIN]['totalFee'] =
                invoice.minerFees[COIN].totalFee || 0;
            let invoiceFeeSat = invoice.minerFees[COIN].totalFee;
            this.message = this.replaceParametersProvider.replace(this.translate.instant(`{{amountUnitStr}} Gift Card`), { amountUnitStr: this.amountUnitStr });
            const ctxp = yield this.createTx(wallet, invoice, this.message).catch(err => {
                this.onGoingProcessProvider.clear();
                this.resetValues();
                throw this.showErrorInfoSheet(err.message, err.title);
            });
            this.onGoingProcessProvider.clear();
            // Save in memory
            this.tx = ctxp;
            this.invoiceId = invoice.id;
            const now = __WEBPACK_IMPORTED_MODULE_6_moment__().unix() * 1000;
            this.tx.giftData = {
                currency: dataSrc.currency,
                date: now,
                amount: dataSrc.amount,
                uuid: dataSrc.uuid,
                accessKey,
                invoiceId: invoice.id,
                invoiceUrl: invoice.url,
                invoiceTime: invoice.invoiceTime,
                name: this.cardConfig.name
            };
            this.totalAmountStr = this.txFormatProvider.formatAmountStr(wallet.coin, ctxp.amount || parsedAmount.amountSat);
            // Warn: fee too high
            if (this.currencyProvider.isUtxoCoin(wallet.coin)) {
                this.checkFeeHigh(Number(parsedAmount.amountSat), Number(invoiceFeeSat) + Number(ctxp.fee));
            }
            this.setTotalAmount(wallet, parsedAmount.amountSat, invoiceFeeSat, ctxp.fee);
            this.logGiftCardPurchaseEvent(false, COIN, dataSrc);
        });
    }
    buyConfirm() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (!this.tx) {
                this.showErrorInfoSheet(this.translate.instant('Transaction has not been created'));
                return;
            }
            yield this.giftCardProvider.saveGiftCard(Object.assign({}, this.tx.giftData, { status: 'UNREDEEMED' }));
            return this.publishAndSign(this.wallet, this.tx)
                .then(() => {
                this.redeemGiftCard(this.tx.giftData);
                this.logGiftCardPurchaseEvent(true, this.wallet.coin.toUpperCase(), this.tx.giftData);
            })
                .catch((err) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () { return this.handlePurchaseError(err); }));
        });
    }
    handlePurchaseError(err) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.onGoingProcessProvider.clear();
            yield this.giftCardProvider.saveCard(this.tx.giftData, {
                remove: true
            });
            yield this.walletProvider.removeTx(this.wallet, this.tx);
            const errorMessage = err && err.message;
            const canceledErrors = ['FINGERPRINT_CANCELLED', 'PASSWORD_CANCELLED'];
            if (canceledErrors.indexOf(errorMessage) !== -1) {
                return;
            }
            if (['NO_PASSWORD', 'WRONG_PASSWORD'].indexOf(errorMessage) === -1) {
                this.resetValues();
            }
            this.showErrorInfoSheet(this.bwcErrorProvider.msg(err), this.translate.instant('Could not send transaction'));
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        this.initialize(wallet).catch(() => { });
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        const params = {
            wallets: this.wallets,
            selectedWalletId: id,
            title: this.translate.instant('Buy from')
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.isOpenSelector = false;
        });
    }
    finish(card) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            let finishComment;
            let cssClass;
            if (card.status == 'FAILURE') {
                finishComment = this.translate.instant('Your purchase could not be completed.');
                cssClass = 'danger';
            }
            if (card.status == 'PENDING') {
                finishComment = this.translate.instant('Your purchase is pending.');
                cssClass = 'warning';
            }
            if (card.status == 'SUCCESS') {
                finishComment = this.translate.instant('Gift card generated and ready to use.');
            }
            let finishText = '';
            let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_8__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment, cssClass }, { showBackdrop: true, enableBackdropDismiss: false });
            yield modal.present();
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            const numActiveCards = yield this.getNumActiveCards();
            if (numActiveCards > 1) {
                yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__purchased_cards_purchased_cards__["b" /* PurchasedCardsPage */], { cardName: card.name }, { animate: false });
            }
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__gift_cards_card_details_card_details__["a" /* CardDetailsPage */], { card }, { animate: false });
        });
    }
    getNumActiveCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const allGiftCards = yield this.giftCardProvider.getPurchasedCards(this.cardConfig.name);
            const currentGiftCards = allGiftCards.filter(c => !c.archived);
            return currentGiftCards.length;
        });
    }
};
ConfirmCardPurchasePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'confirm-card-purchase-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/confirm-card-purchase/confirm-card-purchase.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Confirm\' | translate}}</ion-title>\n    <ion-buttons right>\n      <button (click)="cancel()" ion-button>{{\'Cancel\' | translate}}</button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list class="bp-list">\n    <ion-item class="confirm-header">\n      <div class="confirm-header__amount">\n        <div class="gift-card-title">\n          {{cardConfig?.displayName}}<span *ngIf="!displayNameIncludesGiftCard">&nbsp;Gift Card</span>\n        </div>\n        <div class="amount-label">\n          <div class="amount">{{amount | formatCurrency:currency}}</div>\n        </div>\n      </div>\n      <img-loader class="card-list-item__icon" [src]="cardConfig?.icon"></img-loader>\n    </ion-item>\n    <ion-item-group class="info">\n      <button ion-item detail-none (click)="showWallets()" class="wallets-list">\n        <div>{{\'Sending From\' | translate}}</div>\n        <div class="wallet">\n          <ion-icon *ngIf="wallet && wallet.coin" item-start>\n            <img [ngClass]="{ testnet: network === \'testnet\' }" src="assets/img/currencies/{{wallet.coin}}.svg"\n              class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n      <div *ngIf="totalAmountStr">\n        <ion-item-divider>\n          {{\'Details\' | translate}}\n        </ion-item-divider>\n        <ion-item>\n          <span>{{\'Gift Card\' | translate}}</span>\n          <ion-note item-end>\n            <span *ngIf="onlyIntegers">{{amount | number : \'1.0-0\'}}</span>\n            <span *ngIf="!onlyIntegers">{{amount | number : \'1.2-2\'}}</span>\n            {{currencyIsoCode}}\n          </ion-note>\n        </ion-item>\n        <ion-item *ngIf="activationFee">\n          <span>{{\'Activation Fee\' | translate}}</span>\n          <ion-note item-end>\n            <span *ngIf="onlyIntegers">{{activationFee | number : \'1.0-0\'}}</span>\n            <span *ngIf="!onlyIntegers">{{activationFee | number : \'1.2-2\'}}</span>\n            {{currencyIsoCode}}\n          </ion-note>\n        </ion-item>\n        <ion-item *ngIf="totalDiscount">\n          <span>{{\'Discount\' | translate}}</span>\n          <ion-note item-end>\n            <span *ngIf="onlyIntegers">-{{totalDiscount | number : \'1.0-0\'}}</span>\n            <span *ngIf="!onlyIntegers">-{{totalDiscount | number : \'1.2-2\'}}</span>\n            {{currencyIsoCode}}\n          </ion-note>\n        </ion-item>\n        <ion-item *ngIf="invoiceFee">\n          <span>{{\'Network cost\' | translate}}</span>\n          <ion-note item-end>\n            <span *ngIf="onlyIntegers">{{invoiceFee | number : \'1.0-0\'}}</span>\n            <span *ngIf="!onlyIntegers">{{invoiceFee | number : \'1.2-2\'}}</span>\n            {{currencyIsoCode}}\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span>{{\'Miner fee\' | translate}}</span>\n          <ion-note item-end>\n            <span *ngIf="onlyIntegers">{{networkFee | number : \'1.0-0\'}}</span>\n            <span *ngIf="!onlyIntegers">{{networkFee | number : \'1.2-2\'}}</span>\n            {{currencyIsoCode}}\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span>{{\'Total\' | translate}}</span>\n          <ion-note item-end>\n            <span *ngIf="totalAmountStr">{{totalAmountStr}} ~ </span>\n            <span *ngIf="totalAmount">\n              <span *ngIf="onlyIntegers">{{totalAmount | number : \'1.0-0\'}}</span>\n              <span *ngIf="!onlyIntegers">{{totalAmount | number : \'1.2-2\'}}</span>\n              {{currencyIsoCode}}\n            </span>\n          </ion-note>\n        </ion-item>\n      </div>\n      <ion-item>\n        <card-terms *ngIf="cardConfig" [cardName]="cardConfig.name"></card-terms>\n      </ion-item>\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!(wallet && totalAmountStr)"\n    buttonText="{{\'Slide to confirm\' | translate}}" (slideDone)="buyConfirm()"\n    [ngClass]="{\'slide-confirm-fast slide-confirm-down\': hideSlideButton, \'slide-confirm-slow\': !hideSlideButton}">\n  </page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="buyConfirm()" [disabled]="!(wallet && totalAmountStr)">{{\'Confirm\n      purchase\' | translate}}</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/confirm-card-purchase/confirm-card-purchase.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_13__providers__["c" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_14__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_12__angular_common__["d" /* DecimalPipe */],
        __WEBPACK_IMPORTED_MODULE_13__providers__["A" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_22__providers_gift_card_gift_card__["a" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers__["H" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_23__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_29__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers__["x" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_24__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_27__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_28__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers__["_9" /* TxConfirmNotificationProvider */],
        __WEBPACK_IMPORTED_MODULE_30__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_31__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_25__providers_paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_26__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers__["_14" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_clipboard_clipboard__["a" /* ClipboardProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_15__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */]])
], ConfirmCardPurchasePage);

//# sourceMappingURL=confirm-card-purchase.js.map

/***/ }),

/***/ 469:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Animate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let Animate = class Animate {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
    }
    animate(animationName) {
        this.renderer.setElementClass(this.el.nativeElement, animationName, true);
        setTimeout(() => {
            this.renderer.setElementClass(this.el.nativeElement, animationName, false);
        }, 600);
    }
};
Animate = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"])({
        selector: '[animate]'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"], __WEBPACK_IMPORTED_MODULE_1__angular_core__["Renderer"]])
], Animate);

//# sourceMappingURL=animate.js.map

/***/ }),

/***/ 470:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SendFeedbackPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_device__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ionic_native_launch_review__ = __webpack_require__(850);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_feedback_feedback__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__finish_finish__ = __webpack_require__(95);







// native


// providers








// pages

let SendFeedbackPage = class SendFeedbackPage {
    constructor(actionSheetProvider, configProvider, externalLinkProvider, launchReview, modalCtrl, navCtrl, navParams, platformProvider, appProvider, onGoingProcessProvider, feedbackProvider, formBuilder, popupProvider, translate, device) {
        this.actionSheetProvider = actionSheetProvider;
        this.configProvider = configProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.launchReview = launchReview;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.appProvider = appProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.feedbackProvider = feedbackProvider;
        this.formBuilder = formBuilder;
        this.popupProvider = popupProvider;
        this.translate = translate;
        this.device = device;
        this.feedbackForm = this.formBuilder.group({
            comment: [
                '',
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required])
            ]
        });
        this.fromCard = this.navParams.data.fromCard;
        this.score = this.navParams.data.score;
        this.appName = this.appProvider.info.nameCase;
        this.leavingFeedback = false;
        this.isCordova = this.platformProvider.isCordova;
        this.isAndroid = this.platformProvider.isAndroid;
    }
    ionViewWillEnter() {
        switch (this.score) {
            case 1:
                this.reaction = this.translate.instant('Ouch!');
                this.comment = this.translate.instant("There's obviously something we're doing wrong. How could we improve your experience?");
                break;
            case 2:
                this.reaction = this.translate.instant('Thanks!');
                this.comment = this.translate.instant("We're always listening for ways we can improve your experience. Is there anything we could do to improve your experience?");
                break;
            case 3:
                this.reaction = this.translate.instant('Thanks!');
                this.comment = this.translate.instant("We're always listening for ways we can improve your experience. Feel free to leave us a review in the app store or request a new feature.");
                break;
            default:
                this.reaction = this.translate.instant('Feedback!');
                this.comment = this.translate.instant("We're always listening for ways we can improve your experience. Feel free to leave us a review in the app store or request a new feature. Also, let us know if you experience any technical issues.");
                break;
        }
    }
    showAppreciationSheet() {
        const storeName = this.isAndroid ? 'Play Store' : 'App Store';
        const infoSheet = this.actionSheetProvider.createInfoSheet('appreciate-review', { storeName });
        infoSheet.present();
        infoSheet.onDidDismiss((option) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (!option)
                return;
            if (this.launchReview.isRatingSupported()) {
                this.launchReview.rating();
            }
            else {
                yield this.launchReview.launch();
            }
        }));
    }
    leaveFeedback() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.leavingFeedback = this.leavingFeedback ? false : true;
            if (this.leavingFeedback) {
                yield __WEBPACK_IMPORTED_MODULE_6_rxjs__["Observable"].timer(50).toPromise();
                this.feedbackTextarea.setFocus();
            }
        });
    }
    openExternalLink(url) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.externalLinkProvider.open(url);
        });
    }
    goHome() {
        this.navCtrl.popToRoot({ animate: false });
    }
    sendFeedback(feedback, goHome) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const config = this.configProvider.get();
            let version;
            let platform;
            if (this.platformProvider.isElectron) {
                version = this.platformProvider
                    .getDeviceInfo()
                    .match(/(Electron[\/]\d+(\.\d)*)/i)[0]; // getDeviceInfo example: 5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Copay/5.1.0 Chrome/66.0.3359.181 Electron/3.0.8 Safari/537.36
                platform =
                    this.platformProvider.getOS() && this.platformProvider.getOS().OSName;
            }
            else {
                version = this.device.version || 'Unknown version';
                platform = this.device.platform || 'Unknown platform';
            }
            const dataSrc = {
                email: __WEBPACK_IMPORTED_MODULE_5_lodash__["values"](config.emailFor)[0] || ' ',
                feedback: goHome ? ' ' : feedback,
                score: this.score || ' ',
                appVersion: this.appProvider.info.version,
                platform,
                deviceVersion: version
            };
            if (!goHome)
                this.onGoingProcessProvider.set('sendingFeedback');
            this.feedbackProvider
                .send(dataSrc)
                .then(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
                if (goHome)
                    return;
                this.onGoingProcessProvider.clear();
                const params = {
                    finishText: 'Thanks',
                    finishComment: 'A member of the team will review your feedback as soon as possible.'
                };
                const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_17__finish_finish__["a" /* FinishModalPage */], params, {
                    showBackdrop: true,
                    enableBackdropDismiss: false
                });
                yield modal.present();
                this.navCtrl.popToRoot({ animate: false });
            }))
                .catch(() => {
                if (goHome)
                    return;
                this.onGoingProcessProvider.clear();
                const title = this.translate.instant('Error');
                const subtitle = this.translate.instant('Feedback could not be submitted. Please try again later.');
                this.popupProvider.ionicAlert(title, subtitle);
            });
            if (goHome) {
                this.navCtrl.popToRoot({ animate: false });
            }
        });
    }
    showInfoSheet(key, externalLink) {
        const infoSheet = this.actionSheetProvider.createInfoSheet(key);
        infoSheet.present();
        infoSheet.onDidDismiss((option) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            if (!option) {
                this.openExternalLink(externalLink);
            }
            else {
                this.openExternalLink('https://help.bitpay.com/requestHelp/create');
            }
        }));
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('focusMe'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], SendFeedbackPage.prototype, "feedbackTextarea", void 0);
SendFeedbackPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-send-feedback',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/feedback/send-feedback/send-feedback.html"*/'<ion-header>\n  <ion-navbar [hideBackButton]="fromCard">\n    <ion-title>{{\'Feedback\'|translate}}</ion-title>\n    <ion-buttons left *ngIf="fromCard" (click)="goHome()">\n      <button ion-button clear>\n        <ion-icon class="close-btn" name="close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <div class="msg-to-user">\n    <ion-row>\n      <ion-col>\n        <div class="feedback-title">\n          <span>{{reaction}}</span>\n        </div>\n      </ion-col>\n      <ion-col class="rating">\n        <img *ngIf="1 == score" src="assets/img/disappointed-face.svg" />\n        <img *ngIf="2 == score" src="assets/img/satisfied-face.svg" />\n        <img *ngIf="3 == score || !score" src="assets/img/happy-face.svg" />\n      </ion-col>\n    </ion-row>\n    <div class="feedback-msg">{{comment}}</div>\n  </div>\n\n  <!-- \n    TODO: reactivate feedback / create server to receive feedback\n    <div *ngIf="score == 1" class="user-feedback-card" (click)="leaveFeedback()">\n    <ion-row>\n      <div class="feedback-icon">\n        <img src="assets/img/ico-chat.svg" />\n      </div>\n      <ion-col>\n        <div class="user-feedback-title">\n          <span translate>Leave Feedback</span>\n        </div>\n      </ion-col>\n      <div *ngIf="!leavingFeedback" class="feedback-action-icon arrow arrow-dropdown"></div>\n      <div *ngIf="leavingFeedback" class="feedback-action-icon arrow arrow-dropup"></div>\n    </ion-row>\n  </div>\n  <div class="feedback-form-card" *ngIf="leavingFeedback">\n    <form class="feedback-form" [formGroup]="feedbackForm">\n      <ion-item>\n        <ion-textarea #focusMe rows="3" type="text" formControlName="comment" [value]="feedbackForm.value.comment" required padding></ion-textarea>\n      </ion-item>\n    </form>\n    <button ion-button class="button-standard" (click)="sendFeedback(feedbackForm.value.comment)" [disabled]="!feedbackForm.valid">\n      {{\'Send\' | translate}}\n    </button>\n  </div> -->\n  <div *ngIf="(score == 3 || !score) && isCordova" class="user-feedback-card" (click)="showAppreciationSheet()">\n    <ion-row>\n      <div class="feedback-icon">\n        <img src="assets/img/icon-star-review.svg" />\n      </div>\n      <ion-col>\n        <div class="user-feedback-title">\n          <span translate>Write a Review</span>\n        </div>\n      </ion-col>\n      <div class="feedback-action-icon arrow arrow-right"></div>\n    </ion-row>\n  </div>\n  <div *ngIf="score != 1" class="user-feedback-card" (click)="showInfoSheet(\'request-feature\', \'https://bitpay.canny.io/wallet-feature-request/create\')">\n    <ion-row>\n      <div class="feedback-icon">\n        <img src="assets/img/ico-chat.svg" />\n      </div>\n      <ion-col>\n        <div class="user-feedback-title">\n          <span translate>Request a Feature</span>\n        </div>\n      </ion-col>\n      <div class="feedback-action-icon">\n        <img src="assets/img/ico-link.svg" />\n      </div>\n    </ion-row>\n  </div>\n  <div *ngIf="score != 3" class="user-feedback-card" (click)="showInfoSheet(\'report-issue\',\'https://bitpay.com/request-help/wizard?category=wallet\')">\n    <ion-row>\n      <div class="feedback-icon">\n        <img src="assets/img/ico-bug.svg" />\n      </div>\n      <ion-col>\n        <div class="user-feedback-title">\n          <span translate>Report an Issue</span>\n        </div>\n      </ion-col>\n      <div class="feedback-action-icon">\n        <img src="assets/img/ico-link.svg" />\n      </div>\n    </ion-row>\n  </div>\n  <div *ngIf="score == 1" class="user-feedback-card" (click)="openExternalLink(\'https://help.bitpay.com/requestHelp/create\')">\n    <ion-row>\n      <div class="feedback-icon">\n        <img src="assets/img/icon-question-help.svg" />\n      </div>\n      <ion-col>\n        <div class="user-feedback-title">\n          <span translate>Get Help</span>\n        </div>\n      </ion-col>\n      <div class="feedback-action-icon">\n        <img src="assets/img/ico-link.svg" />\n      </div>\n    </ion-row>\n  </div>\n\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/feedback/send-feedback/send-feedback.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__ionic_native_launch_review__["a" /* LaunchReview */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_15__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_feedback_feedback__["a" /* FeedbackProvider */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_16__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_7__ionic_native_device__["a" /* Device */]])
], SendFeedbackPage);

//# sourceMappingURL=send-feedback.js.map

/***/ }),

/***/ 471:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_key_key__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_touchid_touchid__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__wallet_delete_wallet_delete__ = __webpack_require__(1017);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__wallet_name_wallet_name__ = __webpack_require__(1018);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__wallet_settings_advanced_wallet_addresses_wallet_addresses__ = __webpack_require__(472);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__wallet_settings_advanced_wallet_duplicate_wallet_duplicate__ = __webpack_require__(1020);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wallet_settings_advanced_wallet_export_wallet_export__ = __webpack_require__(473);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__wallet_settings_advanced_wallet_information_wallet_information__ = __webpack_require__(1021);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__wallet_settings_advanced_wallet_service_url_wallet_service_url__ = __webpack_require__(1022);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__wallet_settings_advanced_wallet_transaction_history_wallet_transaction_history__ = __webpack_require__(1023);





// providers







// pages








let WalletSettingsPage = class WalletSettingsPage {
    constructor(profileProvider, logger, walletProvider, externalLinkProvider, configProvider, navCtrl, navParams, touchIdProvider, translate, actionSheetProvider, keyProvider, events) {
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.configProvider = configProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.touchIdProvider = touchIdProvider;
        this.translate = translate;
        this.actionSheetProvider = actionSheetProvider;
        this.keyProvider = keyProvider;
        this.events = events;
        this.deleted = false;
        this.logger.info('Loaded:  WalletSettingsPage');
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
    }
    ionViewWillEnter() {
        this.canSign = this.wallet.canSign;
        this.needsBackup = this.wallet.needsBackup;
        this.hiddenBalance = this.wallet.balanceHidden;
        this.encryptEnabled = this.wallet.isPrivKeyEncrypted;
        this.checkBiometricIdAvailable();
        this.config = this.configProvider.get();
        this.touchIdEnabled = this.config.touchIdFor
            ? this.config.touchIdFor[this.wallet.credentials.walletId]
            : null;
        this.touchIdPrevValue = this.touchIdEnabled;
        if (this.wallet.credentials &&
            !this.wallet.credentials.mnemonicEncrypted &&
            !this.wallet.credentials.mnemonic) {
            this.deleted = true;
        }
        this.showDuplicateWallet = this.getShowDuplicateWalletOption();
    }
    getShowDuplicateWalletOption() {
        if (this.wallet.network != 'livenet' || this.wallet.coin != 'btc')
            return false;
        const key = this.keyProvider.getKey(this.wallet.credentials.keyId);
        if (!key)
            return false;
        // only available for OLD multisig wallets. or single sig
        if (this.wallet.n > 1 && !key.use44forMultisig)
            return false;
        // only first account
        if (this.wallet.credentials.account != 0)
            return false;
        return true;
    }
    checkBiometricIdAvailable() {
        this.touchIdProvider.isAvailable().then((isAvailable) => {
            this.touchIdAvailable = isAvailable;
        });
    }
    hiddenBalanceChange() {
        this.profileProvider.toggleHideBalanceFlag(this.wallet.credentials.walletId);
    }
    encryptChange() {
        if (!this.wallet)
            return;
        const val = this.encryptEnabled;
        if (val && !this.wallet.isPrivKeyEncrypted) {
            this.logger.debug('Encrypting private key for', this.wallet.name);
            this.keyProvider
                .encrypt(this.wallet.credentials.keyId)
                .then(() => {
                this.profileProvider.updateCredentials(JSON.parse(this.wallet.toString()));
                this.logger.debug('Wallet encrypted');
            })
                .catch(err => {
                this.encryptEnabled = false;
                const title = this.translate.instant('Could not encrypt wallet');
                this.showErrorInfoSheet(err, title);
            });
        }
        else if (!val && this.wallet.isPrivKeyEncrypted) {
            this.keyProvider
                .decrypt(this.wallet.credentials.keyId)
                .then(() => {
                this.profileProvider.updateCredentials(JSON.parse(this.wallet.toString()));
                this.logger.debug('Wallet decrypted');
            })
                .catch(err => {
                this.encryptEnabled = true;
                const title = this.translate.instant('Could not decrypt wallet');
                this.showErrorInfoSheet(err, title);
            });
        }
    }
    showErrorInfoSheet(err, infoSheetTitle) {
        if (!err)
            return;
        this.logger.warn('Could not encrypt/decrypt wallet:', err);
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg: err, title: infoSheetTitle });
        errorInfoSheet.present();
    }
    openSupportEncryptPassword() {
        const url = 'https://support.bitpay.com/hc/en-us/articles/360000244506-What-Does-a-Spending-Password-Do-';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Read more in our support page');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    touchIdChange() {
        if (this.touchIdPrevValue == this.touchIdEnabled)
            return;
        const newStatus = this.touchIdEnabled;
        this.walletProvider
            .setTouchId([].concat(this.wallet), newStatus)
            .then(() => {
            this.touchIdPrevValue = this.touchIdEnabled;
            this.logger.debug('Touch Id status changed: ' + newStatus);
        })
            .catch(err => {
            this.logger.error('Error with fingerprint:', err);
            this.checkBiometricIdAvailable();
            this.touchIdEnabled = this.touchIdPrevValue;
        });
    }
    openWalletName() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__wallet_name_wallet_name__["a" /* WalletNamePage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openWalletInformation() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__wallet_settings_advanced_wallet_information_wallet_information__["a" /* WalletInformationPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openWalletAddresses() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_14__wallet_settings_advanced_wallet_addresses_wallet_addresses__["a" /* WalletAddressesPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openExportWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__wallet_settings_advanced_wallet_export_wallet_export__["a" /* WalletExportPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openWalletServiceUrl() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__wallet_settings_advanced_wallet_service_url_wallet_service_url__["a" /* WalletServiceUrlPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openTransactionHistory() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_19__wallet_settings_advanced_wallet_transaction_history_wallet_transaction_history__["a" /* WalletTransactionHistoryPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openDuplicateWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_15__wallet_settings_advanced_wallet_duplicate_wallet_duplicate__["a" /* WalletDuplicatePage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    hiddenWalletChange(walletId) {
        if (!walletId)
            return;
        this.profileProvider.toggleHideWalletFlag(walletId);
        this.events.publish('Local/WalletListChange');
    }
    openWalletGroupDelete() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__wallet_delete_wallet_delete__["a" /* WalletDeletePage */], {
            keyId: this.wallet.keyId,
            walletId: this.wallet.id
        });
    }
};
WalletSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-settings',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings.html"*/'<ion-header>\n  <ion-navbar [navbar-bg]="wallet?.color">\n    <ion-title>{{\'Wallet Settings\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list class="settings-list bp-list">\n    <button ion-item (click)="openWalletName()">\n      <div translate float-left>Name</div>\n      <ion-note item-end>\n        {{wallet && wallet.name}}\n      </ion-note>\n    </button>\n    <ion-item class="with-label no-border">\n      <ion-label>Hide Wallet</ion-label>\n      <ion-toggle checked="{{wallet?.hidden}}" (ionChange)="hiddenWalletChange(wallet.id)"></ion-toggle>\n    </ion-item>\n    <label-tip class="info" type="info" header="no-header">\n      <div label-tip-body translate>\n        The wallet won\'t be removed from this device. You can hide it whenever you need it.\n      </div>\n    </label-tip>\n    <ion-item>\n      <ion-label>{{\'Hide Balance\' | translate}}</ion-label>\n      <ion-toggle [(ngModel)]="hiddenBalance" (ionChange)="hiddenBalanceChange()"></ion-toggle>\n    </ion-item>\n    <ion-item-divider *ngIf="canSign && touchIdAvailable">{{\'Security\' | translate}}</ion-item-divider>\n    <div *ngIf="canSign && touchIdAvailable">\n      <ion-item>\n        <ion-label [ngClass]="{\'disabled\': needsBackup}">{{\'Request Biometric Authentication\'| translate}}</ion-label>\n        <ion-toggle [(ngModel)]="touchIdEnabled" (ionChange)="touchIdChange()"></ion-toggle>\n      </ion-item>\n    </div>\n    <ion-item-divider>{{\'Advanced\' | translate}}</ion-item-divider>\n    <button ion-item (click)="openWalletInformation()">\n      <span translate>Information</span>\n    </button>\n    <button ion-item (click)="openWalletAddresses()">\n      <span translate>Addresses</span>\n    </button>\n    <button ion-item (click)="openExportWallet()">\n      <span translate>Export Wallet</span>\n    </button>\n    <button ion-item (click)="openWalletServiceUrl()">\n      <span>Wallet Service URL</span>\n    </button>\n    <button ion-item (click)="openTransactionHistory()">\n      <span translate>Transaction History</span>\n    </button>\n    <button ion-item (click)="openDuplicateWallet()" *ngIf="showDuplicateWallet">\n      <span translate>Duplicate to BCH</span>\n    </button>\n    <button *ngIf="!canSign" ion-item (click)="openWalletGroupDelete()">\n      <span translate>Delete</span>\n    </button>\n    <ion-item-divider></ion-item-divider>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_10__providers_touchid_touchid__["a" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_key_key__["a" /* KeyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */]])
], WalletSettingsPage);

//# sourceMappingURL=wallet-settings.js.map

/***/ }),

/***/ 472:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletAddressesPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__all_addresses_all_addresses__ = __webpack_require__(1019);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_lodash__);





// providers





// pages


let WalletAddressesPage = class WalletAddressesPage {
    constructor(profileProvider, walletProvider, navCtrl, navParams, logger, bwcErrorProvider, popupProvider, modalCtrl, txFormatProvider, translate, events) {
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.bwcErrorProvider = bwcErrorProvider;
        this.popupProvider = popupProvider;
        this.modalCtrl = modalCtrl;
        this.txFormatProvider = txFormatProvider;
        this.translate = translate;
        this.events = events;
        this.UNUSED_ADDRESS_LIMIT = 5;
        this.BALANCE_ADDRESS_LIMIT = 5;
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.withBalance = null;
        this.noBalance = null;
    }
    ionViewWillEnter() {
        this.loading = true;
        this.walletProvider
            .getMainAddresses(this.wallet, {
            doNotVerify: true
        })
            .then(allAddresses => {
            const { token } = this.wallet.credentials;
            this.walletProvider
                .getBalance(this.wallet, { tokenAddress: token ? token.address : '' })
                .then(resp => {
                this.withBalance = resp.byAddress;
                const idx = __WEBPACK_IMPORTED_MODULE_11_lodash__["keyBy"](this.withBalance, 'address');
                this.noBalance = __WEBPACK_IMPORTED_MODULE_11_lodash__["reject"](allAddresses, x => {
                    return idx[x.address];
                });
                this.processList(this.noBalance);
                this.processList(this.withBalance);
                this.latestUnused = __WEBPACK_IMPORTED_MODULE_11_lodash__["slice"](this.noBalance, 0, this.UNUSED_ADDRESS_LIMIT);
                this.latestWithBalance = __WEBPACK_IMPORTED_MODULE_11_lodash__["slice"](this.withBalance, 0, this.BALANCE_ADDRESS_LIMIT);
                this.viewAll =
                    this.noBalance.length > this.UNUSED_ADDRESS_LIMIT ||
                        this.withBalance.length > this.BALANCE_ADDRESS_LIMIT;
                this.loading = false;
            })
                .catch(err => {
                this.logger.error(err);
                this.loading = false;
                this.popupProvider.ionicAlert(this.bwcErrorProvider.msg(err, this.translate.instant('Could not update wallet')));
            });
        })
            .catch(err => {
            this.logger.error(err);
            this.loading = false;
            this.popupProvider.ionicAlert(this.bwcErrorProvider.msg(err, this.translate.instant('Could not update wallet')));
        });
        this.walletProvider
            .getLowUtxos(this.wallet)
            .then(resp => {
            if (resp && resp.allUtxos && resp.allUtxos.length) {
                const allSum = __WEBPACK_IMPORTED_MODULE_11_lodash__["sumBy"](resp.allUtxos || 0, 'satoshis');
                const per = (resp.minFee / allSum) * 100;
                this.lowUtxosNb = resp.lowUtxos.length;
                this.allUtxosNb = resp.allUtxos.length;
                this.lowUtxosSum = this.txFormatProvider.formatAmountStr(this.wallet.coin, __WEBPACK_IMPORTED_MODULE_11_lodash__["sumBy"](resp.lowUtxos || 0, 'satoshis'));
                this.allUtxosSum = this.txFormatProvider.formatAmountStr(this.wallet.coin, allSum);
                this.minFee = this.txFormatProvider.formatAmountStr(this.wallet.coin, resp.minFee || 0);
                this.minFeePer = per.toFixed(2) + '%';
            }
        })
            .catch(err => {
            this.logger.warn('GetLowUtxos', err);
        });
    }
    processList(list) {
        __WEBPACK_IMPORTED_MODULE_11_lodash__["each"](list, n => {
            n.path = n.path ? n.path.replace(/^m/g, 'xpub') : null;
            n.address = this.walletProvider.getAddressView(this.wallet.coin, this.wallet.network, n.address);
        });
    }
    viewAllAddresses() {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_10__all_addresses_all_addresses__["a" /* AllAddressesPage */], {
            noBalance: this.noBalance,
            withBalance: this.withBalance,
            coin: this.wallet.coin,
            walletName: this.wallet.name
        });
        modal.present();
    }
    scan() {
        this.walletProvider.startScan(this.wallet);
        this.navCtrl.popToRoot().then(() => {
            setTimeout(() => {
                this.events.publish('OpenWallet', this.wallet);
            }, 1000);
        });
    }
};
WalletAddressesPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-addresses',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/wallet-addresses.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Wallet Addresses\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="explanation">\n    <span translate>\n      Each bitcoin wallet can generate billions of addresses from your 12-word recovery phrase. A new address is automatically generated and shown each time you receive a payment.\n    </span>\n    <a (click)="showInfo = !showInfo" *ngIf="!showInfo" translate>Why?</a>\n\n    <div *ngIf="showInfo">\n      <br>\n      <span translate>\n        It\'s a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.</span>\n      <a (click)="showInfo = !showInfo" translate>Hide</a>\n    </div>\n  </div>\n\n  <button ion-button class="button-standard" (click)="scan()">\n    <span translate>Scan addresses for funds</span>\n  </button>\n\n  <button ion-item *ngIf="viewAll" (click)="viewAllAddresses()">\n    <span ion-text color="dark" translate>View all addresses</span>\n  </button>\n\n  <div class="loading" *ngIf="loading">\n    <ion-spinner icon="crescent"></ion-spinner>\n    <span translate>Loading addresses...</span>\n  </div>\n\n  <ion-list *ngIf="!loading" class="settings-list bp-list">\n    <div *ngIf="allUtxosNb">\n      <ion-item-divider>{{\'Wallet Inputs\' | translate}}</ion-item-divider>\n\n      <ion-item>\n        <span translate>Total wallet inputs</span>\n        <p class="info">{{allUtxosNb}} [{{allUtxosSum}}]</p>\n      </ion-item>\n\n      <ion-item>\n        <span translate> Low amount inputs </span>\n        <p class="info">{{lowUtxosNb}} [{{ lowUtxosSum }}]</p>\n      </ion-item>\n\n      <ion-item>\n        <span translate>Approximate Bitcoin network fee to transfer wallet\'s balance (with normal priority)</span>\n        <p class="info">{{minFeePer}} [{{minFee}}]</p>\n      </ion-item>\n    </div>\n\n    <div *ngIf="latestWithBalance && latestWithBalance[0]">\n      <ion-item-divider>{{\'Addresses with balance\' | translate}}</ion-item-divider>\n      <ion-item *ngFor="let w of latestWithBalance" copy-to-clipboard="{{w.address}}">\n        <h3>{{w.address}}</h3>\n        <p class="info">{{w.amount | satToUnit: wallet.coin}}</p>\n      </ion-item>\n    </div>\n\n    <div *ngIf="latestUnused && latestUnused[0]">\n      <ion-item-divider>{{\'Unused addresses\' | translate}}</ion-item-divider>\n      <ion-item *ngFor="let u of latestUnused" copy-to-clipboard="{{u.address}}">\n        <h3>{{u.address}}</h3>\n        <p>{{u.path}} {{u.createdOn * 1000 | amDateFormat:\'MMMM Do YYYY, hh:mm a\'}}</p>\n      </ion-item>\n    </div>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/wallet-addresses.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_8__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */]])
], WalletAddressesPage);

//# sourceMappingURL=wallet-addresses.js.map

/***/ }),

/***/ 473:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletExportPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_clipboard__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_social_sharing__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_backup_backup__ = __webpack_require__(975);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_wallet_wallet__ = __webpack_require__(32);






// native


// providers









let WalletExportPage = class WalletExportPage {
    constructor(profileProvider, navCtrl, walletProvider, navParams, formBuilder, logger, persistenceProvider, backupProvider, platformProvider, socialSharing, appProvider, clipboard, toastCtrl, translate, actionSheetProvider, configProvider, bwcErrorProvider) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.walletProvider = walletProvider;
        this.navParams = navParams;
        this.formBuilder = formBuilder;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.backupProvider = backupProvider;
        this.platformProvider = platformProvider;
        this.socialSharing = socialSharing;
        this.appProvider = appProvider;
        this.clipboard = clipboard;
        this.toastCtrl = toastCtrl;
        this.translate = translate;
        this.actionSheetProvider = actionSheetProvider;
        this.configProvider = configProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.password = '';
        this.showAdv = false;
        this.showAdvanced = false;
        this.exportWalletForm = this.formBuilder.group({
            password: ['', __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required],
            confirmPassword: ['', __WEBPACK_IMPORTED_MODULE_2__angular_forms__["f" /* Validators */].required],
            noSignEnabled: [false]
        }, { validator: this.matchingPasswords('password', 'confirmPassword') });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: WalletExportPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.isEncrypted = this.wallet.isPrivKeyEncrypted;
        this.canSign = this.wallet.canSign;
        this.isCordova = this.platformProvider.isCordova;
        this.isSafari = this.platformProvider.isSafari;
        this.isIOS = this.platformProvider.isIOS;
    }
    matchingPasswords(passwordKey, confirmPasswordKey) {
        return (group) => {
            const password = group.controls[passwordKey];
            const confirmPassword = group.controls[confirmPasswordKey];
            if (password.value !== confirmPassword.value) {
                return {
                    mismatchedPasswords: true
                };
            }
            return undefined;
        };
    }
    getPassword() {
        return new Promise((resolve, reject) => {
            if (this.password)
                return resolve(this.password);
            this.walletProvider
                .prepare(this.wallet)
                .then(password => {
                this.password = password;
                return resolve(password);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    downloadWalletBackup() {
        this.getPassword()
            .then((password) => {
            this.getAddressBook()
                .then(localAddressBook => {
                const opts = {
                    noSign: this.exportWalletForm.value.noSignEnabled,
                    addressBook: localAddressBook,
                    password
                };
                this.backupProvider
                    .walletDownload(this.navParams.data.walletId, opts, this.exportWalletForm.value.password)
                    .then(() => {
                    this.navCtrl.pop();
                })
                    .catch(() => {
                    this.showErrorInfoSheet();
                });
            })
                .catch(() => {
                this.showErrorInfoSheet();
            });
        })
            .catch(err => {
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED')
                this.showErrorInfoSheet(this.bwcErrorProvider.msg(err));
        });
    }
    getAddressBook() {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook(this.wallet.credentials.network)
                .then(localAddressBook => {
                if (!localAddressBook)
                    return resolve();
                try {
                    localAddressBook = JSON.parse(localAddressBook);
                }
                catch (ex) {
                    this.logger.warn('Wallet Export: JSON Parse localAddressBook is not necessary', ex);
                }
                return resolve(localAddressBook);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getBackup() {
        return new Promise(resolve => {
            this.getPassword()
                .then((password) => {
                this.getAddressBook()
                    .then(localAddressBook => {
                    const opts = {
                        noSign: this.exportWalletForm.value.noSignEnabled,
                        addressBook: localAddressBook,
                        password
                    };
                    const ew = this.backupProvider.walletExport(this.navParams.data.walletId, opts, this.exportWalletForm.value.password);
                    if (!ew) {
                        this.showErrorInfoSheet();
                    }
                    return resolve(ew);
                })
                    .catch(() => {
                    this.showErrorInfoSheet();
                    return resolve();
                });
            })
                .catch(err => {
                if (err &&
                    err.message != 'FINGERPRINT_CANCELLED' &&
                    err.message != 'PASSWORD_CANCELLED')
                    this.showErrorInfoSheet(this.bwcErrorProvider.msg(err));
                return resolve();
            });
        });
    }
    viewWalletBackup() {
        this.getBackup().then(backup => {
            const ew = backup;
            if (!ew)
                return;
            this.backupWalletPlainText = ew;
        });
    }
    copyWalletBackup() {
        this.getBackup().then(backup => {
            const ew = backup;
            if (!ew)
                return;
            this.clipboard.copy(ew);
            const copyMessage = this.translate.instant('Copied to clipboard');
            const showSuccess = this.toastCtrl.create({
                message: copyMessage,
                duration: 1000
            });
            showSuccess.present();
        });
    }
    sendWalletBackup() {
        const preparingMessage = this.translate.instant('Preparing backup...');
        const showSuccess = this.toastCtrl.create({
            message: preparingMessage,
            duration: 1000
        });
        showSuccess.present();
        let name = this.wallet.credentials.walletName || this.wallet.credentials.walletId;
        const config = this.configProvider.get();
        const alias = config.aliasFor && config.aliasFor[this.wallet.credentials.walletId];
        if (alias) {
            name = alias + ' [' + name + ']';
        }
        this.getBackup().then(backup => {
            const ew = backup;
            if (!ew)
                return;
            if (this.exportWalletForm.value.noSignEnabled)
                name = name + '(No Private Key)';
            const subject = this.appProvider.info.nameCase + ' Wallet Backup: ' + name;
            const body = 'Here is the encrypted backup of the wallet ' +
                name +
                ': \n\n' +
                ew +
                '\n\n To import this backup, copy all text between {...}, including the symbols {}';
            // Check if sharing via email is supported
            this.socialSharing
                .canShareViaEmail()
                .then(() => {
                this.logger.info('sharing via email is possible');
                this.socialSharing
                    .shareViaEmail(body, subject, null, // TO: must be null or an array
                null, // CC: must be null or an array
                null, // BCC: must be null or an array
                null // FILES: can be null, a string, or an array
                )
                    .then(data => {
                    this.logger.info('Email created successfully: ', data);
                })
                    .catch(err => {
                    this.logger.error('socialSharing Error: ', err);
                });
            })
                .catch(() => {
                this.logger.warn('sharing via email is not possible');
                this.socialSharing.share(body, subject).catch(err => {
                    this.logger.error('socialSharing Error: ', err);
                });
            });
        });
    }
    showErrorInfoSheet(err) {
        const title = this.translate.instant('Error');
        const msg = err ? err : this.translate.instant('Failed to export');
        this.logger.error(err);
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg, title });
        errorInfoSheet.present();
    }
};
WalletExportPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-export',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-export/wallet-export.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Export wallet\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <div>\n    <ion-list>\n      <div *ngIf="!backupWalletPlainText">\n        <form [formGroup]="exportWalletForm">\n          <ion-item>\n            <ion-label stacked>{{\'Set up a password\' | translate}}</ion-label>\n            <ion-input type="password" formControlName="password" required></ion-input>\n          </ion-item>\n          <ion-item>\n            <ion-label stacked>{{\'Repeat the password\' | translate}}</ion-label>\n            <ion-input type="password" formControlName="confirmPassword" required></ion-input>\n          </ion-item>\n          <ion-item *ngIf="exportWalletForm.controls.confirmPassword.touched && exportWalletForm.hasError(\'mismatchedPasswords\') && exportWalletForm.controls.password.valid">\n            <span ion-text color="warning" translate>Passwords do not match</span>\n          </ion-item>\n          <label-tip class="no-arrowhead warning-message" *ngIf="!canSign" type="warn">\n            <span label-tip-title translate>No Private Key</span>\n            <div label-tip-body translate>\n              The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so funds will not be accessible from the export.\n            </div>\n          </label-tip>\n          <div *ngIf="canSign">\n            <button ion-button class="button-standard button-secondary" (click)="showAdv = !showAdv">\n              <span *ngIf="!showAdv">{{\'Show advanced options\' | translate}}</span>\n              <span *ngIf="showAdv">{{\'Hide advanced options\' | translate}}</span>\n            </button>\n          </div>\n          <ion-item [ngClass]="{\'with-label\': exportWalletForm.value.noSignEnabled }" *ngIf="showAdv">\n            <ion-label stacked>{{\'Do not include private key\' | translate}}</ion-label>\n            <ion-checkbox formControlName="noSignEnabled"></ion-checkbox>\n          </ion-item>\n\n          <label-tip *ngIf="exportWalletForm.value.noSignEnabled" class="warning-message" type="warn">\n            <span label-tip-title translate>Funds Will Not Be Accessible</span>\n            <div label-tip-body translate>\n              Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so funds will not be accessible from the export.\n            </div>\n          </label-tip>\n\n          <button *ngIf="!isSafari && !isCordova" class="button-standard" ion-button type="submit" (click)="downloadWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid ">\n            <span translate>Download</span>\n          </button>\n          <button *ngIf="isSafari && !isCordova" class="button-standard" ion-button type="submit" (click)="viewWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid ">\n            <span translate>View</span>\n          </button>\n          <div *ngIf="isCordova">\n            <button class="button-standard" ion-button type="submit" (click)="copyWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid ">\n              <span translate>Copy to clipboard</span>\n            </button>\n            <button class="button-standard" ion-button type="submit" (click)="sendWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid ">\n              <span translate>Send by email</span>\n            </button>\n          </div>\n        </form>\n      </div>\n      <div *ngIf="backupWalletPlainText">\n        <span translate>Backup wallet</span>\n        <p translate>Copy this text as it is to a safe place (notepad or email)</p>\n        <ion-textarea rows="12">{{backupWalletPlainText}}</ion-textarea>\n      </div>\n    </ion-list>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-export/wallet-export.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_15__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_16__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_13__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_backup_backup__["a" /* BackupProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_9__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__ionic_native_clipboard__["a" /* Clipboard */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["s" /* ToastController */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */]])
], WalletExportPage);

//# sourceMappingURL=wallet-export.js.map

/***/ }),

/***/ 474:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProposalsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_address_book_address_book__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_replace_parameters_replace_parameters__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__finish_finish__ = __webpack_require__(95);





// providers









// pages

let ProposalsPage = class ProposalsPage {
    constructor(plt, actionSheetProvider, addressBookProvider, bwcErrorProvider, logger, onGoingProcessProvider, profileProvider, platformProvider, translate, events, replaceParametersProvider, walletProvider, modalCtrl, navCtrl, navParams) {
        this.plt = plt;
        this.actionSheetProvider = actionSheetProvider;
        this.addressBookProvider = addressBookProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.logger = logger;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.profileProvider = profileProvider;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.events = events;
        this.replaceParametersProvider = replaceParametersProvider;
        this.walletProvider = walletProvider;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.updatePendingProposals = (opts = { finished: true }) => {
            if (!opts.finished)
                return;
            this.profileProvider
                .getTxps({ limit: 50 })
                .then(txpsData => {
                this.zone.run(() => {
                    this.allTxps = [];
                    // Check if txp were checked before
                    txpsData.txps.forEach(txp => {
                        txp.checked = __WEBPACK_IMPORTED_MODULE_4_lodash__["indexOf"](this.txpsToSign, txp) >= 0 ? true : false;
                    });
                    if (this.walletId) {
                        txpsData.txps = __WEBPACK_IMPORTED_MODULE_4_lodash__["filter"](txpsData.txps, txps => {
                            return txps.walletId == this.walletId;
                        });
                    }
                    this.checkStatus(txpsData.txps);
                    this.allTxps.push({
                        title: this.translate.instant('Payment Proposal'),
                        type: 'pending',
                        data: this.groupByWallets(this.txpsPending)
                    });
                    this.allTxps.push({
                        title: this.translate.instant('Accepted'),
                        type: 'accepted',
                        data: this.groupByWallets(this.txpsAccepted)
                    });
                    this.allTxps.push({
                        title: this.translate.instant('Rejected'),
                        type: 'rejected',
                        data: this.groupByWallets(this.txpsRejected)
                    });
                    if (this.navCtrl.canGoBack() &&
                        !this.txpsPending[0] &&
                        !this.txpsAccepted[0] &&
                        !this.txpsRejected[0]) {
                        this.navCtrl.pop();
                    }
                });
            })
                .catch(err => {
                this.logger.error(err);
            });
        };
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
        this.isElectron = this.platformProvider.isElectron;
        this.walletId = this.navParams.data.walletId;
        this.isCordova = this.platformProvider.isCordova;
        this.buttonText = this.translate.instant('Sign selected proposals');
        this.allTxps = [];
        this.txpsToSign = [];
        this.txpsPending = [];
        this.txpsAccepted = [];
        this.txpsRejected = [];
    }
    ionViewWillEnter() {
        this.navCtrl.swipeBackEnabled = false;
        this.updateAddressBook();
        this.updatePendingProposals();
        this.onResumeSubscription = this.plt.resume.subscribe(() => {
            this.subscribeEvents();
        });
        // Update Wallet on Focus
        if (this.isElectron) {
            this.updateDesktopOnFocus();
        }
    }
    subscribeEvents() {
        this.events.subscribe('Local/WalletUpdate', this.updatePendingProposals);
    }
    // Event handling
    ionViewWillLoad() {
        this.subscribeEvents();
    }
    ionViewWillUnload() {
        this.events.unsubscribe('Local/WalletUpdate', this.updatePendingProposals);
        this.onResumeSubscription.unsubscribe();
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    updateDesktopOnFocus() {
        const { remote } = window.require('electron');
        const win = remote.getCurrentWindow();
        win.on('focus', () => {
            this.updatePendingProposals();
        });
    }
    updateAddressBook() {
        this.addressBookProvider
            .list()
            .then(ab => {
            this.addressbook = ab || {};
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    checkStatus(txps) {
        this.txpsPending = [];
        this.txpsAccepted = [];
        this.txpsRejected = [];
        txps.forEach(txp => {
            const action = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](txp.actions, {
                copayerId: txp.wallet.copayerId
            });
            if (!action && txp.status == 'pending') {
                txp.pendingForUs = true;
            }
            if (action && action.type == 'accept') {
                txp.statusForUs = 'accepted';
                this.txpsAccepted.push(txp);
            }
            else if (action && action.type == 'reject') {
                txp.statusForUs = 'rejected';
                this.txpsRejected.push(txp);
            }
            else {
                txp.statusForUs = 'pending';
                this.txpsPending.push(txp);
            }
        });
    }
    groupByWallets(txps) {
        const walletIdGetter = txp => txp.walletId;
        const map = new Map();
        const txpsByWallet = [];
        txps.forEach(txp => {
            const walletId = walletIdGetter(txp);
            const collection = map.get(walletId);
            if (!collection) {
                map.set(walletId, [txp]);
            }
            else {
                collection.push(txp);
            }
        });
        Array.from(map).forEach(txpsPerWallet => {
            const txpToBeSigned = this.getTxpToBeSigned(txpsPerWallet[1]);
            txpsByWallet.push({
                walletId: txpsPerWallet[0],
                txps: txpsPerWallet[1],
                multipleSignAvailable: txpToBeSigned > 1
            });
        });
        return txpsByWallet;
    }
    getTxpToBeSigned(txpsPerWallet) {
        let i = 0;
        txpsPerWallet.forEach(txp => {
            if (txp.statusForUs === 'pending')
                i = i + 1;
        });
        return i;
    }
    signMultipleProposals(txp) {
        this.txpsToSign = [];
        this.walletIdSelectedToSign =
            this.walletIdSelectedToSign == txp.walletId
                ? this.resetMultiSignValues()
                : txp.walletId;
    }
    sign() {
        const wallet = this.txpsToSign[0].wallet
            ? this.txpsToSign[0].wallet
            : this.profileProvider.getWallet(this.txpsToSign[0].walletId);
        this.walletProvider
            .signMultipleTxps(wallet, this.txpsToSign)
            .then(data => {
            this.resetMultiSignValues();
            this.onGoingProcessProvider.clear();
            const count = this.countSuccessAndFailed(data);
            if (count.failed > 0) {
                const signErr = this.replaceParametersProvider.replace(this.translate.instant('There was problem while trying to sign {{txpsFailed}} of your transactions proposals. Please, try again'), { txpsFailed: count.failed });
                const title = this.translate.instant('Error');
                this.showErrorInfoSheet(title, signErr);
            }
            if (count.success > 0) {
                const finishText = this.replaceParametersProvider.replace(count.success > 1
                    ? this.translate.instant('{{txpsSuccess}} proposals signed')
                    : this.translate.instant('{{txpsSuccess}} proposal signed'), { txpsSuccess: count.success });
                this.openModal(finishText, null, 'success');
            }
            // own TxActions  are not triggered?
            this.events.publish('Local/TxAction', wallet.walletId);
        })
            .catch(err => {
            this.logger.error('Sign multiple transaction proposals failed: ', err);
            this.onGoingProcessProvider.clear();
            if (err &&
                err.message != 'FINGERPRINT_CANCELLED' &&
                err.message != 'PASSWORD_CANCELLED') {
                const title = this.translate.instant('Error');
                const msg = this.bwcErrorProvider.msg(err);
                this.showErrorInfoSheet(title, msg);
            }
        });
    }
    showErrorInfoSheet(title, msg) {
        const errorInfoSheet = this.actionSheetProvider.createInfoSheet('default-error', { msg, title });
        errorInfoSheet.present();
    }
    countSuccessAndFailed(arrayData) {
        const count = { success: 0, failed: 0 };
        arrayData.forEach(data => {
            if (data.id) {
                count.success = count.success + 1;
            }
            else {
                count.failed = count.failed + 1;
            }
        });
        return count;
    }
    txpSelectionChange(txp) {
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["indexOf"](this.txpsToSign, txp) >= 0) {
            __WEBPACK_IMPORTED_MODULE_4_lodash__["remove"](this.txpsToSign, txpToSign => {
                return txpToSign.id == txp.id;
            });
            txp.checked = false;
        }
        else {
            txp.checked = true;
            this.txpsToSign.push(txp);
        }
        if (this.isCordova)
            this.hideSlideButton = this.txpsToSign[0] ? false : true;
    }
    resetMultiSignValues() {
        this.allTxps.forEach(txpsByStatus => {
            txpsByStatus.data.forEach(txpsByWallet => {
                if (txpsByWallet.walletId == this.walletIdSelectedToSign) {
                    txpsByWallet.txps.forEach(txp => {
                        txp.checked = false;
                    });
                }
            });
        });
        this.txpsToSign = [];
        this.walletIdSelectedToSign = null;
    }
    openModal(finishText, finishComment, cssClass) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_14__finish_finish__["a" /* FinishModalPage */], {
            finishText,
            finishComment,
            cssClass
        }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
    }
    selectAll(txpsByWallet) {
        this.zone.run(() => {
            this.txpsToSign = [];
            txpsByWallet.txps.forEach(txp => {
                this.txpsToSign.push(txp);
                txp.checked = true;
            });
            if (this.isCordova)
                this.hideSlideButton = false;
        });
    }
};
ProposalsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-proposals',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/home/proposals/proposals.html"*/'<wide-header-page title="{{\'Notifications\' | translate}}" [ngClass]="{\'no-margin-bottom\': !txpsToSign[0], \'small-margin\': !isCordova && txpsToSign[0]}">\n  <div page-content>\n    <div *ngIf="allTxps && allTxps[0]">\n      <div class="txps-status" *ngFor="let txpsByStatus of allTxps">\n        <div class="section-header" *ngIf="txpsByStatus.data && txpsByStatus.data[0]">{{txpsByStatus.title}}</div>\n        <div class="card" *ngFor="let txpsByWallet of txpsByStatus.data">\n          <div class="wallet-divider" *ngIf="txpsByWallet.walletId && txpsByWallet.txps && txpsByWallet.txps[0] && txpsByWallet.txps[0].wallet">\n            <div class="wallet-title">\n              <img [ngClass]="{ testnet: txpsByWallet.txps[0].wallet.network === \'testnet\' }" src="assets/img/currencies/{{txpsByWallet.txps[0].wallet.coin}}.svg" class="icon-wallet" />\n              <span class="name">{{txpsByWallet.txps[0].wallet.name}}</span>\n            </div>\n            <div *ngIf="txpsByStatus.type == \'pending\'">\n              <div *ngIf="txpsByWallet.multipleSignAvailable && !walletIdSelectedToSign" class="multi-sign" outline (click)="signMultipleProposals(txpsByWallet)">\n                <ion-icon name="ios-list-outline"></ion-icon>\n              </div>\n              <div class="select-all" *ngIf="walletIdSelectedToSign && txpsByWallet.walletId == walletIdSelectedToSign">\n                <div class="multi-sign" (click)="selectAll(txpsByWallet)">\n                  <ion-icon name="ios-done-all"></ion-icon>\n                </div>\n                <div class="multi-sign close" (click)="signMultipleProposals(txpsByWallet)">\n                  <ion-icon name="ios-close"></ion-icon>\n                </div>\n              </div>\n            </div>\n            <div class="circle-status" *ngIf="txpsByStatus.type != \'pending\'" [ngClass]="{\'balanced\': txpsByStatus.type == \'accepted\', \'assertive\': txpsByStatus.type == \'rejected\'}"></div>\n          </div>\n          <div class="txp-container" *ngFor="let txp of txpsByWallet.txps">\n            <ion-checkbox mode="ios" (click)="txpSelectionChange(txp)" *ngIf="walletIdSelectedToSign && txp.walletId == walletIdSelectedToSign && txp.statusForUs === \'pending\'" [checked]="txp.checked" [disabled]="txp.statusForUs == \'accepted\' || txp.statusForUs == \'rejected\'"></ion-checkbox>\n            <page-txp [ngClass]="{\'with-checkbox\': walletIdSelectedToSign && txp.walletId == walletIdSelectedToSign && txp.statusForUs === \'pending\'}" [tx]="txp" [addressbook]="addressbook" [noOpenModal]="walletIdSelectedToSign && txp.walletId == walletIdSelectedToSign && txp.statusForUs === \'pending\'"></page-txp>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</wide-header-page>\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova && txpsToSign[0]" [ngClass]="{\'slide-confirm-fast slide-confirm-down\': hideSlideButton, \'slide-confirm-slow\': !hideSlideButton}" [buttonText]="buttonText" (slideDone)="sign()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova && txpsToSign[0]">\n    <button ion-button full class="button-footer" (click)="sign()">{{buttonText}}</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/home/proposals/proposals.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_12__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */]])
], ProposalsPage);

//# sourceMappingURL=proposals.js.map

/***/ }),

/***/ 475:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DisclaimerPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__tabs_tabs__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_email_notifications_email_notifications__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__ = __webpack_require__(39);









let DisclaimerPage = class DisclaimerPage {
    constructor(navCtrl, logger, emailProvider, externalLinkProvider, persistenceProvider, translate) {
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.emailProvider = emailProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.hasEmail = this.emailProvider.getEmailIfEnabled() ? true : false;
        this.accepted = {
            first: false,
            second: false,
            third: this.hasEmail ? false : true
        };
        this.terms = {
            accepted: false
        };
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: DisclaimerPage');
    }
    selectTerms() {
        this.terms.accepted = !this.terms.accepted;
    }
    openDisclaimer() {
        let url = 'https://bitpay.com/about/terms#wallet';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Wallet Terms of Use');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openPrivacyPolicy() {
        let url = 'https://bitpay.com/about/privacy';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Privacy Policy');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    confirm() {
        this.persistenceProvider.setEmailLawCompliance('accepted');
        this.persistenceProvider.setDisclaimerAccepted();
        this.persistenceProvider.setSurveyFlag();
        this.persistenceProvider.setEthLiveCardFlag();
        this.navCtrl.setRoot(__WEBPACK_IMPORTED_MODULE_5__tabs_tabs__["a" /* TabsPage */]);
        this.navCtrl.popToRoot({ animate: false });
    }
};
DisclaimerPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-disclaimer',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/onboarding/disclaimer/disclaimer.html"*/'<wide-header-page title="{{\'Please review\' | translate}}">\n  <div page-content>\n    <ion-list class="checkbox-list" no-lines>\n      <ion-item>\n        <ion-label>\n          {{\'I understand that my funds are held securely on this device, not by a company\' | translate}}.\n        </ion-label>\n        <ion-checkbox [(ngModel)]="accepted.first"></ion-checkbox>\n      </ion-item>\n      <ion-item>\n        <ion-label>\n          {{\'I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the recovery phrase\' | translate}}.\n        </ion-label>\n        <ion-checkbox [(ngModel)]="accepted.second"></ion-checkbox>\n      </ion-item>\n      <div *ngIf="hasEmail">\n        <ion-item>\n          <ion-label>\n            <span translate>I give explicit consent to BitPay to use my email address to send me email notifications about payments (and, if selected, email updates and news about the wallet).</span>\n          </ion-label>\n          <ion-checkbox [(ngModel)]="accepted.third"></ion-checkbox>\n        </ion-item>\n        <a class="external-link" (click)="openPrivacyPolicy()" translate>View Privacy Policy</a>\n      </div>\n    </ion-list>\n  </div>\n  <div footer-content>\n    <ion-toolbar>\n      <div class="checkbox-list footer-container">\n        <div *ngIf="accepted.first && accepted.second && accepted.third">\n          <ion-item no-lines>\n            <ion-label>\n              {{\'I have read, understood, and agree to the Terms of Use\' | translate}}.\n            </ion-label>\n            <ion-checkbox [(ngModel)]="terms.accepted"></ion-checkbox>\n          </ion-item>\n          <a class="external-link" (click)="openDisclaimer()" translate>View complete Terms of Use</a>\n        </div>\n        <button ion-button class="button-standard" [disabled]="!accepted.first || !accepted.second || !accepted.third || !terms.accepted" (click)="confirm()">\n          <span translate>Confirm &amp; Finish</span>\n        </button>\n      </div>\n    </ion-toolbar>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/onboarding/disclaimer/disclaimer.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], DisclaimerPage);

//# sourceMappingURL=disclaimer.js.map

/***/ }),

/***/ 476:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_address_book_address_book__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_gift_card_gift_card__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_index__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_time_time__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__pages_backup_backup_key_backup_key__ = __webpack_require__(334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__pages_home_proposals_proposals__ = __webpack_require__(474);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_wallet_addresses__ = __webpack_require__(472);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__pages_tx_details_tx_details__ = __webpack_require__(1031);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__wallet_tabs_wallet_tabs_child__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__wallet_tabs_wallet_tabs_provider__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__search_tx_modal_search_tx_modal__ = __webpack_require__(1032);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__wallet_balance_wallet_balance__ = __webpack_require__(1033);





// providers










// pages








const HISTORY_SHOW_LIMIT = 10;
const MIN_UPDATE_TIME = 2000;
const TIMEOUT_FOR_REFRESHER = 1000;
let WalletDetailsPage = class WalletDetailsPage extends __WEBPACK_IMPORTED_MODULE_19__wallet_tabs_wallet_tabs_child__["a" /* WalletTabsChild */] {
    constructor(currencyProvider, navCtrl, navParams, profileProvider, walletProvider, addressbookProvider, events, giftCardProvider, logger, timeProvider, translate, modalCtrl, onGoingProcessProvider, externalLinkProvider, walletTabsProvider, actionSheetProvider, platform) {
        super(navCtrl, profileProvider, walletTabsProvider);
        this.currencyProvider = currencyProvider;
        this.navParams = navParams;
        this.walletProvider = walletProvider;
        this.addressbookProvider = addressbookProvider;
        this.events = events;
        this.giftCardProvider = giftCardProvider;
        this.logger = logger;
        this.timeProvider = timeProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.platform = platform;
        this.currentPage = 0;
        this.showBackupNeededMsg = true;
        this.history = [];
        this.groupedHistory = [];
        this.updatingTxHistoryProgress = 0;
        this.showBalanceButton = false;
        this.addressbook = {};
        this.txps = [];
        this.updateAll = __WEBPACK_IMPORTED_MODULE_4_lodash__["debounce"]((opts) => {
            opts = opts || {};
            this.events.publish('Local/WalletFocus', {
                walletId: this.wallet.credentials.walletId,
                force: true
            });
        }, MIN_UPDATE_TIME, {
            leading: true
        });
        // no network //
        this.updateHistory = opts => {
            this.logger.debug('RECV Local/WalletHistoryUpdate @walletDetails', opts);
            if (opts.walletId != this.wallet.id)
                return;
            if (opts.finished) {
                this.updatingTxHistoryProgress = 0;
                this.updatingTxHistory = false;
                this.updateTxHistoryError = false;
                const hasTx = !!this.wallet.completeHistory[0];
                this.showNoTransactionsYetMsg = !hasTx;
                if (this.wallet.needsBackup && hasTx && this.showBackupNeededMsg)
                    this.openBackupModal();
                this.showHistory();
            }
            else {
                if (opts.error) {
                    this.updatingTxHistory = false;
                    this.updateTxHistoryError = true;
                    // show what we have.
                    this.showHistory();
                }
                else {
                    this.updatingTxHistory = true;
                    this.updatingTxHistoryProgress = opts.progress;
                    this.updateTxHistoryError = false;
                    // show what we have
                    this.showHistory();
                    // Hide prev history if long downlad is happending...
                    //  if (opts.progress > 5) {
                    //  this.history = null;
                    //  }
                }
            }
        };
        // no network //
        this.updateStatus = opts => {
            if (opts.walletId != this.wallet.id)
                return;
            this.logger.debug('RECV Local/WalletUpdate @walletDetails', opts);
            if (!opts.finished) {
                this.updatingStatus = true;
                return;
            }
            this.updatingStatus = false;
            if (!this.wallet.error) {
                this.logger.debug(' Updating wallet with amount ', this.wallet.cachedStatus.balance.totalAmount);
                let status = this.wallet.cachedStatus;
                this.setPendingTxps(status.pendingTxps);
                this.showBalanceButton = status.totalBalanceSat != status.spendableAmount;
                if (this.isUtxoCoin()) {
                    this.analyzeUtxos();
                }
                this.updateStatusError = null;
                this.walletNotRegistered = false;
            }
            else {
                this.showBalanceButton = false;
                let err = this.wallet.errorObj;
                if (err.name && err.name.match(/WALLET_NOT_FOUND/)) {
                    this.walletNotRegistered = true;
                }
                if (err === 'WALLET_NOT_REGISTERED') {
                    this.walletNotRegistered = true;
                }
                else {
                    this.updateStatusError = this.wallet.errorObj;
                }
            }
        };
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
    }
    ionViewDidLoad() {
        // Getting info from cache
        if (this.navParams.data.clearCache) {
            this.clearHistoryCache();
        }
        else {
            if (this.wallet.completeHistory)
                this.showHistory();
        }
        this.requiresMultipleSignatures = this.wallet.credentials.m > 1;
        this.supportedCards = this.giftCardProvider.getSupportedCardMap();
        this.addressbookProvider
            .list()
            .then(ab => {
            this.addressbook = ab;
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    subscribeEvents() {
        this.events.subscribe('Local/WalletUpdate', this.updateStatus);
        this.events.subscribe('Local/WalletHistoryUpdate', this.updateHistory);
    }
    // Event handling
    ionViewWillLoad() {
        this.subscribeEvents();
    }
    ionViewWillEnter() {
        this.onResumeSubscription = this.platform.resume.subscribe(() => {
            this.profileProvider.setFastRefresh(this.wallet);
            this.subscribeEvents();
        });
    }
    // Start by firing a walletFocus event.
    ionViewDidEnter() {
        this.profileProvider.setFastRefresh(this.wallet);
        this.events.publish('Local/WalletFocus', {
            walletId: this.wallet.credentials.walletId
        });
    }
    ionViewWillUnload() {
        this.profileProvider.setSlowRefresh(this.wallet);
        this.events.unsubscribe('Local/WalletUpdate', this.updateStatus);
        this.events.unsubscribe('Local/WalletHistoryUpdate', this.updateHistory);
        this.onResumeSubscription.unsubscribe();
    }
    shouldShowZeroState() {
        return this.showNoTransactionsYetMsg && !this.updateStatusError;
    }
    shouldShowSpinner() {
        return ((this.updatingStatus || this.updatingTxHistory) &&
            !this.walletNotRegistered &&
            !this.updateStatusError &&
            !this.updateTxHistoryError);
    }
    isUtxoCoin() {
        return this.currencyProvider.isUtxoCoin(this.wallet.coin);
    }
    clearHistoryCache() {
        this.history = [];
        this.currentPage = 0;
    }
    groupHistory(history) {
        return history.reduce((groups, tx, txInd) => {
            this.isFirstInGroup(txInd)
                ? groups.push([tx])
                : groups[groups.length - 1].push(tx);
            return groups;
        }, []);
    }
    showHistory(loading) {
        if (!this.wallet.completeHistory)
            return;
        this.history = this.wallet.completeHistory.slice(0, (this.currentPage + 1) * HISTORY_SHOW_LIMIT);
        this.zone.run(() => {
            this.groupedHistory = this.groupHistory(this.history);
        });
        if (loading)
            this.currentPage++;
    }
    setPendingTxps(txps) {
        this.txps = !txps ? [] : __WEBPACK_IMPORTED_MODULE_4_lodash__["sortBy"](txps, 'createdOn').reverse();
        this.txpsPending = [];
        this.txps.forEach(txp => {
            const action = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](txp.actions, {
                copayerId: txp.wallet.copayerId
            });
            if (!action && txp.status == 'pending') {
                this.txpsPending.push(txp);
            }
            // For unsent transactions
            if (action && txp.status == 'accepted') {
                this.txpsPending.push(txp);
            }
        });
    }
    openProposalsPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__pages_home_proposals_proposals__["a" /* ProposalsPage */], { walletId: this.wallet.id });
    }
    toggleBalance() {
        this.profileProvider.toggleHideBalanceFlag(this.wallet.credentials.walletId);
    }
    loadHistory(loading) {
        if (this.history &&
            this.wallet.completeHistory &&
            this.history.length === this.wallet.completeHistory.length) {
            loading.complete();
            return;
        }
        setTimeout(() => {
            this.showHistory(true); // loading in true
            loading.complete();
        }, 300);
    }
    analyzeUtxos() {
        if (this.analyzeUtxosDone)
            return;
        this.walletProvider
            .getLowUtxos(this.wallet)
            .then(resp => {
            if (!resp)
                return;
            this.analyzeUtxosDone = true;
            this.lowUtxosWarning = !!resp.warning;
            // this.logger.debug('Low UTXOs warning: ', this.lowUtxosWarning);
        })
            .catch(err => {
            this.logger.warn('Analyze UTXOs: ', err);
        });
    }
    recreate() {
        this.onGoingProcessProvider.set('recreating');
        this.walletProvider
            .recreate(this.wallet)
            .then(() => {
            this.onGoingProcessProvider.clear();
            setTimeout(() => {
                this.walletProvider.startScan(this.wallet).then(() => {
                    this.updateAll({ force: true });
                });
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error(err);
        });
    }
    goToTxDetails(tx) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__pages_tx_details_tx_details__["a" /* TxDetailsPage */], {
            walletId: this.wallet.credentials.walletId,
            txid: tx.txid
        });
    }
    openBackupModal() {
        this.showBackupNeededMsg = false;
        const infoSheet = this.actionSheetProvider.createInfoSheet('backup-needed-with-activity');
        infoSheet.present();
        infoSheet.onDidDismiss(option => {
            if (option)
                this.openBackup();
        });
    }
    openBackup() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_15__pages_backup_backup_key_backup_key__["a" /* BackupKeyPage */], {
            keyId: this.wallet.credentials.keyId
        });
    }
    openAddresses() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_wallet_addresses__["a" /* WalletAddressesPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    getDate(txCreated) {
        const date = new Date(txCreated * 1000);
        return date;
    }
    trackByFn(index) {
        return index;
    }
    isFirstInGroup(index) {
        if (index === 0) {
            return true;
        }
        const curTx = this.history[index];
        const prevTx = this.history[index - 1];
        return !this.createdDuringSameMonth(curTx, prevTx);
    }
    createdDuringSameMonth(curTx, prevTx) {
        return this.timeProvider.withinSameMonth(curTx.time * 1000, prevTx.time * 1000);
    }
    isDateInCurrentMonth(date) {
        return this.timeProvider.isDateInCurrentMonth(date);
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
    isUnconfirmed(tx) {
        return !tx.confirmations || tx.confirmations === 0;
    }
    openBalanceDetails() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_22__wallet_balance_wallet_balance__["a" /* WalletBalancePage */], {
            status: this.wallet.cachedStatus
        });
    }
    back() {
        this.navCtrl.pop();
    }
    openSearchModal() {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_21__search_tx_modal_search_tx_modal__["a" /* SearchTxModalPage */], {
            addressbook: this.addressbook,
            completeHistory: this.wallet.completeHistory,
            wallet: this.wallet
        }, { showBackdrop: false, enableBackdropDismiss: true });
        modal.present();
        modal.onDidDismiss(data => {
            if (!data || !data.txid)
                return;
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__pages_tx_details_tx_details__["a" /* TxDetailsPage */], {
                walletId: this.wallet.credentials.walletId,
                txid: data.txid
            });
        });
    }
    openExternalLink(url) {
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Help and support information is available at the website.');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    doRefresh(refresher) {
        this.updateAll({ force: true });
        setTimeout(() => {
            refresher.complete();
        }, TIMEOUT_FOR_REFRESHER);
    }
};
WalletDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-wallet-details',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/wallet-details/wallet-details.html"*/'<ion-header no-border class="wallet-details-header">\n  <ion-navbar class="app-color">\n    <ion-buttons left>\n      <button class="modal-close-button" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n    <ion-title left>{{wallet.name}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce #scrollArea [fixed-scroll-bg-color]="\'#14245E\'">\n  <ion-refresher (ionRefresh)="doRefresh($event)" [ngStyle]="{\'background\': \'#14245E\'}" pullMin="90" pullMax="180">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="wrapper wrapper--feather">\n    <expandable-header class="balance-card" [scrollArea]="scrollArea">\n      <expandable-header-primary class="balance-header">\n\n        <div *ngIf="wallet.network == \'testnet\'" class="top-notification warning">\n          <a class="energized" (click)="openExternalLink(\'https://support.bitpay.com/hc/en-us/articles/360004102011-What-is-testnet-How-do-I-avoid-testnet-Bitcoin-scams-\')">\n            {{\'Learn more about testnet blockchain\' | translate}}\n            <ion-icon name="arrow-forward"></ion-icon>\n          </a>\n        </div>\n\n        <div *ngIf="lowUtxosWarning && wallet.network == \'livenet\'" class="top-notification warning">\n          <a class="energized" (click)="openAddresses()">\n            {{\'Spending this balance will need significant Bitcoin network fees\'|translate}}\n            <ion-icon name="arrow-forward"></ion-icon>\n          </a>\n        </div>\n\n        <div (longPress)="toggleBalance()">\n          <div (tap)="updateAll(true)" *ngIf="!wallet.balanceHidden && !wallet.scanning && !walletNotRegistered && (wallet.cachedStatus || wallet.lastKnownBalance)">\n            <div class="balance-str">\n              {{ wallet.cachedStatus ? wallet.cachedStatus.totalBalanceStr  : wallet.lastKnownBalance }} </div>\n            <div class="balance-alt-str" *ngIf="wallet.cachedStatus && wallet.cachedStatus.totalBalanceAlternative">\n              {{wallet.cachedStatus.totalBalanceAlternative}} {{wallet.cachedStatus.alternativeIsoCode}}\n            </div>\n            <div class="balance-alt-str" *ngIf="!wallet.scanning && !wallet.cachedStatus && wallet.lastKnownBalanceUpdatedOn">\n              {{ wallet.lastKnownBalanceUpdatedOn * 1000 | amTimeAgo }}\n            </div>\n\n          </div>\n\n          <div class="balance-hidden" *ngIf="!updateStatusError && wallet.balanceHidden  && !wallet.scanning">\n            <span class="title" translate>[Balance Hidden]</span>\n            <div translate>\n              Tap and hold to show\n            </div>\n          </div>\n        </div>\n\n        <div class="balance-scanning" *ngIf="!updateStatusError && wallet.scanning">\n          <span class="title" translate>[Scanning Funds]</span>\n          <div translate>\n            Please wait...\n          </div>\n        </div>\n\n        <div class="balance-spendable" (click)="openBalanceDetails()" *ngIf="!wallet.balanceHidden && !wallet.scanning && !updateStatusError && showBalanceButton">\n          <ion-icon ios="ios-timer-outline" md="md-timer"></ion-icon>\n          <strong>\n            {{wallet.cachedStatus.spendableBalanceStr}}\n          </strong>\n          &nbsp;\n          <span>\n            ({{wallet.cachedStatus.spendableBalanceAlternative}} {{wallet.cachedStatus.alternativeIsoCode}})\n          </span>\n          &rarr;\n        </div>\n\n        <div class="balance-error" *ngIf="updateStatusError">\n          <div>\n            <span>{{wallet.error}}</span>\n          </div>\n        </div>\n\n        <div class="balance-error" *ngIf="walletNotRegistered" (tap)="recreate()">\n          <span class="title" translate>Tap to recreate</span>\n          <div translate>\n            This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.\n          </div>\n        </div>\n      </expandable-header-primary>\n      <expandable-header-footer class="wallet-info" *ngIf="wallet" style="display: flex; align-items: center">\n\n        <div class="left-buttons">\n          <img class="testnet" *ngIf="wallet.network == \'testnet\'" src="assets/img/icon-wallet-testnet.svg">\n          <img class="testnet-text" *ngIf="wallet.network == \'testnet\'" src="assets/img/icon-text-testnet.svg">\n          <img class="read-only" *ngIf="!wallet.canSign" src="assets/img/settings-icons/icon-read-only.svg">\n          <img class="read-only-text" *ngIf="!wallet.canSign" src="assets/img/icon-text-read-only.svg">\n          <img class="auditable-text" *ngIf="wallet.cachedStatus && wallet.cachedStatus.wallet && wallet.cachedStatus.wallet.singleAddress && isUtxoCoin()" src="assets/img/icon-text-auditable.svg">\n          <img class="custom-bws" *ngIf="wallet.usingCustomBWS" src="assets/img/icon-bws-white.svg">\n          <img class="encrypted" *ngIf="wallet.isPrivKeyEncrypted" src="assets/img/icon-lock-white.svg">\n          <span class="token" *ngIf="wallet.linkedEthWalletName">\n            <span>{{\'Linked to wallet: {linkedEthWalletName}\' | translate : {linkedEthWalletName: wallet.linkedEthWalletName} }}</span>\n          </span>\n          <span class="wallet-type" *ngIf="wallet.credentials.n > 1">\n            <span translate>{{wallet.m}}-of-{{wallet.n}}</span>\n          </span>\n        </div>\n\n        <button ion-button clear class="search-button" *ngIf="wallet && wallet.completeHistory && wallet.completeHistory.length > 4 && !shouldShowSpinner()" (click)="openSearchModal()">\n          <img src="assets/img/search.svg">\n        </button>\n        <ion-spinner name="crescent" *ngIf="shouldShowSpinner()"></ion-spinner>\n\n      </expandable-header-footer>\n\n    </expandable-header>\n\n    <div class="fix-margin">\n      <div class="history-wrapper">\n\n        <ion-list *ngIf="wallet && wallet.isComplete() && !walletNotRegistered && txps && txps[0]" class="tx-history">\n          <ion-item-divider *ngIf="wallet.incorrectDerivation">\n            <span translate>\n              WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.\n            </span>\n          </ion-item-divider>\n          <ion-item-divider class="tx-history-header tx-history-header--large">\n            <span *ngIf="requiresMultipleSignatures" translate>Pending Proposals</span>\n            <span *ngIf="!requiresMultipleSignatures" translate>Unsent transactions</span>\n            <button ion-button clear icon-only class="txps-badge" *ngIf="txps.length > 0" (click)="openProposalsPage()">\n              <ion-badge>{{txps.length}}</ion-badge>\n            </button>\n          </ion-item-divider>\n          <div *ngFor="let txp of txpsPending;  let i=index">\n            <page-txp *ngIf="i<=2" [tx]="txp" [addressbook]="addressbook"></page-txp>\n          </div>\n          <ion-item *ngIf="wallet.cachedStatus && wallet.cachedStatus.lockedBalanceSat" class="locked-balance" (click)="openBalanceDetails()">\n            <span translate>Total Locked Balance</span>\n            <ion-note item-end>\n              <span class="total-locked-amount">{{wallet.cachedStatus.lockedBalanceStr}}</span>\n              <div class="total-alt-locked-amount">{{wallet.cachedStatus.lockedBalanceAlternative}}\n                {{wallet.cachedStatus.alternativeIsoCode}}</div>\n            </ion-note>\n          </ion-item>\n        </ion-list>\n\n        <!-- Transactions -->\n\n\n        <div class="prompt-user activity-fix white-card" *ngIf="shouldShowZeroState()">\n          <div class="title-icon larger-icon">\n            <img src="assets/img/ghost-tongue-out.svg" />\n          </div>\n          <div class="title-info">\n            <span translate>It\'s a ghost town in here</span>\n          </div>\n          <div class="subtitle-info">\n            <span translate>\n              If you have funds stored on a website then you should move them into a secure wallet... like this one!\n            </span>\n          </div>\n        </div>\n\n        <div class="middle-message white-card" *ngIf="updateTxHistoryError" translate>\n          Could not update transaction history\n        </div>\n\n        <div class="middle-message white-card" *ngIf="updatingTxHistory && (!history[0] || updatingTxHistoryProgress>4)">\n          <span translate>Updating transaction history. Please stand by.</span>\n          <br>\n          <span translate *ngIf="updatingTxHistoryProgress>4">{{updatingTxHistoryProgress}} transactions downloaded</span>\n        </div>\n\n        <ion-list *ngIf="history && history[0]" class="tx-history">\n          <ion-item-group *ngFor="let group of groupedHistory; trackBy: trackByFn; let i = index;">\n\n            <ion-item-divider sticky class="tx-history-header">\n              <span translate *ngIf="isDateInCurrentMonth(getDate(group[0].time))">Recent</span>\n              <span *ngIf="!isDateInCurrentMonth(getDate(group[0].time))">{{getDate(group[0].time) |\n                amDateFormat:\'MMMM\'}}</span>\n            </ion-item-divider>\n\n            <div class="item-wrapper" *ngFor="let tx of group; trackBy: trackByFn; let i = index">\n\n              <button ion-item (click)="goToTxDetails(tx)">\n                <ion-icon class="item-img" item-start>\n                  <div *ngIf="tx.confirmations <= 0">\n                    <img src="assets/img/tx-action/icon-confirming.svg" width="40">\n                  </div>\n                  <div *ngIf="tx.confirmations > 0">\n                    <span *ngIf="tx.customData && tx.customData.service">\n                      <img class="icon-services" src="assets/img/shapeshift/icon-shapeshift.svg" *ngIf="tx.customData.service == \'shapeshift\'" width="40">\n                      <img-loader class="icon-services" *ngIf="tx.customData.service === \'amazon\'" src="https://bitpay.com/gift-cards/assets/amazoncom/icon.svg" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                      <img-loader class="icon-services" *ngIf="tx.customData.service === \'mercadolibre\'" src="https://bitpay.com/gift-cards/assets/mercadolivre/icon.svg" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                      <ng-container *ngIf="supportedCards | async as cardConfig">\n                        <img-loader class="icon-services" *ngIf="tx.customData.service === \'giftcards\'" [src]="cardConfig[tx.customData.giftCardName]?.icon" width="40" fallbackUrl="assets/img/gift-cards/gift-cards-icon.svg"></img-loader>\n                      </ng-container>\n                      <img class="icon-services" src="assets/img/bitpay-card/icon-bitpay.svg" *ngIf="tx.customData.service == \'debitcard\'" width="40">\n                    </span>\n                    <span *ngIf="tx.customData && tx.customData.toWalletName && !tx.customData.service">\n                      <img class="icon-services" src="assets/img/icon-wallet-reverse.svg" *ngIf="tx.action == \'sent\'" width="40">\n                    </span>\n                    <span *ngIf="!tx.customData || (tx.customData && !tx.customData.service && !tx.customData.toWalletName)">\n                      <img src="assets/img/tx-action/icon-sent.svg" *ngIf="tx.action == \'sent\'" width="40">\n                    </span>\n                    <span>\n                      <img src="assets/img/tx-action/icon-received.svg" *ngIf="tx.action == \'received\'" width="40">\n                      <img src="assets/img/tx-action/icon-moved.svg" *ngIf="tx.action == \'moved\'" width="40">\n                    </span>\n                  </div>\n                </ion-icon>\n\n                <div class="action" *ngIf="tx.confirmations <= 0">\n                  <span *ngIf="(tx.action == \'sent\') && !(addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address])">{{\'Sending\'\n                    | translate}}</span>\n                  <span *ngIf="(tx.action == \'moved\') && !(addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address])">{{\'Moving\'\n                    | translate}}</span>\n                  <span *ngIf="(tx.action == \'sent\' || tx.action == \'moved\') && (addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address])">{{addressbook[tx.outputs[0].address].name\n                    || addressbook[tx.outputs[0].address]}}</span>\n                  <span *ngIf="tx.action == \'received\'">{{\'Receiving\' | translate}}</span>\n                </div>\n\n                <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'received\'">\n                  <span *ngIf="(!tx.note || (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address])">{{\'Received\'\n                    | translate}}</span>\n                  <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n                  <span *ngIf="addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address]">\n                    {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n                  </span>\n                </div>\n\n                <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'sent\'">\n                  <span *ngIf="(tx.message && (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address]) && (!tx.customData || !tx.customData.toWalletName)" translate>Sent</span>\n                  <span *ngIf="!tx.message && (!tx.note || (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address]) && (!tx.customData || !tx.customData.toWalletName)">{{\'Sent\'\n                    | translate}}</span>\n                  <span *ngIf="!tx.message && (!tx.note || (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address]) && (tx.customData && tx.customData.toWalletName)">\n                    {{ \'Sent to {walletName}\' | translate: {walletName: tx.customData.toWalletName} }}\n                  </span>\n                  <span *ngIf="!tx.note && tx.message">{{tx.message}}</span>\n                  <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n                  <span *ngIf="!tx.message && addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address]">\n                    {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n                  </span>\n                </div>\n\n                <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'moved\'">\n                  <span *ngIf="(tx.message && (tx.note && !tx.note.body))" translate>Moved</span>\n                  <span *ngIf="((!tx.note || (tx.note && !tx.note.body)) && !tx.message)" translate>Moved</span>\n                  <span *ngIf="!tx.note && tx.message">{{tx.message}}</span>\n                  <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n                </div>\n\n                <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'invalid\'">\n                  <span class="assertive" *ngIf="!tx.message && !tx.note" translate>Invalid</span>\n                </div>\n\n                <ion-note item-end text-end>\n                  <div class="amount">\n                    <span [ngClass]="{\'received\': tx.action == \'received\'}" *ngIf="tx.action != \'invalid\'">{{tx.amount |\n                      satToUnit: wallet.coin}}</span>\n                    <span class="double-spend" *ngIf="tx.action == \'invalid\'" translate>(possible double spend)</span>\n                  </div>\n                  <div class="date">\n                    <span *ngIf="tx.time && createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amTimeAgo}}</span>\n                    <span *ngIf="tx.time && !createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amDateFormat:\'MMM\n                      D, YYYY\'}}</span>\n                  </div>\n                </ion-note>\n              </button>\n            </div>\n          </ion-item-group>\n        </ion-list>\n\n        <ion-infinite-scroll (ionInfinite)="loadHistory($event)" *ngIf="!shouldShowZeroState()">\n          <ion-infinite-scroll-content></ion-infinite-scroll-content>\n        </ion-infinite-scroll>\n\n      </div>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/wallet-details/wallet-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_8__providers_gift_card_gift_card__["a" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_13__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_20__wallet_tabs_wallet_tabs_provider__["a" /* WalletTabsProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_index__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* Platform */]])
], WalletDetailsPage);

//# sourceMappingURL=wallet-details.js.map

/***/ }),

/***/ 486:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 486;

/***/ }),

/***/ 49:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BwcErrorProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);



let BwcErrorProvider = class BwcErrorProvider {
    constructor(translate) {
        this.translate = translate;
    }
    msg(err, prefix) {
        if (!err)
            return 'Unknown error';
        const name = err.name
            ? err.name === 'Error'
                ? err.message
                : err.name.replace(/^bwc.Error/g, '')
            : err;
        let body = '';
        prefix = prefix || '';
        switch (name) {
            case 'UNCONFIRMED_INPUTS_NOT_ACCEPTED':
                body = this.translate.instant('This invoice does not accept unconfirmed inputs.');
                break;
            case 'INVOICE_EXPIRED':
                body = this.translate.instant('This invoice is not longer accepting payments');
                break;
            case 'INVALID_BACKUP':
                body = this.translate.instant('Wallet Recovery Phrase is invalid');
                break;
            case 'WALLET_DOES_NOT_EXIST':
                body = this.translate.instant('Wallet not registered at the wallet service. Recreate it from "Create Wallet" using "Advanced Options" to set your recovery phrase');
                break;
            case 'MISSING_PRIVATE_KEY':
                body = this.translate.instant('Missing private keys to sign');
                break;
            case 'ENCRYPTED_PRIVATE_KEY':
                body = this.translate.instant('Private key is encrypted, cannot sign');
                break;
            case 'SERVER_COMPROMISED':
                body = this.translate.instant('Server response could not be verified');
                break;
            case 'COULD_NOT_BUILD_TRANSACTION':
                body = this.translate.instant('Could not build transaction');
                break;
            case 'INSUFFICIENT_FUNDS':
                body = this.translate.instant('Insufficient funds');
                break;
            case 'MAINTENANCE_ERROR':
                body = this.translate.instant('Bitcore Wallet Service is under maintenance. Please check https://status.bitpay.com/.');
                break;
            case 'CONNECTION_ERROR':
                body = this.translate.instant('Network error');
                break;
            case 'NOT_FOUND':
                body = this.translate.instant('Wallet service not found');
                break;
            case 'ECONNRESET_ERROR':
                body = this.translate.instant('Connection reset by peer');
                break;
            case 'BAD_RESPONSE_CODE':
                body = this.translate.instant('The request could not be understood by the server');
                break;
            case 'WALLET_ALREADY_EXISTS':
                body = this.translate.instant('Wallet already exists');
                break;
            case 'COPAYER_IN_WALLET':
                body = this.translate.instant('Copayer already in this wallet');
                break;
            case 'WALLET_FULL':
                body = this.translate.instant('Wallet is full');
                break;
            case 'WALLET_NOT_FOUND':
                body = this.translate.instant('Wallet not found');
                break;
            case 'INSUFFICIENT_FUNDS_FOR_FEE':
                body = this.translate.instant('Insufficient funds for fee');
                break;
            case 'LOCKED_FUNDS':
                body = this.translate.instant('Funds are locked by pending spend proposals');
                break;
            case 'COPAYER_VOTED':
                body = this.translate.instant('Copayer already voted on this spend proposal');
                break;
            case 'NOT_AUTHORIZED':
                body = this.translate.instant('Not authorized');
                break;
            case 'TX_ALREADY_BROADCASTED':
                body = this.translate.instant('Transaction already broadcasted');
                break;
            case 'TX_CANNOT_CREATE':
                body = this.translate.instant('Locktime in effect. Please wait to create a new spend proposal');
                break;
            case 'TX_CANNOT_REMOVE':
                body = this.translate.instant('Locktime in effect. Please wait to remove this spend proposal');
                break;
            case 'TX_NOT_ACCEPTED':
                body = this.translate.instant('Spend proposal is not accepted');
                break;
            case 'TX_NOT_FOUND':
                body = this.translate.instant('Spend proposal not found');
                break;
            case 'TX_NOT_PENDING':
                body = this.translate.instant('The spend proposal is not pending');
                break;
            case 'UPGRADE_NEEDED':
                body = this.translate.instant('Please upgrade the app to perform this action');
                break;
            case 'BAD_SIGNATURES':
                body = this.translate.instant('Signatures rejected by server');
                break;
            case 'COPAYER_DATA_MISMATCH':
                body = this.translate.instant('Copayer data mismatch');
                break;
            case 'DUST_AMOUNT':
                body = this.translate.instant('Amount below minimum allowed');
                break;
            case 'INCORRECT_ADDRESS_NETWORK':
                body = this.translate.instant('Incorrect network address');
                break;
            case 'COPAYER_REGISTERED':
                body = this.translate.instant('Key already associated with an existing wallet');
                break;
            case 'INVALID_ADDRESS':
                body = this.translate.instant('Invalid address');
                break;
            case 'MAIN_ADDRESS_GAP_REACHED':
                body = this.translate.instant('Empty addresses limit reached. New addresses cannot be generated.');
                break;
            case 'WALLET_LOCKED':
                body = this.translate.instant('Wallet is locked');
                break;
            case 'WALLET_NOT_COMPLETE':
                body = this.translate.instant('Wallet is not complete');
                break;
            case 'WALLET_NEEDS_BACKUP':
                body = this.translate.instant('Wallet needs backup');
                break;
            case 'MISSING_PARAMETER':
                body = this.translate.instant('Missing parameter');
                break;
            case 'NO_PASSWORD':
                body = this.translate.instant('No password');
                break;
            case 'WRONG_PASSWORD':
                body = this.translate.instant('Wrong password');
                break;
            case 'EXCEEDED_DAILY_LIMIT':
                body = this.translate.instant('Exceeded daily limit of $500 per user');
                break;
            case 'ERROR':
                body = err.message || err.error;
                break;
            default:
                body = err.message || name;
                break;
        }
        var msg = prefix + (prefix ? ': ' : '') + body;
        return msg;
    }
};
BwcErrorProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], BwcErrorProvider);

//# sourceMappingURL=bwc-error.js.map

/***/ }),

/***/ 533:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 533;

/***/ }),

/***/ 66:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeyProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__popup_popup__ = __webpack_require__(18);




// Providers




let KeyProvider = class KeyProvider {
    constructor(logger, bwcProvider, popupProvider, persistenceProvider, translate) {
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.popupProvider = popupProvider;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.Key = this.bwcProvider.getKey();
        this.logger.debug('KeyProvider initialized');
        this.isDirty = false;
    }
    load() {
        return this.persistenceProvider.getKeys().then((keys) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.keys = [];
            keys = keys ? keys : [];
            if (typeof keys === 'string') {
                try {
                    keys = JSON.parse(keys);
                }
                catch (_) {
                    this.logger.warn('Could not parse');
                }
            }
            keys.forEach(k => this.keys.push(this.Key.fromObj(k)));
            return Promise.resolve();
        }));
    }
    storeKeysIfDirty() {
        if (!this.isDirty) {
            this.logger.debug('The keys have not been saved. Not dirty');
            return Promise.resolve();
        }
        const keysToAdd = [];
        this.keys.forEach(k => {
            keysToAdd.push(k.toObj(k));
        });
        return this.persistenceProvider.setKeys(keysToAdd).then(() => {
            this.isDirty = false;
            return Promise.resolve();
        });
    }
    addKey(keyToAdd) {
        if (!keyToAdd)
            return Promise.resolve();
        const keyIndex = this.keys.findIndex(k => this.Key.match(keyToAdd, k));
        if (keyIndex >= 0) {
            this.keys.splice(keyIndex, 1, this.Key.fromObj(keyToAdd));
        }
        else {
            this.keys.push(this.Key.fromObj(keyToAdd));
        }
        this.isDirty = true;
        return this.storeKeysIfDirty();
    }
    addKeys(keysToAdd) {
        keysToAdd.forEach(keyToAdd => {
            if (!this.keys.find(k => this.Key.match(keyToAdd, k))) {
                this.keys.push(this.Key.fromObj(keyToAdd));
                this.isDirty = true;
            }
            else {
                this.logger.warn('Key already added');
            }
        });
        return this.storeKeysIfDirty();
    }
    getKey(keyId) {
        let selectedKey = this.keys.find(k => k.id == keyId);
        if (selectedKey) {
            return selectedKey;
        }
        else {
            this.logger.debug('No matches for key id: ' + keyId);
            return null;
        }
    }
    removeKey(keyId) {
        this.logger.debug('Removing key: ' + keyId);
        if (keyId === 'read-only')
            return Promise.resolve();
        const selectedKey = this.keys.findIndex(k => k.id == keyId);
        if (selectedKey >= 0) {
            this.keys.splice(selectedKey, 1);
            this.isDirty = true;
            return this.storeKeysIfDirty();
        }
        else {
            const err = 'No matches for key id: ' + keyId;
            this.logger.debug(err);
            return Promise.reject(err);
        }
    }
    // An alert dialog
    askPassword(warnMsg, title) {
        const opts = {
            type: 'password',
            useDanger: true
        };
        return this.popupProvider.ionicPrompt(title, warnMsg, opts);
    }
    encrypt(keyId) {
        const key = this.getKey(keyId);
        let title = this.translate.instant('Enter a new encrypt password');
        const warnMsg = this.translate.instant('Your wallet key will be encrypted. The encrypt password cannot be recovered. Be sure to write it down.');
        return this.askPassword(warnMsg, title).then((password) => {
            if (password == '' || __WEBPACK_IMPORTED_MODULE_3_lodash__["isNull"](password)) {
                return Promise.reject(this.translate.instant('No password'));
            }
            title = this.translate.instant('Confirm your new encrypt password');
            return this.askPassword(warnMsg, title).then((password2) => {
                if (password != password2 || __WEBPACK_IMPORTED_MODULE_3_lodash__["isNull"](password2)) {
                    return Promise.reject(this.translate.instant('Password mismatch'));
                }
                try {
                    this.encryptPrivateKey(key, password);
                }
                catch (error) {
                    return Promise.reject(error);
                }
                return Promise.resolve();
            });
        });
    }
    encryptNewKey(key) {
        let title = this.translate.instant('Enter a password to encrypt your wallet');
        const warnMsg = this.translate.instant('This password is only for this device, and it cannot be recovered. To avoid losing funds, write your password down.');
        return this.askPassword(warnMsg, title).then((password) => {
            if (!password) {
                return this.showWarningNoEncrypt().then(res => {
                    if (res)
                        return Promise.resolve();
                    return this.encryptNewKey(key);
                });
            }
            else {
                title = this.translate.instant('Enter your encrypt password again to confirm');
                return this.askPassword(warnMsg, title).then((password2) => {
                    if (!password2 || password != password2) {
                        return this.encryptNewKey(key);
                    }
                    else {
                        try {
                            this.encryptPrivateKey(key, password);
                        }
                        catch (error) {
                            return Promise.reject(error);
                        }
                        return Promise.resolve(password);
                    }
                });
            }
        });
    }
    showWarningNoEncrypt() {
        const title = this.translate.instant('Are you sure?');
        const msg = this.translate.instant('Without encryption, a thief or another application on this device may be able to access your funds.');
        const okText = this.translate.instant("I'm sure");
        const cancelText = this.translate.instant('Go Back');
        return this.popupProvider.ionicConfirm(title, msg, okText, cancelText);
    }
    decrypt(keyId) {
        const key = this.getKey(keyId);
        return this.askPassword(null, this.translate.instant('Enter encrypt password')).then((password) => {
            if (password == '' || __WEBPACK_IMPORTED_MODULE_3_lodash__["isNull"](password)) {
                return Promise.reject(this.translate.instant('No password'));
            }
            try {
                this.decryptPrivateKey(key, password);
            }
            catch (e) {
                return Promise.reject(this.translate.instant('Wrong password'));
            }
            return Promise.resolve();
        });
    }
    handleEncryptedWallet(keyId) {
        if (!keyId) {
            return Promise.resolve();
        }
        const key = this.getKey(keyId);
        const isPrivKeyEncrypted = this.isPrivKeyEncrypted(keyId);
        if (!isPrivKeyEncrypted)
            return Promise.resolve();
        return this.askPassword(null, this.translate.instant('Enter encrypt password')).then((password) => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isNull"](password)) {
                return Promise.reject(new Error('PASSWORD_CANCELLED'));
            }
            else if (password == '') {
                return Promise.reject(new Error('NO_PASSWORD'));
            }
            else if (!key.checkPassword(password)) {
                return Promise.reject(new Error('WRONG_PASSWORD'));
            }
            else {
                return Promise.resolve(password);
            }
        });
    }
    isPrivKeyEncrypted(keyId) {
        if (!keyId)
            return false;
        const key = this.getKey(keyId);
        return key ? key.isPrivKeyEncrypted() : undefined;
    }
    isDeletedSeed(keyId) {
        if (!keyId)
            return true;
        const key = this.getKey(keyId);
        return !key || (!key.mnemonic && !key.mnemonicEncrypted);
    }
    mnemonicHasPassphrase(keyId) {
        if (!keyId)
            return false;
        const key = this.getKey(keyId);
        return key.mnemonicHasPassphrase;
    }
    get(keyId, password) {
        const key = this.getKey(keyId);
        return key.get(password);
    }
    getBaseAddressDerivationPath(keyId, opts) {
        const key = this.getKey(keyId);
        return key.getBaseAddressDerivationPath(opts);
    }
    encryptPrivateKey(key, password) {
        key.encrypt(password);
    }
    decryptPrivateKey(key, password) {
        key.decrypt(password);
    }
    sign(keyId, rootPath, txp, password) {
        if (!keyId) {
            this.logger.warn("Can't sign. No key provided");
            return;
        }
        const key = this.getKey(keyId);
        return key.sign(rootPath, txp, password);
    }
};
KeyProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_7__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], KeyProvider);

//# sourceMappingURL=key.js.map

/***/ }),

/***/ 7:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Logger; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);

/* tslint:disable:no-console */


let Logger = class Logger {
    constructor() {
        this.logs = [];
        this.levels = [
            { level: 'error', weight: 1, label: 'Error', def: false },
            { level: 'warn', weight: 2, label: 'Warning', def: false },
            { level: 'info', weight: 3, label: 'Info', def: true },
            { level: 'debug', weight: 4, label: 'Debug', def: false }
        ];
        // Create an array of level weights for performant filtering.
        this.weight = {};
        for (let i = 0; i < this.levels.length; i++) {
            this.weight[this.levels[i].level] = this.levels[i].weight;
        }
    }
    getMessage(message) {
        const isUndefined = __WEBPACK_IMPORTED_MODULE_2_lodash__["isUndefined"](message);
        const isNull = __WEBPACK_IMPORTED_MODULE_2_lodash__["isNull"](message);
        const isError = __WEBPACK_IMPORTED_MODULE_2_lodash__["isError"](message);
        const isObject = __WEBPACK_IMPORTED_MODULE_2_lodash__["isObject"](message);
        if (isUndefined)
            return 'undefined';
        else if (isNull)
            return 'null';
        else if (isError)
            return message.message;
        else if (isObject)
            return JSON.stringify(message);
        else
            return message;
    }
    error(_message, ..._optionalParams) {
        const type = 'error';
        const args = this.processingArgs(arguments);
        this.log(`[${type}] ${args}`);
        this.add(type, args);
    }
    debug(_message, ..._optionalParams) {
        const type = 'debug';
        const args = this.processingArgs(arguments);
        if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["isDevMode"])())
            this.log(`[${type}] ${args}`);
        this.add(type, args);
    }
    info(_message, ..._optionalParams) {
        const type = 'info';
        const args = this.processingArgs(arguments);
        if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["isDevMode"])())
            this.log(`[${type}] ${args}`);
        this.add(type, args);
    }
    warn(_message, ..._optionalParams) {
        const type = 'warn';
        const args = this.processingArgs(arguments);
        if (Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["isDevMode"])())
            this.log(`[${type}] ${args}`);
        this.add(type, args);
    }
    getLevels() {
        return this.levels;
    }
    getWeight(weight) {
        return __WEBPACK_IMPORTED_MODULE_2_lodash__["find"](this.levels, l => {
            return l.weight == weight;
        });
    }
    getDefaultWeight() {
        return __WEBPACK_IMPORTED_MODULE_2_lodash__["find"](this.levels, l => {
            return l.def;
        });
    }
    add(level, msg) {
        msg = msg.replace('/xpriv.*/', '[...]');
        msg = msg.replace('/walletPrivKey.*/', 'walletPrivKey:[...]');
        const newLog = {
            timestamp: new Date().toISOString(),
            level,
            msg
        };
        this.logs.push(newLog);
    }
    /**
     * Returns logs of <= to filteredWeight
     * @param {number} filteredWeight Weight (1-4) to use when filtering logs. optional
     */
    get(filterWeight) {
        let filteredLogs = this.logs;
        if (filterWeight != undefined) {
            filteredLogs = __WEBPACK_IMPORTED_MODULE_2_lodash__["filter"](this.logs, l => {
                return this.weight[l.level] <= filterWeight;
            });
        }
        return filteredLogs;
    }
    processingArgs(argsValues) {
        let args = Array.prototype.slice.call(argsValues);
        args = args.map(v => {
            try {
                v = this.getMessage(v);
            }
            catch (e) {
                console.log('Error at log decorator:', e);
                v = 'Unknown message';
            }
            return v;
        });
        return args.join(' ');
    }
    log(msg, ...optionalParams) {
        console.log(msg, ...optionalParams);
    }
};
Logger = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [])
], Logger);

//# sourceMappingURL=logger.js.map

/***/ }),

/***/ 71:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxFormatProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__filter_filter__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__rate_rate__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash__);









let TxFormatProvider = class TxFormatProvider {
    constructor(bwcProvider, rate, configProvider, currencyProvider, filter, logger) {
        this.bwcProvider = bwcProvider;
        this.rate = rate;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.filter = filter;
        this.logger = logger;
        this.logger.debug('TxFormatProvider initialized');
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
    }
    toCashAddress(address, withPrefix) {
        return this.bitcoreCash.Address(address).toString(!withPrefix);
    }
    toLegacyAddress(address) {
        let legacyAddr = this.bitcoreCash
            .Address(address)
            .toLegacyAddress();
        return legacyAddr;
    }
    // TODO: Check return of formatAmount(...), sometimes returns a number and sometimes a string
    formatAmount(coin, satoshis, fullPrecision) {
        if (coin == 'sat')
            return satoshis;
        // TODO : now only works for english, specify opts to change thousand separator and decimal separator
        var opts = {
            fullPrecision: !!fullPrecision
        };
        return this.bwcProvider.getUtils().formatAmount(satoshis, coin, opts);
    }
    formatAmountStr(coin, satoshis) {
        if (isNaN(satoshis))
            return undefined;
        return this.formatAmount(coin, satoshis) + ' ' + coin.toUpperCase();
    }
    toFiat(coin, satoshis, code) {
        // TODO not a promise
        return new Promise(resolve => {
            if (isNaN(satoshis))
                return resolve();
            var v1;
            v1 = this.rate.toFiat(satoshis, code, coin);
            if (!v1)
                return resolve(null);
            return resolve(v1.toFixed(2));
        });
    }
    formatToUSD(coin, satoshis) {
        // TODO not a promise
        return new Promise(resolve => {
            let v1;
            if (isNaN(satoshis))
                return resolve();
            v1 = this.rate.toFiat(satoshis, 'USD', coin);
            if (!v1)
                return resolve(null);
            return resolve(v1.toFixed(2));
        });
    }
    formatAlternativeStr(coin, satoshis) {
        if (isNaN(satoshis))
            return undefined;
        let settings = this.configProvider.get().wallet.settings;
        let val = (() => {
            var v1 = parseFloat(this.rate.toFiat(satoshis, settings.alternativeIsoCode, coin).toFixed(2));
            v1 = this.filter.formatFiatAmount(v1);
            if (!v1)
                return null;
            return v1 + ' ' + settings.alternativeIsoCode;
        }).bind(this);
        if (!this.rate.isCoinAvailable(coin))
            return null;
        return val();
    }
    processTx(coin, tx) {
        if (!tx || tx.action == 'invalid')
            return tx;
        // New transaction output format. Fill tx.amount and tx.toAmount for
        // backward compatibility.
        if (tx.outputs && tx.outputs.length) {
            var outputsNr = tx.outputs.length;
            if (tx.action != 'received') {
                if (outputsNr > 1) {
                    tx.recipientCount = outputsNr;
                    tx.hasMultiplesOutputs = true;
                }
                tx.amount = __WEBPACK_IMPORTED_MODULE_8_lodash__["reduce"](tx.outputs, (total, o) => {
                    o.amountStr = this.formatAmountStr(coin, o.amount);
                    o.alternativeAmountStr = this.formatAlternativeStr(coin, o.amount);
                    return total + o.amount;
                }, 0);
            }
            tx.toAddress = tx.outputs[0].toAddress;
            // toDo: translate all tx.outputs[x].toAddress ?
            if (tx.toAddress && coin == 'bch') {
                tx.toAddress = this.toCashAddress(tx.toAddress);
            }
        }
        // Old tx format. Fill .output, for forward compatibility
        if (!tx.outputs) {
            tx.outputs = [
                {
                    address: tx.toAddress,
                    amount: tx.amount
                }
            ];
        }
        tx.amountStr = this.formatAmountStr(coin, tx.amount);
        tx.alternativeAmountStr = this.formatAlternativeStr(coin, tx.amount);
        const chain = this.currencyProvider.getChain(coin).toLowerCase();
        tx.feeStr = tx.fee
            ? this.formatAmountStr(chain, tx.fee)
            : tx.fees
                ? this.formatAmountStr(chain, tx.fees)
                : 'N/A';
        if (tx.amountStr) {
            tx.amountValueStr = tx.amountStr.split(' ')[0];
            tx.amountUnitStr = tx.amountStr.split(' ')[1];
        }
        if (tx.size && (tx.fee || tx.fees) && tx.amountUnitStr)
            tx.feeRate = `${((tx.fee || tx.fees) / tx.size).toFixed(0)} sat/bytes`;
        if (tx.addressTo && coin == 'bch') {
            tx.addressTo = this.toCashAddress(tx.addressTo);
        }
        return tx;
    }
    parseAmount(coin, amount, currency, onlyIntegers) {
        const { alternativeIsoCode } = this.configProvider.get().wallet.settings;
        const { unitToSatoshi, unitDecimals } = this.currencyProvider.getPrecision(coin);
        const satToUnit = 1 / unitToSatoshi;
        let amountUnitStr;
        let amountSat;
        // If fiat currency
        if (!__WEBPACK_IMPORTED_MODULE_5__currency_currency__["a" /* Coin */][currency] && currency != 'sat') {
            let formattedAmount = onlyIntegers
                ? this.filter.formatFiatAmount(amount.toFixed(0))
                : this.filter.formatFiatAmount(amount);
            amountUnitStr = formattedAmount + ' ' + currency;
            amountSat = Number(this.rate.fromFiat(amount, currency, coin).toFixed(0));
        }
        else if (currency == 'sat') {
            amountSat = Number(amount);
            amountUnitStr = this.formatAmountStr(coin, amountSat);
            // convert sat to Coin
            amount = (amountSat * satToUnit).toFixed(unitDecimals);
            currency = coin.toUpperCase();
        }
        else {
            amountSat = parseInt((amount * unitToSatoshi).toFixed(0), 10);
            amountUnitStr = this.formatAmountStr(coin, amountSat);
            // convert unit to Coin
            amount = (amountSat * satToUnit).toFixed(unitDecimals);
            currency = coin.toUpperCase();
        }
        return {
            amount,
            currency,
            alternativeIsoCode,
            amountSat,
            amountUnitStr
        };
    }
    satToUnit(amount, coin) {
        let { unitToSatoshi, unitDecimals } = this.currencyProvider.getPrecision(coin);
        let satToUnit = 1 / unitToSatoshi;
        return parseFloat((amount * satToUnit).toFixed(unitDecimals));
    }
};
TxFormatProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_7__rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_4__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_6__filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], TxFormatProvider);

//# sourceMappingURL=tx-format.js.map

/***/ }),

/***/ 854:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IncomingDataMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__action_sheet_action_sheet_parent__ = __webpack_require__(285);





let IncomingDataMenuComponent = class IncomingDataMenuComponent extends __WEBPACK_IMPORTED_MODULE_4__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(currencyProvider, platformProvider) {
        super();
        this.currencyProvider = currencyProvider;
        this.platformProvider = platformProvider;
        this.isCordova = this.platformProvider.isCordova;
    }
    ngOnInit() {
        this.https = false;
        this.data = this.params.data.data;
        this.type = this.params.data.type;
        this.coin = this.params.data.coin;
        this.coinName = this.coin && this.currencyProvider.getCoinName(this.coin);
        this.fromHomeCard = this.params.data.fromHomeCard;
        if (this.type === 'url') {
            this.https = this.data.indexOf('https://') === 0 ? true : false;
        }
    }
    close(redirTo, value) {
        if (redirTo == 'OpenExternalLink') {
            if (this.isCordova)
                this.dismiss();
            this.dismissFunction;
            this.dismissFunction({ redirTo, value, coin: this.coin });
        }
        else {
            this.dismiss({ redirTo, value, coin: this.coin });
        }
    }
};
IncomingDataMenuComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'incoming-data-menu',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/incoming-data-menu/incoming-data-menu.html"*/'<action-sheet>\n  <ion-list *ngIf="type === \'url\'">\n    <ion-item-divider>{{\'Website\' | translate}}</ion-item-divider>\n    <ion-item>\n      {{data}}\n      <ion-icon item-start>\n        <img *ngIf="!https" src="assets/img/icon-lock-x.svg">\n        <img *ngIf="https" src="assets/img/icon-lock-green.svg">\n      </ion-icon>\n    </ion-item>\n    <button ion-item (click)="close(\'OpenExternalLink\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-link-external.svg">\n      </ion-icon>\n      <span translate>Open website</span>\n    </button>\n    <button ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <ion-list *ngIf="type === \'bitcoinAddress\' || type === \'ethereumAddress\'">\n    <ion-item-divider *ngIf="coinName">{{\'{coinName} Address\' | translate: { coinName: coinName } }}</ion-item-divider>\n    <ion-item>\n      {{data}}\n      <ion-icon item-start>\n        <img src="assets/img/icon-{{coin}}-small.svg" alt="Coin">\n      </ion-icon>\n    </ion-item>\n    <button ion-item (click)="close(\'AddressBookPage\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-contacts.svg">\n      </ion-icon>\n      <span translate>Add as a contact</span>\n    </button>\n    <button ion-item (click)="close(\'AmountPage\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-send-alt.svg">\n      </ion-icon>\n      <span translate>Send payment to this address</span>\n    </button>\n    <button ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <ion-list *ngIf="type === \'text\'">\n    <ion-item-divider>{{\'Text\' | translate}}</ion-item-divider>\n    <ion-item>\n      {{data}}\n    </ion-item>\n    <button ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <ion-list *ngIf="type === \'privateKey\'">\n    <ion-item-divider>{{\'Private Key\' | translate}}</ion-item-divider>\n    <ion-item>{{data}}</ion-item>\n    <button ion-item (click)="close(\'PaperWalletPage\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-import.svg">\n      </ion-icon>\n      <span translate>Sweep paper wallet</span>\n    </button>\n    <button *ngIf="!fromHomeCard" ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <button ion-button clear color="danger" class="button-standard" (click)="close(null, null)">\n    {{\'Close\' | translate}}\n  </button>\n</action-sheet>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/incoming-data-menu/incoming-data-menu.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_platform_platform__["a" /* PlatformProvider */]])
], IncomingDataMenuComponent);

//# sourceMappingURL=incoming-data-menu.js.map

/***/ }),

/***/ 855:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActionSheetComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_dom_dom__ = __webpack_require__(427);





let ActionSheetComponent = class ActionSheetComponent {
    constructor(domProvider, platform, zone) {
        this.domProvider = domProvider;
        this.platform = platform;
        this.zone = zone;
        this.transitionDuration = 250;
        this.slideIn = false;
    }
    ngOnInit() {
        this.overrideHardwareBackButton();
    }
    present(componentRef) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.parentComponentRef = componentRef;
            yield __WEBPACK_IMPORTED_MODULE_3_rxjs__["Observable"].timer(50).toPromise();
            this.zone.run(() => (this.slideIn = true));
        });
    }
    dismiss(data) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.zone.run(() => (this.slideIn = false));
            this.dismissFunction && this.dismissFunction(data);
            yield __WEBPACK_IMPORTED_MODULE_3_rxjs__["Observable"].timer(this.transitionDuration).toPromise();
            this.domProvider.removeComponent(this.parentComponentRef);
        });
    }
    overrideHardwareBackButton() {
        this.deregisterBackButtonAction = this.platform.registerBackButtonAction(() => this.dismiss());
    }
    ngOnDestroy() {
        this.deregisterBackButtonAction();
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["HostBinding"])('class.open'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Boolean)
], ActionSheetComponent.prototype, "slideIn", void 0);
ActionSheetComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'action-sheet',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/action-sheet/action-sheet.html"*/'<div class="backdrop" [ngClass]="{\'backdrop-fade-in\': slideIn}" (click)="dismiss()"></div>\n<div class="action-sheet" [ngClass]="{\'opened\': slideIn, \'closed\': !slideIn }">\n  <ng-content></ng-content>\n</div>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/action-sheet/action-sheet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_dom_dom__["a" /* DomProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["q" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]])
], ActionSheetComponent);

//# sourceMappingURL=action-sheet.js.map

/***/ }),

/***/ 856:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return InfoSheetComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__ = __webpack_require__(285);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__info_sheet_template__ = __webpack_require__(857);





let InfoSheetComponent = class InfoSheetComponent extends __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(externalLinkProvider) {
        super();
        this.externalLinkProvider = externalLinkProvider;
    }
    ngAfterViewInit() {
        this.infoSheetTemplate.onDismiss.subscribe(option => {
            this.dismiss(option);
        });
    }
    openInBrowser(url) {
        this.externalLinkProvider.open(url);
        this.dismiss();
    }
    optionClicked(option) {
        this.dismiss(option);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_4__info_sheet_template__["a" /* InfoSheetTemplate */]),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_4__info_sheet_template__["a" /* InfoSheetTemplate */])
], InfoSheetComponent.prototype, "infoSheetTemplate", void 0);
InfoSheetComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'info-sheet',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/info-sheet/info-sheet.html"*/'<action-sheet>\n  <div class="info-container" [ngSwitch]="sheetType">\n    <info-sheet-template *ngSwitchCase="\'address-copied\'" type="success">\n      <span sheet-title-text>{{\'Copied {coin} address\' | translate: {coin: params.coin | uppercase } }}</span>\n      <span sheet-text class="text-address">{{params.address}}</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'custom-amount\'" type="success">\n      <span sheet-title-text translate>Copied</span>\n      <span sheet-text>{{params.qrAddress}}</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'copayers\'" type="success">\n      <span sheet-title-text translate>Copied</span>\n      <span sheet-text>\n        {{params.secret}}\n      </span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'receiving-bitcoin\'" type="info">\n      <span sheet-title-text>{{\'Receiving {coinName} address\' | translate: {coinName: params.coinName } }}</span>\n      <span sheet-text>\n        {{\'Your wallet address is similar to a bank account number. You can add funds to your wallet by withdrawing funds you may have stored on an exchange to your wallet address. Or other {coinName} users can send you money by scanning your QR code.\' | translate: {coinName: params.coinName} }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'backup-needed-with-activity\'" type="info">\n      <span sheet-title-text translate>Needs Backup</span>\n      <span sheet-text translate>\n        Congratulations! It looks like you\'ve recently received money. It\'s highly advised that you verify your recovery phrase so that your funds can be recovered in case your phone was lost or stolen.\n      </span>\n      <span sheet-button-text translate>Continue</span>\n      <span sheet-second-button-text translate>Not right now</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'miner-fee-notice\'" type="warning">\n      <span sheet-title-text translate>Miner Fee Notice</span>\n      <span sheet-text>\n        {{\'Because you are sending the maximum amount contained in this wallet, the {coinName} miner fee ({fee} {coin}) will be deducted from the total. {msg}\' | translate: {coinName: params.coinName, fee: params.fee, coin:params.coin, msg: params.msg} }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'miner-fee\'" type="danger">\n      <span sheet-title-text>{{ \'Network Fee Warning\' | translate }}</span>\n      <span sheet-text>\n        {{ \'This transaction requires a high network fee because either the sending amount is too small or the network is experiencing congestion.\' | translate }}\n        <p>\n          {{ \'BitPay does not receive and does not control miner fees.\' | translate }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'insufficient-funds\'" type="danger">\n      <span sheet-title-text translate>Not enough funds</span>\n      <span sheet-text>\n        {{ \'You are trying to send more funds than you have available. Make sure you do not have funds locked by pending transaction proposals. You can also try with a lower amount or send max.\' | translate }}\n      </span>\n      <span sheet-button-text translate>Change Amount</span>\n      <span sheet-second-button-text translate>Send Max</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'import-no-wallet-warning\'" type="warning">\n      <span sheet-title-text translate>We couldn\'t find your wallet!</span>\n      <span sheet-text>\n        {{ \'There are no records of your wallet on our servers. If you are importing a BIP44 compatible wallet from a 3rd party you can continue to recreate it. If you wallet is not BIP44 compatible, you will not be able to access its funds.\' | translate }}\n      </span>\n      <span sheet-button-text translate>Go Back</span>\n      <span sheet-second-button-text translate>Continue Anyway</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'default-error\'" type="danger">\n      <span sheet-title-text>{{params.title}}</span>\n      <span sheet-text>{{params.msg}}</span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'backup-later-warning\'" type="warning">\n      <span sheet-title-text translate>Do this later?</span>\n      <span sheet-text translate>\n        Receiving funds will be temporary disabled until you can verify your recovery phrase has been stored away securely. You can always complete this later from your wallet settings.\n      </span>\n      <span sheet-button-text translate>Ok</span>\n      <span sheet-second-button-text translate>Continue Backup</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'backup-ready\'" type="success">\n      <span sheet-title-text>{{\'Your {walletType} wallet is backed up!\' | translate : {walletType: params.walletType}\n        }}</span>\n      <span sheet-text translate>\n        Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'backup-safeguard-warning\'" type="info">\n      <span sheet-title-text translate>Safeguard your recovery phrase</span>\n      <span sheet-text translate>\n        Your recovery phrase is composed of 12 randomly selected words. Please carefully write down each word in the order they appear.\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'sensitive-info\'" type="warning">\n      <span sheet-title-text translate>Sensitive Data</span>\n      <span sheet-text translate>\n        The information you are about to share/export may contain sensitive data such us wallet IDs, addresses, balances, etc. Please be sure you trust the person or entity with whom you are sharing this information.\n      </span>\n      <span sheet-button-text translate>I understand</span>\n      <span sheet-second-button-text translate>Go Back</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'copy-to-clipboard\'" type="success">\n      <span sheet-title-text translate>Copied to Clipboard</span>\n      <span sheet-text>{{params?.msg}}</span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'copied-gift-card-claim-code\'" type="success">\n      <span sheet-title-text style="word-break: break-all;">{{\'Copied: {claimCode}\' | translate: params }}</span>\n      <span sheet-text>\n        <redeem-instructions [cardConfig]="params.cardConfig" [params]="params"></redeem-instructions>\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'addTokenWallet\'" type="{{ params.wallets[0] ? \'info\' : \'warning\' }}">\n      <span *ngIf="params.wallets && params.wallets.length>1" sheet-title-text translate>Select a Ethereum Wallet for Transaction Costs</span>\n      <span *ngIf="params.wallets && params.wallets.length == 1" sheet-title-text translate>Transaction Costs</span>\n      <span *ngIf="!params.wallets[0]" sheet-title-text translate>Ethereum wallet required</span>\n      <span *ngIf="params.wallets && params.wallets.length == 1" sheet-text translate>This token will use your wallet {{ params.wallets[0].walletName}} (ETH) for the transaction costs</span>\n      <span *ngIf="params.wallets && params.wallets.length > 1" sheet-text translate>Which Ethereum wallet would you like this token to use for transaction costs?</span>\n\n      <span *ngIf="!params.wallets[0]" sheet-text translate>\n        In order to create a token wallet, an Ethereum (ETH) wallet is required. Please create an ETH wallet first.\n        Only one {{ params.token.name }} wallet is allowed per ETH wallet.\n      </span>\n\n      <span sheet-text>\n        <div style="margin-top: 20px" *ngIf="params.wallets && params.wallets.length > 1">\n          <ion-list>\n            <div>\n              <button ion-item class="list-button" *ngFor="let wallet of params.wallets; let last = last" [class.border-none]="last" (click)="optionClicked(wallet)">\n                <wallet-item-content [wallet]="wallet"></wallet-item-content>\n              </button>\n            </div>\n          </ion-list>\n        </div>\n      </span>\n\n      <span sheet-button-text translate *ngIf="params.wallets.length==1"  (click)="optionClicked(params.wallets[0])" style="float: right;" item-end>OK</span>\n\n      <span sheet-button-text translate [ngClass]="{\'sheet-btn default\': !params.wallets[0] }">GO BACK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'copied-invoice-url\'" type="{{ params.error ? \'danger\' : \'success\' }}">\n      <span *ngIf="!params.error" sheet-title-text class="truncate">\n        <span translate>Copied</span>: {{params.invoiceUrl}}\n      </span>\n      <span *ngIf="params.error" sheet-title-text class="truncate">\n        <span translate>Error</span>: {{params.error}}\n      </span>\n      <span sheet-text>\n        <redeem-instructions [cardConfig]="params.cardConfig" [params]="params"></redeem-instructions>\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n      <span sheet-button-text class="sheet-btn-invoice" translate (click)="openInBrowser(params.invoiceUrl)" style="float: right;" item-end>OPEN IN BROWSER\n      </span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'archive-all-gift-cards\'" type="warning">\n      <span sheet-title-text>{{\'Archive All {brand} Gift Cards?\' | translate: params }}</span>\n      <span sheet-text>{{\'Have you redeemed all of your {brand} Gift Cards? Archived gift cards will still be accessible in settings.\' | translate: params }}</span>\n      <span sheet-button-text translate>YES</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'archive-gift-card\'" type="warning">\n      <span sheet-title-text translate>Archive this Card?</span>\n      <span sheet-text translate>Have you redeemed the entire balance of this gift card?</span>\n      <span sheet-button-text translate>YES</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'hide-gift-card-discount-item\'" type="warning">\n      <span sheet-title-text translate>Hide discount?</span>\n      <span sheet-text translate>Would you like to hide this gift card discount?</span>\n      <span sheet-button-text translate>YES</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'gift-card-archived\'" type="success">\n      <span sheet-title-text translate>Card Archived</span>\n      <span sheet-text translate>You can continue to view your archived cards here if you need to access them.</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'activation-fee-included\'" type="info">\n      <span sheet-title-text translate>Activation Fee</span>\n      <span sheet-text>{{\'{displayName} gift cards contain an additional activation fee of {fee} {currency}.\' |\n        translate: params }}</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'gift-cards-unavailable\'" type="danger">\n      <span sheet-title-text translate>Temporarily Unavailable</span>\n      <span sheet-text translate>Gift card purchases are temporarily unavailable. Please try again later.</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'below-minimum-gift-card-amount\'" type="danger">\n      <span sheet-title-text translate>Below Minimum Amount</span>\n      <span sheet-text>{{\'The purchase amount must be at least {minAmount} {currency}. Please modify your amount.\' |\n        translate: params }}</span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'above-maximum-gift-card-amount\'" type="danger">\n      <span sheet-title-text translate>Purchase Limit Reached</span>\n      <span sheet-text>\n        {{\'The purchase amount is limited to {maxAmount} {currency} per day. Please modify your amount.\' | translate:params }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'legacy-address-info\'" type="info">\n      <span sheet-title-text>{{\'{appName} BCH wallets use the CashAddr format by default\' | translate: {appName:params.appName} }}</span>\n      <span sheet-text translate>\n        If you need to send to "old" addresses (like the one you just pasted), and you are SURE those are BCH addresses, you can "translate" them using the BCH Translator tool and paste the corresponding address in CashAddr format for that "old" address.\n      </span>\n      <span sheet-button-text translate>Translate address</span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'appreciate-review\'" type="love">\n      <span sheet-title-text translate>We appreciate your review</span>\n      <span sheet-text translate>\n        5-star ratings help us get BitPay Wallet into more hands, and more users means more resources can be committed to the app!\n      </span>\n      <span sheet-button-text>{{\'Rate on the {storeName}\' | translate: {storeName: params?.storeName} }}</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'backup-failed\'" type="danger">\n      <span sheet-title-text translate>Incorrect backup phrase</span>\n      <span sheet-text translate>\n        It\'s important that you write your recovery phrase down correctly. If something happens to your wallet, you\'ll need it to recover your money. Please review and try again.\n      </span>\n      <span sheet-button-text translate>START OVER</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'payment-request\'" type="info">\n      <span sheet-title-text translate>Payment Request info</span>\n      <span sheet-text>\n        {{\'Share this QR code to receive {amount} in your wallet {name}.\' | translate: {amount: params.amount, name:params.name} }}\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'print-required\'" type="info">\n      <span sheet-title-text translate>Printed Gift Card Required</span>\n      <span sheet-text>\n        {{\'{displayName} requires you to present a printed gift card at redemption.\' | translate: params }}\n        <br>\n        <br>\n        You will be able to print this gift card upon completing your purchase.\n      </span>\n      <span sheet-button-text translate>GOT IT</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'in-app-notification\'" type="success">\n      <span sheet-title-text>{{params.title}}</span>\n      <span sheet-text>{{params.body}}</span>\n      <span sheet-button-text translate>OK</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'request-feature\'" type="info">\n      <span sheet-title-text translate>Request a new feature</span>\n      <span sheet-text translate>\n        If you need immediate help with a problem you are having, then get help by contacting our support team.\n      </span>\n      <span sheet-button-text translate>Get help</span>\n      <span sheet-second-button-text translate>Request feature</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'report-issue\'" type="info">\n      <span sheet-title-text translate>Report an issue</span>\n      <span sheet-text translate>\n        Found something broken? Please report it as a bug. If you need immediate help with a problem you are having, then get help by contacting our support team.\n      </span>\n      <span sheet-button-text translate>Get help</span>\n      <span sheet-second-button-text translate>Report issue</span>\n    </info-sheet-template>\n\n    <info-sheet-template *ngSwitchCase="\'new-key\'" type="warning">\n      <span sheet-title-text translate>Store this key separately</span>\n      <span sheet-text translate>\n        This is a new 12-word key that manages its own set of wallets. It is unrelated to any 12 word key you may have previously created. Store and manage it accordingly.\n      </span>\n      <span sheet-button-text translate>Learn More</span>\n      <span sheet-second-button-text translate>GOT IT</span>\n    </info-sheet-template>\n  </div>\n</action-sheet>\n'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/info-sheet/info-sheet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], InfoSheetComponent);

const INFO_SHEET_COMPONENTS = [InfoSheetComponent, __WEBPACK_IMPORTED_MODULE_4__info_sheet_template__["a" /* InfoSheetTemplate */]];
/* harmony export (immutable) */ __webpack_exports__["a"] = INFO_SHEET_COMPONENTS;

//# sourceMappingURL=info-sheet.js.map

/***/ }),

/***/ 857:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AlertType */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InfoSheetTemplate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__);



var AlertType;
(function (AlertType) {
    AlertType["info"] = "info";
    AlertType["success"] = "success";
    AlertType["warning"] = "warning";
    AlertType["danger"] = "danger";
    AlertType["love"] = "love";
})(AlertType || (AlertType = {}));
let InfoSheetTemplate = class InfoSheetTemplate {
    constructor() {
        this.type = AlertType.info;
        this.dismissSubject = new __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__["Subject"]();
        this.onDismiss = this.dismissSubject.asObservable();
    }
    dismiss(option) {
        this.dismissSubject.next(option);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", String)
], InfoSheetTemplate.prototype, "type", void 0);
InfoSheetTemplate = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'info-sheet-template',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/info-sheet/info-sheet-template.html"*/'<div class="confirm-sheet">\n  <div class="sheet-title">\n    <div class="title-icon">\n      <img *ngIf="type === \'success\'" src="assets/img/green-check-circled.svg">\n      <img *ngIf="type === \'info\'" src="assets/img/icon-info-blue.svg">\n      <img *ngIf="type === \'warning\'" src="assets/img/icon-warning-circled.svg">\n      <img *ngIf="type === \'danger\'" src="assets/img/icon-danger.svg">\n      <img *ngIf="type === \'love\'" src="assets/img/icon-heart.svg">\n    </div>\n    <ng-content select="[sheet-title-text]"></ng-content>\n  </div>\n  <div class="sheet-text">\n    <ng-content select="[sheet-text]"></ng-content>\n  </div>\n  <div class="sheet-btn-group">\n    <div class="sheet-btn"\n      [ngClass]="{blue: type === \'info\' || type === \'love\', yellow: type === \'warning\', red: type === \'danger\'}"\n      (click)="dismiss(true)">\n      <ng-content select="[sheet-button-text]"></ng-content>\n    </div>\n    <div class="sheet-second-btn" [ngClass]="{primary: type == \'danger\'}" (click)="dismiss(false)">\n      <ng-content select="[sheet-second-button-text]"></ng-content>\n    </div>\n  </div>\n</div>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/info-sheet/info-sheet-template.html"*/
    })
], InfoSheetTemplate);

//# sourceMappingURL=info-sheet-template.js.map

/***/ }),

/***/ 858:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OptionsSheetComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__action_sheet_action_sheet_parent__ = __webpack_require__(285);



let OptionsSheetComponent = class OptionsSheetComponent extends __WEBPACK_IMPORTED_MODULE_2__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor() {
        super();
    }
    optionClicked(option) {
        this.dismiss(option);
    }
};
OptionsSheetComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'options-sheet',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/options-sheet/options-sheet.html"*/'<action-sheet>\n  <div class="options-container" [ngSwitch]="sheetType">\n    <div *ngSwitchCase="\'address-options\'">\n      <div class="option" (click)="optionClicked(\'request-amount\')">\n        <div class="option-icon">\n          <img src="assets/img/specific-amount.svg">\n        </div>\n        <div translate class="option-text">Request Specific Amount</div>\n      </div>\n      <div *ngIf="params.showShare" class="option" (click)="optionClicked(\'share-address\')">\n        <div class="option-icon">\n          <img src="assets/img/icon-share.svg">\n        </div>\n        <div translate class="option-text">Share Address</div>\n      </div>\n    </div>\n    <div *ngSwitchCase="\'gift-card-options\'">\n      <div class="option" (click)="optionClicked(\'archive\')" *ngIf="!params.card.archived">\n        <div class="option-icon">\n          <img src="assets/img/notebook.svg">\n        </div>\n        <div translate class="option-text">Archive Card</div>\n      </div>\n      <div class="option" (click)="optionClicked(\'unarchive\')" *ngIf="params.card.archived">\n        <div class="option-icon">\n          <img src="assets/img/notebook.svg">\n        </div>\n        <div translate class="option-text">Unarchive Card</div>\n      </div>\n      <div class="option" (click)="optionClicked(\'view-invoice\')">\n        <div class="option-icon">\n          <img src="assets/img/invoice-icon.svg">\n        </div>\n        <div translate class="option-text">View Invoice</div>\n      </div>\n      <div *ngIf="params.showShare" class="option" (click)="optionClicked(\'share-code\')">\n        <div class="option-icon">\n          <img src="assets/img/icon-share.svg">\n        </div>\n        <div translate class="option-text">Share Claim Code</div>\n      </div>\n      <div *ngIf="!params.hidePrint" class="option" (click)="optionClicked(\'print-card\')">\n        <div class="option-icon">\n          <img src="assets/img/printer-p.svg" height="19" width="18">\n        </div>\n        <div translate class="option-text">Print Card</div>\n      </div>\n    </div>\n    <div (click)="dismiss()" class="cancel-btn" translate>Cancel</div>\n  </div>\n</action-sheet>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/options-sheet/options-sheet.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [])
], OptionsSheetComponent);

//# sourceMappingURL=options-sheet.js.map

/***/ }),

/***/ 859:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletSelectorComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__ = __webpack_require__(285);




let WalletSelectorComponent = class WalletSelectorComponent extends __WEBPACK_IMPORTED_MODULE_3__action_sheet_action_sheet_parent__["a" /* ActionSheetParent */] {
    constructor(currencyProvider) {
        super();
        this.currencyProvider = currencyProvider;
        this.wallets = {};
        this.availableCoins = this.currencyProvider.getAvailableCoins();
    }
    ngOnInit() {
        this.title = this.params.title;
        this.selectedWalletId = this.params.selectedWalletId;
        this.separateWallets();
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    separateWallets() {
        const wallets = this.params.wallets;
        for (const coin of this.availableCoins) {
            this.wallets[coin] = wallets.filter(wallet => wallet.coin === coin);
        }
    }
    optionClicked(option) {
        this.dismiss(option);
    }
};
WalletSelectorComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'wallet-selector',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/components/wallet-selector/wallet-selector.html"*/'<action-sheet>\n  <ion-row align-items-center>\n    <ion-col col-4 text-left>\n      <button ion-button clear icon-only color="grey" (click)="dismiss()">\n        <ion-icon name="arrow-round-back"></ion-icon>\n      </button>\n    </ion-col>\n    <ion-col col-4 text-center class="destination-title">{{ title }}</ion-col>\n  </ion-row>\n  <div *ngFor="let coin of availableCoins">\n    <div class="no-wallets" *ngIf="(!wallets[coin] && !wallets[coin][0])" translate>\n      No wallets available\n    </div>\n\n    <div *ngIf="wallets && wallets[coin][0]">\n      <ion-item-divider>\n        <div class="title">\n          <span translate>{{ getCoinName(coin) }} Wallets</span>\n        </div>\n      </ion-item-divider>\n\n      <ion-list>\n        <div>\n          <button ion-item detail-none *ngFor="let wallet of wallets[coin]" (click)="optionClicked(wallet)">\n            <wallet-item-content [wallet]="wallet"></wallet-item-content>\n          </button>\n        </div>\n      </ion-list>\n    </div>\n  </div>\n  <ion-item-divider></ion-item-divider>\n</action-sheet>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/components/wallet-selector/wallet-selector.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_currency_currency__["b" /* CurrencyProvider */]])
], WalletSelectorComponent);

//# sourceMappingURL=wallet-selector.js.map

/***/ }),

/***/ 86:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GiftCardProvider; });
/* harmony export (immutable) */ __webpack_exports__["b"] = getActivationFee;
/* unused harmony export filterDisplayableConfig */
/* unused harmony export sortByDescendingDate */
/* harmony export (immutable) */ __webpack_exports__["f"] = sortByDisplayName;
/* harmony export (immutable) */ __webpack_exports__["c"] = getDisplayNameSortValue;
/* unused harmony export setNullableCardFields */
/* unused harmony export getCardsFromInvoiceMap */
/* harmony export (immutable) */ __webpack_exports__["e"] = hasVisibleDiscount;
/* harmony export (immutable) */ __webpack_exports__["d"] = getVisibleDiscount;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_image_loader__ = __webpack_require__(343);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_observable_from__ = __webpack_require__(394);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_observable_from___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_from__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromPromise__ = __webpack_require__(353);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromPromise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromPromise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_observable_of__ = __webpack_require__(200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_observable_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs_observable_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_operators__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_operators___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs_operators__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils__ = __webpack_require__(1958);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__analytics_analytics__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__email_notifications_email_notifications__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__home_integrations_home_integrations__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__invoice_invoice__ = __webpack_require__(976);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__time_time__ = __webpack_require__(148);





















let GiftCardProvider = class GiftCardProvider extends __WEBPACK_IMPORTED_MODULE_16__invoice_invoice__["a" /* InvoiceProvider */] {
    constructor(analyticsProvider, appProvider, configProvider, imageLoader, homeIntegrationsProvider, timeProvider, emailNotificationsProvider, http, logger, persistenceProvider, platformProvider) {
        super(emailNotificationsProvider, http, logger, persistenceProvider);
        this.analyticsProvider = analyticsProvider;
        this.appProvider = appProvider;
        this.configProvider = configProvider;
        this.imageLoader = imageLoader;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.timeProvider = timeProvider;
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.http = http;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.platformProvider = platformProvider;
        this.cardUpdatesSubject = new __WEBPACK_IMPORTED_MODULE_5_rxjs__["Subject"]();
        this.cardUpdates$ = this.cardUpdatesSubject.asObservable();
        this.fallbackIcon = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAyCAQAAAA38nkBAAAADklEQVR42mP8/4Vx8CEAn9BhqacD+5kAAAAASUVORK5CYII=';
        this.logger.debug('GiftCardProvider initialized');
        this.setCredentials();
    }
    getCardConfig(cardName) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const cardConfigMap = yield this.getCardConfigMap();
            return cardConfigMap[cardName];
        });
    }
    getCardConfigMap() {
        return this.availableCardMapPromise
            ? this.availableCardMapPromise
            : this.fetchCardConfigMap();
    }
    fetchCardConfigMap() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.availableCardMapPromise = this.getSupportedCards().then(availableCards => availableCards.reduce((map, cardConfig) => (Object.assign({}, map, { [cardConfig.name]: cardConfig })), {}));
            return this.availableCardMapPromise;
        });
    }
    getCardMap(cardName) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const network = this.getNetwork();
            const map = yield this.persistenceProvider.getGiftCards(cardName, network);
            return map || {};
        });
    }
    createBitpayInvoice(data) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const dataSrc = {
                brand: data.cardName,
                currency: data.currency,
                amount: data.amount,
                clientId: data.uuid,
                discounts: data.discounts,
                email: data.email
            };
            const url = `${this.getApiPath()}/pay`;
            const headers = new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["c" /* HttpHeaders */]({
                'Content-Type': 'application/json'
            });
            const cardOrder = yield this.http
                .post(url, dataSrc, { headers })
                .toPromise()
                .catch(err => {
                this.logger.error('BitPay Create Invoice: ERROR', JSON.stringify(data));
                throw err;
            });
            this.logger.info('BitPay Create Invoice: SUCCESS');
            return cardOrder;
        });
    }
    getActiveCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const [configMap, giftCardMap] = yield Promise.all([
                this.getCardConfigMap(),
                this.persistenceProvider.getActiveGiftCards(this.getNetwork())
            ]);
            const validSchema = giftCardMap && Object.keys(giftCardMap).every(key => key !== 'undefined');
            return !giftCardMap || !validSchema
                ? this.migrateAndFetchActiveCards()
                : getCardsFromInvoiceMap(giftCardMap, configMap);
        });
    }
    getPurchasedCards(cardName) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const [configMap, giftCardMap] = yield Promise.all([
                this.getCardConfigMap(),
                this.getCardMap(cardName)
            ]);
            return getCardsFromInvoiceMap(giftCardMap, configMap);
        });
    }
    hideDiscountItem() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            return this.persistenceProvider.setHideGiftCardDiscountItem(true);
        });
    }
    getAllCardsOfBrand(cardBrand) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const supportedCards = yield this.getSupportedCards();
            const cardConfigs = supportedCards.filter(cardConfig => cardConfig.displayName === cardBrand);
            const cardPromises = cardConfigs.map(cardConfig => this.getPurchasedCards(cardConfig.name));
            const cardsGroup = yield Promise.all(cardPromises);
            return cardsGroup
                .reduce((allCards, brandCards) => allCards.concat(brandCards), [])
                .sort(sortByDescendingDate);
        });
    }
    getPurchasedBrands() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const supportedCards = yield this.getSupportedCards();
            const supportedCardNames = supportedCards.map(c => c.name);
            const purchasedCardPromises = supportedCardNames.map(cardName => this.getPurchasedCards(cardName));
            const purchasedCards = yield Promise.all(purchasedCardPromises);
            return purchasedCards
                .filter(brand => brand.length)
                .sort((a, b) => sortByDisplayName(a[0], b[0]));
        });
    }
    saveCard(giftCard, opts) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const oldGiftCards = yield this.getCardMap(giftCard.name);
            const newMap = this.getNewSaveableGiftCardMap(oldGiftCards, giftCard, opts);
            const savePromise = this.persistCards(giftCard.name, newMap);
            yield Promise.all([savePromise, this.updateActiveCards([giftCard], opts)]);
        });
    }
    updateActiveCards(giftCardsToUpdate, opts = {}) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            let oldActiveGiftCards = (yield this.persistenceProvider.getActiveGiftCards(this.getNetwork())) ||
                {};
            if (typeof oldActiveGiftCards !== 'object') {
                oldActiveGiftCards = {};
            }
            const newMap = giftCardsToUpdate.reduce((updatedMap, c) => this.getNewSaveableGiftCardMap(updatedMap, c, {
                remove: c.archived || opts.remove
            }), oldActiveGiftCards);
            return this.persistenceProvider.setActiveGiftCards(this.getNetwork(), JSON.stringify(newMap));
        });
    }
    clearActiveGiftCards() {
        return this.persistenceProvider.setActiveGiftCards(this.getNetwork(), JSON.stringify({}));
    }
    persistCards(cardName, newMap) {
        return this.persistenceProvider.setGiftCards(cardName, this.getNetwork(), JSON.stringify(newMap));
    }
    saveGiftCard(giftCard, opts) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const originalCard = (yield this.getPurchasedCards(giftCard.name)).find(c => c.invoiceId === giftCard.invoiceId);
            const cardChanged = !originalCard ||
                originalCard.status !== giftCard.status ||
                originalCard.archived !== giftCard.archived ||
                originalCard.barcodeImage !== giftCard.barcodeImage;
            const shouldNotify = cardChanged && giftCard.status !== 'UNREDEEMED';
            yield this.saveCard(giftCard, opts);
            shouldNotify && this.cardUpdatesSubject.next(giftCard);
        });
    }
    getNewSaveableGiftCardMap(oldGiftCards, gc, opts) {
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isString"](oldGiftCards)) {
            oldGiftCards = JSON.parse(oldGiftCards);
        }
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isString"](gc)) {
            gc = JSON.parse(gc);
        }
        let newMap = oldGiftCards || {};
        newMap[gc.invoiceId] = gc;
        if (opts && (opts.error || opts.status)) {
            newMap[gc.invoiceId] = __WEBPACK_IMPORTED_MODULE_4_lodash__["assign"](newMap[gc.invoiceId], opts);
        }
        if (opts && opts.remove) {
            delete newMap[gc.invoiceId];
        }
        return newMap;
    }
    archiveCard(card) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            card.archived = true;
            yield this.saveGiftCard(card);
        });
    }
    unarchiveCard(card) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            card.archived = false;
            yield this.saveGiftCard(card);
        });
    }
    archiveAllCards(cardName) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const activeCards = (yield this.getPurchasedCards(cardName)).filter(c => !c.archived);
            const oldGiftCards = yield this.getCardMap(cardName);
            const invoiceIds = Object.keys(oldGiftCards);
            const newMap = invoiceIds.reduce((newMap, invoiceId) => {
                const card = oldGiftCards[invoiceId];
                card.archived = true;
                return this.getNewSaveableGiftCardMap(newMap, card);
            }, oldGiftCards);
            yield Promise.all([
                this.persistCards(cardName, newMap),
                this.updateActiveCards(activeCards.map(c => (Object.assign({}, c, { archived: true }))))
            ]);
            activeCards
                .map(c => (Object.assign({}, c, { archived: true })))
                .forEach(c => this.cardUpdatesSubject.next(c));
        });
    }
    createGiftCard(data) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const dataSrc = {
                brand: data.name,
                clientId: data.uuid,
                invoiceId: data.invoiceId,
                accessKey: data.accessKey
            };
            const name = data.name;
            const cardConfig = yield this.getCardConfig(name);
            const url = `${this.getApiPath()}/redeem`;
            return this.http
                .post(url, dataSrc)
                .catch(err => {
                this.logger.error(`${cardConfig.name} Gift Card Create/Update: ${err.message}`);
                const errMessage = err.error && err.error.message;
                const pendingMessages = [
                    'Card creation delayed',
                    'Invoice is unpaid or payment has not confirmed'
                ];
                return pendingMessages.indexOf(errMessage) > -1 ||
                    errMessage.indexOf('Please wait') > -1
                    ? Object(__WEBPACK_IMPORTED_MODULE_8_rxjs_observable_of__["of"])(Object.assign({}, data, { status: 'PENDING' }))
                    : __WEBPACK_IMPORTED_MODULE_5_rxjs__["Observable"].throw(err);
            })
                .map((res) => {
                const status = res.claimCode || res.claimLink ? 'SUCCESS' : 'PENDING';
                const fullCard = Object.assign({}, data, res, { name,
                    status });
                this.logger.info(`${cardConfig.name} Gift Card Create/Update: ${fullCard.status}`);
                return fullCard;
            })
                .toPromise();
        });
    }
    updatePendingGiftCards(cards, force = false) {
        const cardsNeedingUpdate = cards.filter(card => this.checkIfCardNeedsUpdate(card) || force);
        return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_from__["from"])(cardsNeedingUpdate).pipe(Object(__WEBPACK_IMPORTED_MODULE_9_rxjs_operators__["mergeMap"])(card => Object(__WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromPromise__["fromPromise"])(this.createGiftCard(card)).catch(err => {
            this.logger.error('Error creating gift card:', err);
            this.logger.error('Gift card: ', JSON.stringify(card, null, 4));
            return Object(__WEBPACK_IMPORTED_MODULE_8_rxjs_observable_of__["of"])(Object.assign({}, card, { status: 'FAILURE' }));
        })), Object(__WEBPACK_IMPORTED_MODULE_9_rxjs_operators__["mergeMap"])(card => card.status === 'UNREDEEMED' || card.status === 'PENDING'
            ? Object(__WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromPromise__["fromPromise"])(this.getBitPayInvoice(card.invoiceId).then(invoice => (Object.assign({}, card, { status: (card.status === 'PENDING' ||
                    (card.status === 'UNREDEEMED' &&
                        invoice.status !== 'new')) &&
                    invoice.status !== 'expired' &&
                    invoice.status !== 'invalid'
                    ? 'PENDING'
                    : 'expired' }))))
            : Object(__WEBPACK_IMPORTED_MODULE_8_rxjs_observable_of__["of"])(card)), Object(__WEBPACK_IMPORTED_MODULE_9_rxjs_operators__["mergeMap"])(updatedCard => this.updatePreviouslyPendingCard(updatedCard)), Object(__WEBPACK_IMPORTED_MODULE_9_rxjs_operators__["mergeMap"])(updatedCard => {
            this.logger.debug('Gift card updated');
            return Object(__WEBPACK_IMPORTED_MODULE_8_rxjs_observable_of__["of"])(updatedCard);
        }));
    }
    updatePreviouslyPendingCard(updatedCard) {
        return Object(__WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromPromise__["fromPromise"])(this.saveGiftCard(updatedCard, {
            remove: updatedCard.status === 'expired'
        }).then(() => updatedCard));
    }
    checkIfCardNeedsUpdate(card) {
        if (!card.invoiceId) {
            return false;
        }
        // Continues normal flow (update card)
        if (card.status === 'PENDING' ||
            card.status === 'UNREDEEMED' ||
            card.status === 'invalid' ||
            (!card.claimCode && !card.claimLink)) {
            return true;
        }
        // Check if card status FAILURE for 24 hours
        if (card.status === 'FAILURE' &&
            this.timeProvider.withinPastDay(card.date)) {
            return true;
        }
        // Success: do not update
        return false;
    }
    getSupportedCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const [availableCards, cachedApiCardConfig] = yield Promise.all([
                this.getAvailableCards().catch(_ => []),
                this.getCachedApiCardConfig().catch(_ => ({}))
            ]);
            const cachedCardNames = Object.keys(cachedApiCardConfig);
            const availableCardNames = availableCards.map(c => c.name);
            const uniqueCardNames = Array.from(new Set([...availableCardNames, ...cachedCardNames]));
            const supportedCards = uniqueCardNames
                .map(cardName => {
                const freshConfig = availableCards.find(c => c.name === cardName);
                const cachedConfig = appendFallbackImages(cachedApiCardConfig[cardName]);
                const config = freshConfig || cachedConfig;
                const displayName = config.displayName || config.brand || config.name;
                return Object.assign({}, config, { displayName });
            })
                .filter(filterDisplayableConfig)
                .sort(sortByDisplayName);
            return supportedCards;
        });
    }
    getSupportedCardMap() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const supportedCards = yield this.getSupportedCards();
            return supportedCards.reduce((map, cardConfig) => (Object.assign({}, map, { [cardConfig.name]: cardConfig })), {});
        });
    }
    migrateAndFetchActiveCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.clearActiveGiftCards();
            const purchasedBrands = yield this.getPurchasedBrands();
            const activeCardsGroupedByBrand = purchasedBrands.filter(cards => cards.filter(c => !c.archived).length);
            const activeCards = activeCardsGroupedByBrand
                .reduce((allCards, brandCards) => [...allCards, ...brandCards], [])
                .filter(c => !c.archived);
            yield this.updateActiveCards(activeCards);
            return activeCards;
        });
    }
    fetchAvailableCardMap() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const url = `${this.credentials.BITPAY_API_URL}/gift-cards/cards`;
            const availableCardMap = (yield this.http
                .get(url, {
                headers: {
                    'x-bitpay-version': this.appProvider.info.version
                }
            })
                .toPromise());
            this.cacheApiCardConfig(availableCardMap);
            return availableCardMap;
        });
    }
    cacheApiCardConfig(availableCardMap) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const cardNames = Object.keys(availableCardMap);
            const previousCache = yield this.persistenceProvider.getGiftCardConfigCache(this.getNetwork());
            const apiCardConfigCache = getCardConfigFromApiConfigMap(availableCardMap, this.platformProvider.isCordova).reduce((configMap, apiCardConfigMap, index) => {
                const name = cardNames[index];
                return Object.assign({}, configMap, { [name]: apiCardConfigMap });
            }, {});
            const newCache = Object.assign({}, previousCache, apiCardConfigCache);
            if (JSON.stringify(previousCache) !== JSON.stringify(newCache)) {
                yield this.persistenceProvider.setGiftCardConfigCache(this.getNetwork(), newCache);
            }
        });
    }
    fetchCachedApiCardConfig() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.cachedApiCardConfigPromise = this.persistenceProvider.getGiftCardConfigCache(this.getNetwork());
            return this.cachedApiCardConfigPromise;
        });
    }
    getCachedApiCardConfig() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const config = this.cachedApiCardConfigPromise
                ? yield this.cachedApiCardConfigPromise
                : yield this.fetchCachedApiCardConfig();
            return config || {};
        });
    }
    getAvailableCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            return this.availableCardsPromise
                ? this.availableCardsPromise
                : this.fetchAvailableCards();
        });
    }
    fetchAvailableCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.availableCardsPromise = this.fetchAvailableCardMap().then(availableCardMap => getCardConfigFromApiConfigMap(availableCardMap, this.platformProvider.isCordova)
                .map(apiCardConfig => (Object.assign({}, apiCardConfig, { displayName: apiCardConfig.displayName || apiCardConfig.name })))
                .filter(filterDisplayableConfig)
                .sort(sortByDisplayName));
            return this.availableCardsPromise;
        });
    }
    preloadImages() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const supportedCards = yield this.getSupportedCards();
            const imagesPerCard = supportedCards
                .map(c => [c.icon, c.cardImage])
                .filter(images => images[0] && images[1]);
            const fetchBatches = imagesPerCard.map(images => () => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () { return Promise.all(images.map(i => this.imageLoader.preload(i))); }));
            yield Object(__WEBPACK_IMPORTED_MODULE_10__utils__["a" /* promiseSerial */])(fetchBatches);
        });
    }
    logEvent(eventName, eventParams) {
        if (this.getNetwork() !== __WEBPACK_IMPORTED_MODULE_18__persistence_persistence__["a" /* Network */].livenet)
            return;
        this.analyticsProvider.logEvent(eventName, eventParams);
    }
    getDiscountEventParams(discountedCard, context) {
        const discount = discountedCard.discounts[0];
        return {
            brand: discountedCard.name,
            code: discount.code,
            context,
            type: discount.type,
            discountAmount: discount.amount
        };
    }
    register() {
        this.homeIntegrationsProvider.register({
            name: 'giftcards',
            title: 'Gift Cards',
            icon: 'assets/img/gift-cards/gift-cards-icon.svg',
            show: !!this.configProvider.get().showIntegration['giftcards']
        });
    }
};
GiftCardProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_11__analytics_analytics__["a" /* AnalyticsProvider */],
        __WEBPACK_IMPORTED_MODULE_12__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_13__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_image_loader__["a" /* ImageLoader */],
        __WEBPACK_IMPORTED_MODULE_15__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_20__time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_14__email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_17__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_18__persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_19__platform_platform__["a" /* PlatformProvider */]])
], GiftCardProvider);

function getCardConfigFromApiConfigMap(availableCardMap, isCordova) {
    const cardNames = Object.keys(availableCardMap);
    const availableCards = cardNames
        .filter(cardName => availableCardMap[cardName] && availableCardMap[cardName].length)
        .map(cardName => getCardConfigFromApiBrandConfig(cardName, availableCardMap[cardName]))
        .map(cardConfig => removeDiscountsIfNotMobile(cardConfig, isCordova));
    return availableCards;
}
function removeDiscountsIfNotMobile(cardConfig, isCordova) {
    return Object.assign({}, cardConfig, { discounts: isCordova ? cardConfig.discounts : undefined });
}
function getCardConfigFromApiBrandConfig(cardName, apiBrandConfig) {
    const cards = apiBrandConfig;
    const [firstCard] = cards;
    const { currency } = firstCard;
    const range = cards.find(c => !!(c.maxAmount || c.minAmount) && c.currency === currency);
    const fixed = cards.filter(c => c.amount && c.currency);
    const supportedAmounts = fixed
        .reduce((newSupportedAmounts, currentCard) => [
        ...newSupportedAmounts,
        currentCard.amount
    ], [])
        .sort((a, b) => a - b);
    const activationFees = cards
        .filter(c => c.activationFees)
        .reduce((allFees, card) => allFees.concat(card.activationFees), []);
    const { amount, type, maxAmount, minAmount } = firstCard, config = __WEBPACK_IMPORTED_MODULE_0_tslib__["h" /* __rest */](firstCard, ["amount", "type", "maxAmount", "minAmount"]);
    const baseConfig = Object.assign({}, config, { name: cardName, activationFees });
    return range
        ? Object.assign({}, baseConfig, { minAmount: range.minAmount < 1 ? 1 : range.minAmount, maxAmount: range.maxAmount }) : Object.assign({}, baseConfig, { supportedAmounts });
}
function getActivationFee(amount, cardConfig) {
    const activationFees = (cardConfig && cardConfig.activationFees) || [];
    const fixedFee = activationFees.find(fee => fee.type === 'fixed' &&
        amount >= fee.amountRange.min &&
        amount <= fee.amountRange.max);
    return (fixedFee && fixedFee.fee) || 0;
}
function filterDisplayableConfig(cardConfig) {
    return (cardConfig.logo &&
        cardConfig.icon &&
        cardConfig.cardImage &&
        !cardConfig.hidden);
}
function sortByDescendingDate(a, b) {
    return a.date < b.date ? 1 : -1;
}
function sortByDisplayName(a, b) {
    const aSortValue = getDisplayNameSortValue(a.displayName);
    const bSortValue = getDisplayNameSortValue(b.displayName);
    return aSortValue > bSortValue ? 1 : -1;
}
function getDisplayNameSortValue(displayName) {
    const startsNumeric = value => /^[0-9]$/.test(value.charAt(0));
    const name = displayName.toLowerCase();
    return `${startsNumeric(name) ? 'zzz' : ''}${name}`;
}
function setNullableCardFields(card, cardConfig) {
    return Object.assign({}, card, { name: cardConfig.name, displayName: cardConfig.displayName, currency: card.currency || getCurrencyFromLegacySavedCard(cardConfig.name) });
}
function getCardsFromInvoiceMap(invoiceMap, configMap) {
    return Object.keys(invoiceMap)
        .map(invoiceId => invoiceMap[invoiceId])
        .filter(card => card.invoiceId && configMap[card.name])
        .map(card => setNullableCardFields(card, configMap[card.name]))
        .sort(sortByDescendingDate);
}
function hasVisibleDiscount(cardConfig) {
    return !!getVisibleDiscount(cardConfig);
}
function getVisibleDiscount(cardConfig) {
    const discounts = cardConfig.discounts;
    const supportedDiscountTypes = ['flatrate', 'percentage'];
    return (discounts &&
        discounts.find(d => supportedDiscountTypes.includes(d.type) && !d.hidden));
}
function appendFallbackImages(cardConfig) {
    // For cards bought outside of the user's current IP catalog area before server-side
    // catalog management was implemented and card images were stored locally.
    const getBrandImagePath = brandName => {
        const cardImagePath = `https://bitpay.com/gift-cards/assets/`;
        const brandImageDirectory = brandName
            .toLowerCase()
            .replace(/[^0-9a-z]/gi, '');
        return `${cardImagePath}${brandImageDirectory}/`;
    };
    const getImagesForBrand = brandName => {
        const imagePath = getBrandImagePath(brandName);
        return {
            cardImage: `${imagePath}card.png`,
            icon: `${imagePath}icon.svg`,
            logo: `${imagePath}logo.svg`
        };
    };
    const needsFallback = cardConfig &&
        cardConfig.cardImage &&
        !cardConfig.cardImage.includes('https://bitpay.com');
    return needsFallback
        ? Object.assign({}, cardConfig, getImagesForBrand(cardConfig.name)) : cardConfig;
}
function getCurrencyFromLegacySavedCard(cardName) {
    switch (cardName) {
        case 'Amazon.com':
            return 'USD';
        case 'Amazon.co.jp':
            return 'JPY';
        case 'Mercado Livre':
            return 'BRL';
        default:
            return 'USD';
    }
}
//# sourceMappingURL=gift-card.js.map

/***/ }),

/***/ 860:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ISTORAGE */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);

class KeyAlreadyExistsError extends Error {
    constructor() {
        super('Key already exists');
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = KeyAlreadyExistsError;

let ISTORAGE = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["InjectionToken"]('storage');
//# sourceMappingURL=istorage.js.map

/***/ }),

/***/ 90:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletTabsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);


let WalletTabsProvider = class WalletTabsProvider {
    goToTabIndex(index) {
        return this.tabNav.select(index);
    }
    setTabNav(nav) {
        this.tabNav = nav;
    }
    getTabNav() {
        return this.tabNav;
    }
    setSendParams(params) {
        this.sendParams = params;
    }
    getSendParams() {
        return this.sendParams;
    }
    setFromPage(page) {
        this.fromPage = page;
    }
    getFromPage() {
        return this.fromPage;
    }
    clear() {
        this.tabNav = null;
        this.sendParams = null;
        this.fromPage = null;
    }
};
WalletTabsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])()
], WalletTabsProvider);

//# sourceMappingURL=wallet-tabs.provider.js.map

/***/ }),

/***/ 95:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FinishModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);




let FinishModalPage = class FinishModalPage {
    constructor(viewCtrl, navParams, translate) {
        this.viewCtrl = viewCtrl;
        this.navParams = navParams;
        this.translate = translate;
        this.finishText =
            this.navParams.data.finishText || this.navParams.data.finishText == ''
                ? this.navParams.data.finishText
                : this.translate.instant('Payment Sent');
        this.finishComment = this.navParams.data.finishComment
            ? this.navParams.data.finishComment
            : '';
        this.cssClass = this.navParams.data.cssClass
            ? this.navParams.data.cssClass
            : 'success';
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
FinishModalPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-finish',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/finish/finish.html"*/'<div class="container">\n  <div class="content" [ngClass]="{\'success\': cssClass == \'success\', \'warning\': cssClass == \'warning\', \'danger\': cssClass == \'danger\', \'primary\': cssClass == \'primary\'}">\n    <div class="body">\n      <div class="body-img success-img" *ngIf="cssClass == \'primary\'"></div>\n      <img class="body-img" *ngIf="cssClass == \'success\'" src="assets/img/onboarding-success.svg">\n      <img class="body-img" *ngIf="(cssClass != \'success\' && cssClass != \'primary\')" src="assets/img/warning.svg">\n      <div class="body-text">\n        {{finishText}}\n      </div>\n      <div class="body-comment">\n        {{finishComment}}\n      </div>\n    </div>\n  </div>\n  <div class="footer" (click)="close()">\n    OK\n  </div>\n</div>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/finish/finish.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], FinishModalPage);

//# sourceMappingURL=finish.js.map

/***/ }),

/***/ 975:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackupProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_download_download__ = __webpack_require__(462);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__key_key__ = __webpack_require__(66);



// Providers






let BackupProvider = class BackupProvider {
    constructor(appProvider, bwcProvider, configProvider, downloadProvider, logger, profileProvider, keyProvider) {
        this.appProvider = appProvider;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.downloadProvider = downloadProvider;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.keyProvider = keyProvider;
        this.logger.debug('BackupProvider initialized');
    }
    walletDownload(walletId, opts, password) {
        return new Promise((resolve, reject) => {
            let config = this.configProvider.get();
            let wallet = this.profileProvider.getWallet(walletId);
            let ew = this.walletExport(walletId, opts, password);
            if (!ew)
                return reject('Could not create backup');
            let walletName = wallet.credentials.walletName || wallet.credentials.walletId;
            let alias = config.aliasFor && config.aliasFor[wallet.credentials.walletId];
            if (alias) {
                walletName = alias + ' [' + walletName + ']';
            }
            if (opts.noSign)
                walletName = walletName + '-noSign';
            let filename = walletName + '-' + this.appProvider.info.nameCase + 'backup.aes.json';
            this.downloadProvider.download(ew, filename).then(() => {
                return resolve();
            });
        });
    }
    walletExport(walletId, opts, password) {
        if (!password) {
            return null;
        }
        let wallet = this.profileProvider.getWallet(walletId);
        try {
            opts = opts ? opts : {};
            let b = {};
            b.credentials = JSON.parse(wallet.toString(opts));
            if (b.credentials.keyId && opts.noSign) {
                delete b.credentials.keyId;
            }
            if (wallet.canSign && !opts.noSign) {
                const k = {};
                Object.assign(k, this.keyProvider.getKey(wallet.credentials.keyId));
                if (opts.password) {
                    const k1 = this.keyProvider.get(wallet.credentials.keyId, opts.password);
                    k.mnemonic = k1.mnemonic;
                    k.xPrivKey = k1.xPrivKey;
                    delete k.xPrivKeyEncrypted;
                    delete k.mnemonicEncrypted;
                }
                b.key = k;
            }
            if (opts.addressBook)
                b.addressBook = opts.addressBook;
            b = JSON.stringify(b);
            return this.bwcProvider.getSJCL().encrypt(password, b, {
                iter: 10000
            });
        }
        catch (err) {
            this.logger.error('Error exporting wallet: ', err);
            return null;
        }
    }
};
BackupProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_7__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_download_download__["a" /* DownloadProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_8__key_key__["a" /* KeyProvider */]])
], BackupProvider);

//# sourceMappingURL=backup.js.map

/***/ }),

/***/ 976:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InvoiceProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__email_notifications_email_notifications__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__ = __webpack_require__(39);







let InvoiceProvider = class InvoiceProvider {
    constructor(emailNotificationsProvider, http, logger, persistenceProvider) {
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.http = http;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.credentials = {
            NETWORK: __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__["a" /* Network */].livenet,
            BITPAY_API_URL: 'https://bitpay.com'
        };
        this.logger.debug('InvoiceProvider initialized');
        this.setCredentials();
    }
    getNetwork() {
        return this.credentials.NETWORK;
    }
    setCredentials() {
        if (this.getNetwork() === __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__["a" /* Network */].testnet) {
            this.credentials.BITPAY_API_URL = 'https://test.bitpay.com';
        }
    }
    getApiPath() {
        return `${this.credentials.BITPAY_API_URL}/gift-cards`;
    }
    getBitPayInvoice(id) {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const res = yield this.http
                .get(`${this.credentials.BITPAY_API_URL}/invoices/${id}`)
                .toPromise()
                .catch(err => {
                this.logger.error('BitPay Get Invoice: ERROR ' + err.error.message);
                throw err.error.message;
            });
            this.logger.info('BitPay Get Invoice: SUCCESS');
            return res.data;
        });
    }
    emailIsValid(email) {
        const validEmail = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(email);
        return validEmail;
    }
    storeEmail(email) {
        this.setUserInfo({ email });
    }
    getUserEmail() {
        return this.persistenceProvider
            .getGiftCardUserInfo()
            .then(data => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](data)) {
                data = JSON.parse(data);
            }
            return data && data.email
                ? data.email
                : this.emailNotificationsProvider.getEmailIfEnabled();
        })
            .catch(_ => { });
    }
    setUserInfo(data) {
        this.persistenceProvider.setGiftCardUserInfo(JSON.stringify(data));
    }
};
InvoiceProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_5__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__["b" /* PersistenceProvider */]])
], InvoiceProvider);

//# sourceMappingURL=invoice.js.map

/***/ }),

/***/ 977:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HttpRequestsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__platform_platform__ = __webpack_require__(12);




// providers


let HttpRequestsProvider = class HttpRequestsProvider {
    constructor(http, logger, platformProvider) {
        this.http = http;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.logger.debug('HttpRequestsProvider Provider initialized');
        this.isIOS = this.platformProvider.isIOS;
    }
    post(url, data, headers) {
        if (this.isIOS) {
            return new __WEBPACK_IMPORTED_MODULE_3_rxjs__["Observable"](observer => {
                cordova.plugin.http.setDataSerializer('json');
                cordova.plugin.http.post(url, data, headers, res => {
                    try {
                        res.data = JSON.parse(res.data);
                    }
                    catch (e) {
                        // TODO
                    }
                    observer.next(res.data);
                    observer.complete();
                }, err => {
                    observer.error(err.error);
                });
            });
        }
        else
            return this.http.post(url, data, { headers });
    }
    get(url, params, headers) {
        if (this.isIOS) {
            return new __WEBPACK_IMPORTED_MODULE_3_rxjs__["Observable"](observer => {
                cordova.plugin.http.setDataSerializer('json');
                cordova.plugin.http.get(url, params, headers, res => {
                    try {
                        res.data = JSON.parse(res.data);
                    }
                    catch (e) {
                        // TODO
                    }
                    observer.next(res.data);
                    observer.complete();
                }, err => {
                    observer.error(err.error);
                });
            });
        }
        else
            return this.http.get(url, { headers });
    }
};
HttpRequestsProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__platform_platform__["a" /* PlatformProvider */]])
], HttpRequestsProvider);

//# sourceMappingURL=http-requests.js.map

/***/ }),

/***/ 978:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LanguageLoader; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_gettext_parser__ = __webpack_require__(1959);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_gettext_parser___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_gettext_parser__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_operators_map__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_operators_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_operators_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__platform_platform__ = __webpack_require__(12);








let LanguageLoader = class LanguageLoader {
    constructor(http, file, platformProvider) {
        this.http = http;
        this.file = file;
        this.platformProvider = platformProvider;
        this.domain = '';
        this._prefix = 'assets/i18n/';
        this._suffix = '.po';
    }
    getTranslation(lang) {
        if (this.platformProvider.isCordova) {
            return __WEBPACK_IMPORTED_MODULE_5_rxjs_Observable__["Observable"].fromPromise(this.file
                .readAsText(this.file.applicationDirectory + 'www/', `${this._prefix}/${lang}${this._suffix}`)
                .then(data => {
                return this.parse(data);
            }));
        }
        else {
            return this.http
                .get(`${this._prefix}/${lang}${this._suffix}`, { responseType: 'text' })
                .pipe(Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_operators_map__["map"])((contents) => this.parse(contents)));
        }
    }
    parse(contents) {
        let translations = {};
        const po = __WEBPACK_IMPORTED_MODULE_4_gettext_parser__["po"].parse(contents, 'utf-8');
        if (!po.translations.hasOwnProperty(this.domain)) {
            return translations;
        }
        Object.keys(po.translations[this.domain]).forEach(key => {
            const translation = po.translations[this.domain][key].msgstr.pop();
            if (key.length > 0 && translation.length > 0) {
                translations[key] = translation;
            }
        });
        return translations;
    }
};
LanguageLoader = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__["a" /* File */],
        __WEBPACK_IMPORTED_MODULE_7__platform_platform__["a" /* PlatformProvider */]])
], LanguageLoader);

//# sourceMappingURL=language-loader.js.map

/***/ }),

/***/ 981:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ScanProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_qr_scanner__ = __webpack_require__(851);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__platform_platform__ = __webpack_require__(12);






let ScanProvider = class ScanProvider {
    constructor(qrScanner, platform, logger, events) {
        this.qrScanner = qrScanner;
        this.platform = platform;
        this.logger = logger;
        this.events = events;
        this.isDesktop = !this.platform.isCordova;
        this.isAvailable = true;
        this.hasPermission = false;
        this.isDenied = false;
        this.isRestricted = false;
        this.canEnableLight = false;
        this.canChangeCamera = false;
        this.canOpenSettings = false;
        this.backCamera = true;
        this.initializeStarted = false;
        this.initializeCompleted = false;
        this.scannerVisible = false;
        this.lightEnabled = false;
        this.frontCameraEnabled = false;
    }
    checkCapabilities(status) {
        this.logger.info('scannerService is reviewing platform capabilities...');
        // Permission can be assumed on the desktop builds
        this.hasPermission = this.isDesktop || status.authorized ? true : false;
        this.isDenied = status.denied ? true : false;
        this.isRestricted = status.restricted ? true : false;
        this.canEnableLight = status.canEnableLight ? true : false;
        this.canChangeCamera = status.canChangeCamera ? true : false;
        this.canOpenSettings = status.canOpenSettings ? true : false;
        this.logCapabilities();
    }
    orIsNot(bool) {
        return bool ? '' : 'not ';
    }
    logCapabilities() {
        this.logger.debug('A camera is ' + this.orIsNot(this.isAvailable) + 'available to this app.');
        var access = 'not authorized';
        if (this.hasPermission)
            access = 'authorized';
        if (this.isDenied)
            access = 'denied';
        if (this.isRestricted)
            access = 'restricted';
        this.logger.debug('Camera access is ' + access + '.');
        this.logger.debug('Support for opening device settings is ' +
            this.orIsNot(this.canOpenSettings) +
            'available on this platform.');
        this.logger.debug('A light is ' +
            this.orIsNot(this.canEnableLight) +
            'available on this platform.');
        this.logger.debug('A second camera is ' +
            this.orIsNot(this.canChangeCamera) +
            'available on this platform.');
    }
    /**
     * Immediately return known capabilities of the current platform.
     */
    getCapabilities() {
        return {
            isAvailable: this.isAvailable,
            hasPermission: this.hasPermission,
            isDenied: this.isDenied,
            isRestricted: this.isRestricted,
            canEnableLight: this.canEnableLight,
            canChangeCamera: this.canChangeCamera,
            canOpenSettings: this.canOpenSettings
        };
    }
    /**
     * If camera access has been granted, pre-initialize the QRScanner. This method
     * can be safely called before the scanner is visible to improve perceived
     * scanner loading times.
     *
     * The `status` of QRScanner is returned to the callback.
     */
    gentleInitialize() {
        return new Promise(resolve => {
            if (this.initializeStarted && !this.isDesktop) {
                this.qrScanner.getStatus().then(status => {
                    this.completeInitialization(status);
                });
                return resolve();
            }
            this.initializeStarted = true;
            this.logger.debug('Trying to pre-initialize QRScanner.');
            if (!this.isDesktop) {
                this.qrScanner.getStatus().then(status => {
                    this.checkCapabilities(status);
                    if (status.authorized) {
                        this.logger.debug('Camera permission already granted.');
                        this.initialize().then(() => {
                            return resolve();
                        });
                    }
                    else {
                        this.logger.debug('QRScanner not authorized, waiting to initalize.');
                        this.completeInitialization(status);
                        return resolve();
                    }
                });
            }
            else {
                this.logger.debug('To avoid flashing the privacy light, we do not pre-initialize the camera on desktop.');
                return resolve();
            }
        });
    }
    reinitialize() {
        this.initializeCompleted = false;
        this.qrScanner.destroy();
        this.initialize();
    }
    initialize() {
        return new Promise(resolve => {
            this.logger.info('Initializing scanner...');
            this.qrScanner
                .prepare()
                .then(status => {
                this.completeInitialization(status);
                return resolve();
            })
                .catch(err => {
                this.isAvailable = false;
                this.logger.error(err);
                // does not return `status` if there is an error
                this.qrScanner.getStatus().then(status => {
                    this.completeInitialization(status);
                    return resolve();
                });
            });
        });
    }
    completeInitialization(status) {
        this.checkCapabilities(status);
        this.initializeCompleted = true;
        this.events.publish('scannerServiceInitialized');
    }
    isInitialized() {
        return this.initializeCompleted;
    }
    isInitializeStarted() {
        return this.initializeStarted;
    }
    /**
     * (Re)activate the QRScanner, and cancel the timeouts if present.
     *
     * The `status` of QRScanner is passed to the callback when activation
     * is complete.
     */
    activate() {
        return new Promise(resolve => {
            this.logger.info('Activating scanner...');
            this.qrScanner.show().then(status => {
                this.initializeCompleted = true;
                this.checkCapabilities(status);
                return resolve();
            });
        });
    }
    /**
     * Start a new scan.
     */
    scan() {
        return new Promise(resolve => {
            this.logger.info('Scanning...');
            let scanSub = this.qrScanner.scan().subscribe((text) => {
                this.logger.debug('Scan success');
                scanSub.unsubscribe(); // stop scanning
                return resolve(text);
            });
        });
    }
    pausePreview() {
        this.qrScanner.pausePreview();
    }
    resumePreview() {
        this.qrScanner.resumePreview();
    }
    /**
     * Deactivate the QRScanner. To balance user-perceived performance and power
     * consumption, this kicks off a countdown which will "sleep" the scanner
     * after a certain amount of time.
     *
     * The `status` of QRScanner is passed to the callback when deactivation
     * is complete.
     */
    deactivate() {
        this.logger.info('Deactivating scanner...');
        if (this.lightEnabled) {
            this.qrScanner.disableLight();
            this.lightEnabled = false;
        }
        this.hide();
        this.destroy();
    }
    // Natively hide the QRScanner's preview
    // On mobile platforms, this can reduce GPU/power usage
    // On desktop, this fully turns off the camera (and any associated privacy lights)
    hide() {
        this.qrScanner.hide();
    }
    // Reduce QRScanner power/processing consumption by the maximum amount
    destroy() {
        this.qrScanner.destroy();
    }
    /**
     * Toggle the device light (if available).
     *
     * The callback receives a boolean which is `true` if the light is enabled.
     */
    toggleLight() {
        return new Promise((resolve, reject) => {
            this.logger.info('Toggling light...');
            if (this.lightEnabled) {
                this.qrScanner
                    .disableLight()
                    .then(() => {
                    this.lightEnabled = false;
                    return resolve(this.lightEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (disableLight)', err);
                    return reject(err);
                });
            }
            else {
                this.qrScanner
                    .enableLight()
                    .then(() => {
                    this.lightEnabled = true;
                    return resolve(this.lightEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (enableLight)', err);
                    return reject(err);
                });
            }
        });
    }
    /**
     * Switch cameras (if a second camera is available).
     *
     * The `status` of QRScanner is passed to the callback when activation
     * is complete.
     */
    toggleCamera() {
        return new Promise((resolve, reject) => {
            this.logger.info('Toggling camera...');
            if (this.frontCameraEnabled) {
                this.qrScanner
                    .useBackCamera()
                    .then(() => {
                    this.frontCameraEnabled = false;
                    return resolve(this.frontCameraEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (useBackCamera)', err);
                    return reject(err);
                });
            }
            else {
                this.qrScanner
                    .useFrontCamera()
                    .then(() => {
                    this.frontCameraEnabled = true;
                    return resolve(this.frontCameraEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (useFrontCamera)', err);
                    return reject(err);
                });
            }
        });
    }
    openSettings() {
        this.logger.info('Attempting to open device settings...');
        this.qrScanner.openSettings();
    }
};
ScanProvider = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ionic_native_qr_scanner__["a" /* QRScanner */],
        __WEBPACK_IMPORTED_MODULE_5__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* Events */]])
], ScanProvider);

//# sourceMappingURL=scan.js.map

/***/ }),

/***/ 982:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HomePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__add_wallet_add_wallet__ = __webpack_require__(320);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__add_add__ = __webpack_require__(324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__add_create_wallet_create_wallet__ = __webpack_require__(321);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__integrations_bitpay_card_bitpay_card__ = __webpack_require__(327);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__integrations_coinbase_coinbase__ = __webpack_require__(248);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__integrations_shapeshift_shapeshift__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__settings_settings__ = __webpack_require__(995);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__proposals_proposals__ = __webpack_require__(474);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_bitpay_card_bitpay_card__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_clipboard_clipboard__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_email_notifications_email_notifications__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_feedback_feedback__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_home_integrations_home_integrations__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_incoming_data_incoming_data__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_paypro_paypro__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_persistence_persistence__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__providers_wallet_wallet__ = __webpack_require__(32);








// Pages









// Providers
















let HomePage = class HomePage {
    constructor(plt, navCtrl, profileProvider, walletProvider, bwcErrorProvider, logger, events, externalLinkProvider, popupProvider, appProvider, platformProvider, homeIntegrationsProvider, payproProvider, persistenceProvider, feedbackProvider, bitPayCardProvider, translate, emailProvider, clipboardProvider, incomingDataProvider, statusBar) {
        this.plt = plt;
        this.navCtrl = navCtrl;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.logger = logger;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.popupProvider = popupProvider;
        this.appProvider = appProvider;
        this.platformProvider = platformProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.payproProvider = payproProvider;
        this.persistenceProvider = persistenceProvider;
        this.feedbackProvider = feedbackProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.translate = translate;
        this.emailProvider = emailProvider;
        this.clipboardProvider = clipboardProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.statusBar = statusBar;
        this.showBitPayCard = false;
        this.showAnnouncement = false;
        this.walletFocusHandler = opts => {
            this.logger.debug('RECV Local/WalletFocus @home', opts);
            opts = opts || {};
            opts.alsoUpdateHistory = true;
            this.fetchWalletStatus(opts);
        };
        this.walletActionHandler = opts => {
            this.logger.debug('RECV Local/TxAction @home', opts);
            opts = opts || {};
            opts.alsoUpdateHistory = true;
            this.fetchWalletStatus(opts);
        };
        this.debounceFetchWalletStatus = __WEBPACK_IMPORTED_MODULE_5_lodash__["debounce"]((walletId, alsoUpdateHistory) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.fetchWalletStatus({ walletId, alsoUpdateHistory });
        }), 3000);
        // BWS events can come many at time (publish,sign, broadcast...)
        this.bwsEventHandler = (walletId, type, n) => {
            // NewBlock, NewCopayer, NewAddress, NewTxProposal, TxProposalAcceptedBy, TxProposalRejectedBy, txProposalFinallyRejected,
            // txProposalFinallyAccepted, TxProposalRemoved, NewIncomingTx, NewOutgoingTx
            const wallet = this.profileProvider.getWallet(walletId);
            if (wallet.copayerId == n.creatorId) {
                return;
            }
            this.logger.info(`BWS Event: ${type}: `, n);
            let alsoUpdateHistory = false;
            switch (type) {
                case 'NewAddress':
                    this.walletProvider.expireAddress(walletId);
                    return;
                case 'NewIncomingTx':
                case 'NewOutgoingTx':
                case 'NewBlock':
                    alsoUpdateHistory = true;
            }
            this.walletProvider.invalidateCache(wallet);
            this.debounceFetchWalletStatus(walletId, alsoUpdateHistory);
        };
        this.debounceSetWallets = __WEBPACK_IMPORTED_MODULE_5_lodash__["debounce"](() => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.setWallets(true);
        }), 5000, {
            leading: true
        });
        this.setWallets = (shouldUpdate = false) => {
            // TEST
            /*
            setTimeout(() => {
              this.logger.info('##### Load BITCOIN URI TEST');
              this.incomingDataProvider.redir('bitcoin:3KeJU7VxSKC451pPNSWjF6zK3gm2x7re7q?amount=0.0001');
            },100);
            */
            this.wallets = this.profileProvider.getWallets();
            this.walletsGroups = __WEBPACK_IMPORTED_MODULE_5_lodash__["values"](__WEBPACK_IMPORTED_MODULE_5_lodash__["groupBy"](__WEBPACK_IMPORTED_MODULE_5_lodash__["filter"](this.wallets, wallet => {
                return wallet.keyId != 'read-only';
            }), 'keyId'));
            this.readOnlyWalletsGroup = this.profileProvider.getWalletsFromGroup({
                keyId: 'read-only'
            });
            this.profileProvider.setLastKnownBalance();
            // Avoid heavy tasks that can slow down the unlocking experience
            if (!this.appProvider.isLockModalOpen && shouldUpdate) {
                this.fetchAllWalletsStatus();
            }
        };
        // Names:
        // .fetch => from BWS
        // .update => to UI
        /* This is the only .getStatus call in Copay */
        this.fetchWalletStatus = (opts) => {
            if (!opts.walletId) {
                this.logger.error('Error no walletId in update Wallet');
                return;
            }
            this.events.publish('Local/WalletUpdate', {
                walletId: opts.walletId,
                finished: false
            });
            this.logger.debug('fetching status for: ' +
                opts.walletId +
                ' alsohistory:' +
                opts.alsoUpdateHistory);
            const wallet = this.profileProvider.getWallet(opts.walletId);
            if (!wallet)
                return;
            this.walletProvider
                .fetchStatus(wallet, opts)
                .then(status => {
                wallet.cachedStatus = status;
                wallet.error = wallet.errorObj = null;
                this.persistenceProvider.setLastKnownBalance(wallet.id, wallet.cachedStatus.availableBalanceStr);
                // Update txps
                this.updateTxps();
                this.events.publish('Local/WalletUpdate', {
                    walletId: opts.walletId,
                    finished: true
                });
                if (opts.alsoUpdateHistory) {
                    this.fetchTxHistory({ walletId: opts.walletId, force: opts.force });
                }
            })
                .catch(err => {
                if (err == 'INPROGRESS')
                    return;
                this.logger.warn('Update error:', err);
                this.processWalletError(wallet, err);
                this.events.publish('Local/WalletUpdate', {
                    walletId: opts.walletId,
                    finished: true,
                    error: wallet.error
                });
                if (opts.alsoUpdateHistory) {
                    this.fetchTxHistory({ walletId: opts.walletId, force: opts.force });
                }
            });
        };
        this.slideDown = false;
        this.isBlur = false;
        this.isCordova = this.platformProvider.isCordova;
        this.isElectron = this.platformProvider.isElectron;
        this.collapsedGroups = {};
        // Update Wallet on Focus
        if (this.isElectron) {
            this.updateDesktopOnFocus();
        }
        this.zone = new __WEBPACK_IMPORTED_MODULE_1__angular_core__["NgZone"]({ enableLongStackTrace: false });
        this.events.subscribe('Home/reloadStatus', () => {
            this._willEnter(true);
            this._didEnter();
        });
    }
    ionViewWillEnter() {
        this._willEnter();
    }
    ionViewDidEnter() {
        this._didEnter();
    }
    _willEnter(shouldUpdate = false) {
        if (this.platformProvider.isIOS) {
            this.statusBar.styleDefault();
        }
        // Update list of wallets, status and TXPs
        this.setWallets(shouldUpdate);
        this.checkPriceChart();
    }
    _didEnter() {
        this.checkClipboard();
        // Show integrations
        const integrations = this.homeIntegrationsProvider
            .get()
            .filter(i => i.show)
            .filter(i => i.name !== 'giftcards' && i.name !== 'debitcard');
        this.showGiftCards = this.homeIntegrationsProvider.shouldShowInHome('giftcards');
        this.showBitpayCardGetStarted = this.homeIntegrationsProvider.shouldShowInHome('debitcard');
        // Hide BitPay if linked
        setTimeout(() => {
            this.homeIntegrations = __WEBPACK_IMPORTED_MODULE_5_lodash__["remove"](__WEBPACK_IMPORTED_MODULE_5_lodash__["clone"](integrations), x => {
                if (x.name == 'debitcard' && x.linked)
                    return false;
                else
                    return x;
            });
        }, 200);
        // Only BitPay Wallet
        this.bitPayCardProvider.get({ noHistory: true }).then(cards => {
            this.showBitPayCard = !!this.appProvider.info._enabledExtensions
                .debitcard;
            this.bitpayCardItems = cards;
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: HomePage');
        // Required delay to improve performance loading
        setTimeout(() => {
            this.showSurveyCard();
            this.showEthLive();
            this.checkFeedbackInfo();
            this.checkEmailLawCompliance();
        }, 2000);
        const subscribeEvents = () => {
            // BWS Events: Update Status per Wallet -> Update txps
            // NewBlock, NewCopayer, NewAddress, NewTxProposal, TxProposalAcceptedBy, TxProposalRejectedBy, txProposalFinallyRejected,
            // txProposalFinallyAccepted, TxProposalRemoved, NewIncomingTx, NewOutgoingTx
            this.events.subscribe('bwsEvent', this.bwsEventHandler);
            // Create, Join, Import and Delete -> Get Wallets -> Update Status for All Wallets -> Update txps
            this.events.subscribe('Local/WalletListChange', () => this.setWallets(true));
            // Reject, Remove, OnlyPublish and SignAndBroadcast -> Update Status per Wallet -> Update txps
            this.events.subscribe('Local/TxAction', this.walletActionHandler);
            // Wallet is focused on some inner view, therefore, we refresh its status and txs
            this.events.subscribe('Local/WalletFocus', this.walletFocusHandler);
        };
        subscribeEvents();
        this.onResumeSubscription = this.plt.resume.subscribe(() => {
            this.setWallets();
            this.checkClipboard();
            subscribeEvents();
        });
        this.onPauseSubscription = this.plt.pause.subscribe(() => {
            this.events.unsubscribe('bwsEvent', this.bwsEventHandler);
            this.events.unsubscribe('Local/WalletListChange', this.setWallets);
            this.events.unsubscribe('Local/TxAction', this.walletFocusHandler);
            this.events.unsubscribe('Local/WalletFocus', this.walletFocusHandler);
        });
        this.setWallets(true);
    }
    ngOnDestroy() {
        this.onResumeSubscription.unsubscribe();
        this.onPauseSubscription.unsubscribe();
    }
    ionViewWillLeave() {
        this.resetValuesForAnimationCard();
    }
    resetValuesForAnimationCard() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield __WEBPACK_IMPORTED_MODULE_7_rxjs__["Observable"].timer(50).toPromise();
            this.validDataFromClipboard = null;
            this.slideDown = false;
        });
    }
    updateDesktopOnFocus() {
        const { remote } = window.require('electron');
        const win = remote.getCurrentWindow();
        win.on('focus', () => {
            if (this.navCtrl.getActive() &&
                this.navCtrl.getActive().name == 'HomePage') {
                this.checkClipboard();
                this.setWallets();
            }
        });
    }
    openEmailDisclaimer() {
        const message = this.translate.instant('By providing your email address, you give explicit consent to BitPay to use your email address to send you email notifications about payments.');
        const title = this.translate.instant('Privacy Policy update');
        const okText = this.translate.instant('Accept');
        const cancelText = this.translate.instant('Disable notifications');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then(ok => {
            if (ok) {
                // Accept new Privacy Policy
                this.persistenceProvider.setEmailLawCompliance('accepted');
            }
            else {
                // Disable email notifications
                this.persistenceProvider.setEmailLawCompliance('rejected');
                this.emailProvider.updateEmail({
                    enabled: false,
                    email: 'null@email'
                });
            }
        });
    }
    checkEmailLawCompliance() {
        setTimeout(() => {
            if (this.emailProvider.getEmailIfEnabled()) {
                this.persistenceProvider.getEmailLawCompliance().then(value => {
                    if (!value)
                        this.openEmailDisclaimer();
                });
            }
        }, 2000);
    }
    showSurveyCard() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const hideSurvey = yield this.persistenceProvider.getSurveyFlag();
            this.showSurvey.setShowSurveyCard(!hideSurvey);
        });
    }
    showEthLive() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            const hideEthLiveCard = yield this.persistenceProvider.getEthLiveCardFlag();
            if (!hideEthLiveCard) {
                let hasNoLegacy = false;
                this.walletsGroups.forEach((walletsGroup) => {
                    if (walletsGroup[0].canAddNewAccount) {
                        hasNoLegacy = true;
                    }
                });
                this.showEthLiveCard.setShowEthLiveCard(hasNoLegacy);
            }
        });
    }
    checkFeedbackInfo() {
        // Hide feeback card if survey card is shown
        // TODO remove this condition
        if (this.showSurvey)
            return;
        this.persistenceProvider.getFeedbackInfo().then(info => {
            if (!info) {
                this.initFeedBackInfo();
            }
            else {
                const feedbackInfo = info;
                // Check if current version is greater than saved version
                const currentVersion = this.appProvider.info.version;
                const savedVersion = feedbackInfo.version;
                const isVersionUpdated = this.feedbackProvider.isVersionUpdated(currentVersion, savedVersion);
                if (!isVersionUpdated) {
                    this.initFeedBackInfo();
                    return;
                }
                const now = __WEBPACK_IMPORTED_MODULE_6_moment__().unix();
                const timeExceeded = now - feedbackInfo.time >= 24 * 7 * 60 * 60;
                this.showRateCard = timeExceeded && !feedbackInfo.sent;
                this.showCard.setShowRateCard(this.showRateCard);
            }
        });
    }
    checkPriceChart() {
        this.persistenceProvider.getHiddenFeaturesFlag().then(res => {
            this.showPriceChart = res === 'enabled' ? true : false;
            this.updateCharts();
        });
    }
    updateCharts() {
        if (this.showPriceChart && this.priceCard)
            this.priceCard.updateCharts();
    }
    onWalletAction(wallet, action, slidingItem) {
        const tabMap = {
            receive: 0,
            view: 1,
            send: 2
        };
        const selectedTabIndex = tabMap[action];
        this.goToWalletDetails(wallet, { selectedTabIndex });
        slidingItem.close();
    }
    checkClipboard() {
        return this.clipboardProvider
            .getData()
            .then((data) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.validDataFromClipboard = this.incomingDataProvider.parseData(data);
            if (!this.validDataFromClipboard) {
                return;
            }
            const dataToIgnore = [
                'BitcoinAddress',
                'BitcoinCashAddress',
                'EthereumAddress',
                'PlainUrl'
            ];
            if (dataToIgnore.indexOf(this.validDataFromClipboard.type) > -1) {
                this.validDataFromClipboard = null;
                return;
            }
            if (this.validDataFromClipboard.type === 'PayPro' ||
                this.validDataFromClipboard.type === 'InvoiceUri') {
                try {
                    const invoiceUrl = this.incomingDataProvider.getPayProUrl(data);
                    const disableLoader = true;
                    const payproOptions = yield this.payproProvider.getPayProOptions(invoiceUrl, disableLoader);
                    const { expires, paymentOptions, payProUrl } = payproOptions;
                    let selected = paymentOptions.filter(option => option.selected);
                    if (selected.length === 0) {
                        // No Currency Selected default to BTC
                        selected.push(payproOptions.paymentOptions[0]); // BTC
                    }
                    const [{ currency, estimatedAmount }] = selected;
                    this.payProDetailsData = payproOptions;
                    this.payProDetailsData.coin = currency.toLowerCase();
                    this.payProDetailsData.amount = estimatedAmount;
                    this.payProDetailsData.host = new URL(payProUrl).host;
                    this.clearCountDownInterval();
                    this.paymentTimeControl(expires);
                }
                catch (err) {
                    this.payProDetailsData = {};
                    this.payProDetailsData.error = err.message;
                    this.logger.warn('Error in Payment Protocol', err);
                }
            }
            yield __WEBPACK_IMPORTED_MODULE_7_rxjs__["Observable"].timer(50).toPromise();
            this.slideDown = true;
        }))
            .catch(err => {
            this.logger.warn('Paste from clipboard: ', err);
        });
    }
    hideClipboardCard() {
        this.validDataFromClipboard = null;
        this.clipboardProvider.clear();
        this.slideDown = false;
    }
    processClipboardData(data) {
        this.clearCountDownInterval();
        this.incomingDataProvider.redir(data, { fromHomeCard: true });
    }
    clearCountDownInterval() {
        if (this.countDown)
            clearInterval(this.countDown);
    }
    paymentTimeControl(expires) {
        const expirationTime = Math.floor(new Date(expires).getTime() / 1000);
        const setExpirationTime = () => {
            const now = Math.floor(Date.now() / 1000);
            if (now > expirationTime) {
                this.remainingTimeStr = this.translate.instant('Expired');
                this.clearCountDownInterval();
                return;
            }
            const totalSecs = expirationTime - now;
            const m = Math.floor(totalSecs / 60);
            const s = totalSecs % 60;
            this.remainingTimeStr = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
        };
        setExpirationTime();
        this.countDown = setInterval(() => {
            setExpirationTime();
        }, 1000);
    }
    initFeedBackInfo() {
        this.persistenceProvider.setFeedbackInfo({
            time: __WEBPACK_IMPORTED_MODULE_6_moment__().unix(),
            version: this.appProvider.info.version,
            sent: false
        });
        this.showRateCard = false;
    }
    fetchTxHistory(opts) {
        if (!opts.walletId) {
            this.logger.error('Error no walletId in update History');
            return;
        }
        const wallet = this.profileProvider.getWallet(opts.walletId);
        const progressFn = ((_, newTxs) => {
            let args = {
                walletId: opts.walletId,
                finished: false,
                progress: newTxs
            };
            this.events.publish('Local/WalletHistoryUpdate', args);
        }).bind(this);
        // Fire a startup event, to allow UI to show the spinner
        this.events.publish('Local/WalletHistoryUpdate', {
            walletId: opts.walletId,
            finished: false
        });
        this.walletProvider
            .fetchTxHistory(wallet, progressFn, opts)
            .then(txHistory => {
            wallet.completeHistory = txHistory;
            this.events.publish('Local/WalletHistoryUpdate', {
                walletId: opts.walletId,
                finished: true
            });
        })
            .catch(err => {
            if (err != 'HISTORY_IN_PROGRESS') {
                this.logger.warn('WalletHistoryUpdate ERROR', err);
                this.events.publish('Local/WalletHistoryUpdate', {
                    walletId: opts.walletId,
                    finished: false,
                    error: err
                });
            }
        });
    }
    updateTxps() {
        this.profileProvider
            .getTxps({ limit: 3 })
            .then(data => {
            this.zone.run(() => {
                this.txpsN = data.n;
            });
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    fetchAllWalletsStatus() {
        let foundMessage = false;
        if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](this.wallets))
            return;
        this.logger.debug('fetchAllWalletsStatus');
        const pr = wallet => {
            return this.walletProvider
                .fetchStatus(wallet, {})
                .then((status) => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
                wallet.cachedStatus = status;
                wallet.error = wallet.errorObj = null;
                if (!foundMessage && !__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](status.serverMessages)) {
                    this.serverMessages = __WEBPACK_IMPORTED_MODULE_5_lodash__["orderBy"](status.serverMessages, ['priority'], ['asc']);
                    this.serverMessages.forEach(serverMessage => {
                        this.checkServerMessage(serverMessage);
                    });
                    foundMessage = true;
                }
                this.persistenceProvider.setLastKnownBalance(wallet.id, wallet.cachedStatus.availableBalanceStr);
                this.events.publish('Local/WalletUpdate', {
                    walletId: wallet.id,
                    finished: true
                });
                return Promise.resolve();
            }))
                .catch(err => {
                this.processWalletError(wallet, err);
                return Promise.resolve();
            });
        };
        const promises = [];
        __WEBPACK_IMPORTED_MODULE_5_lodash__["each"](this.profileProvider.wallet, wallet => {
            promises.push(pr(wallet));
        });
        Promise.all(promises).then(() => {
            this.updateTxps();
        });
    }
    processWalletError(wallet, err) {
        wallet.error = wallet.errorObj = null;
        if (!err || err == 'INPROGRESS')
            return;
        wallet.cachedStatus = null;
        wallet.errorObj = err;
        if (err.message === '403') {
            this.accessDenied = true;
            wallet.error = this.translate.instant('Access denied');
        }
        else if (err === 'WALLET_NOT_REGISTERED') {
            wallet.error = this.translate.instant('Wallet not registered');
        }
        else {
            wallet.error = this.bwcErrorProvider.msg(err);
        }
        this.logger.warn(this.bwcErrorProvider.msg(wallet.error, 'Error updating status for ' + wallet.id));
    }
    removeServerMessage(id) {
        this.serverMessages = __WEBPACK_IMPORTED_MODULE_5_lodash__["filter"](this.serverMessages, s => s.id !== id);
    }
    dismissServerMessage(serverMessage) {
        this.showServerMessage = false;
        this.logger.debug(`Server message id: ${serverMessage.id} dismissed`);
        this.persistenceProvider.setServerMessageDismissed(serverMessage.id);
        this.removeServerMessage(serverMessage.id);
    }
    checkServerMessage(serverMessage) {
        if (serverMessage.app && serverMessage.app != this.appProvider.info.name) {
            this.removeServerMessage(serverMessage.id);
            return;
        }
        if (serverMessage.id === 'bcard-atm' &&
            (!this.showBitPayCard ||
                !this.bitpayCardItems ||
                !this.bitpayCardItems[0])) {
            this.removeServerMessage(serverMessage.id);
            return;
        }
        this.persistenceProvider
            .getServerMessageDismissed(serverMessage.id)
            .then((value) => {
            if (value === 'dismissed') {
                this.removeServerMessage(serverMessage.id);
                return;
            }
            this.showServerMessage = true;
        });
    }
    openServerMessageLink(url) {
        this.externalLinkProvider.open(url);
    }
    openCountryBannedLink() {
        const url = "https://github.com/bitpay/copay/wiki/Why-can't-I-use-BitPay's-services-in-my-country%3F";
        this.externalLinkProvider.open(url);
    }
    goToWalletDetails(wallet, params) {
        this.events.publish('OpenWallet', wallet, params);
    }
    openProposalsPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__proposals_proposals__["a" /* ProposalsPage */]);
    }
    goTo(page) {
        const pageMap = {
            BitPayCardIntroPage: __WEBPACK_IMPORTED_MODULE_12__integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__["a" /* BitPayCardIntroPage */],
            CoinbasePage: __WEBPACK_IMPORTED_MODULE_13__integrations_coinbase_coinbase__["a" /* CoinbasePage */],
            ShapeshiftPage: __WEBPACK_IMPORTED_MODULE_14__integrations_shapeshift_shapeshift__["a" /* ShapeshiftPage */]
        };
        this.navCtrl.push(pageMap[page]);
    }
    goToCard(cardId) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__integrations_bitpay_card_bitpay_card__["a" /* BitPayCardPage */], { id: cardId });
    }
    doRefresh(refresher) {
        this.debounceSetWallets();
        setTimeout(() => {
            this.updateCharts();
            refresher.complete();
        }, 2000);
    }
    scan() {
        this.navCtrl.parent.select(1);
    }
    settings() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_15__settings_settings__["a" /* SettingsPage */]);
    }
    collapseGroup(keyId) {
        this.collapsedGroups[keyId] = this.collapsedGroups[keyId] ? false : true;
    }
    isCollapsed(keyId) {
        return this.collapsedGroups[keyId] ? true : false;
    }
    addWallet(fromEthCard) {
        let keyId;
        const compatibleKeyWallets = __WEBPACK_IMPORTED_MODULE_5_lodash__["values"](__WEBPACK_IMPORTED_MODULE_5_lodash__["groupBy"](__WEBPACK_IMPORTED_MODULE_5_lodash__["filter"](this.wallets, wallet => {
            if (wallet.canAddNewAccount && wallet.keyId != 'read-only') {
                keyId = wallet.keyId;
                return true;
            }
            else
                return false;
        }), 'keyId'));
        if (fromEthCard && compatibleKeyWallets.length == 1) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__add_create_wallet_create_wallet__["a" /* CreateWalletPage */], {
                isShared: false,
                coin: 'eth',
                keyId
            });
        }
        else if (fromEthCard && compatibleKeyWallets.length > 1) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__add_wallet_add_wallet__["a" /* AddWalletPage */], {
                isCreate: true,
                isMultipleSeed: true,
                fromEthCard
            });
        }
        else {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__add_add__["a" /* AddPage */], {
                // Select currency to add to the same key (1 single seed compatible key)
                keyId: compatibleKeyWallets.length == 1 ? keyId : null,
                // Creates new key (same flow as onboarding)
                isZeroState: compatibleKeyWallets.length == 0 ? true : false,
                // Select currency and Key or creates a new Key
                isMultipleSeed: compatibleKeyWallets.length > 1 ? true : false
            });
        }
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('showCard'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], HomePage.prototype, "showCard", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('showSurvey'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], HomePage.prototype, "showSurvey", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('showEthLiveCard'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], HomePage.prototype, "showEthLiveCard", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('priceCard'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], HomePage.prototype, "priceCard", void 0);
HomePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-home',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/home/home.html"*/'<ion-header>\n  <ion-navbar class="home-header" [ngClass]="{blur: isBlur}">\n    <ion-buttons left class="add-button" *ngIf="wallets && wallets[0]">\n      <button ion-button clear (click)="addWallet()" class="add">\n        <img src="assets/img/add-wallet/add-wallet.svg" />\n      </button>\n    </ion-buttons>\n    <ion-title>\n      <img class="home-logo" src="assets/img/app/logo.svg" />\n    </ion-title>\n    <ion-buttons right class="settings-button">\n      <button ion-button clear icon-only color="grey" *ngIf="txpsN > 0" (click)="openProposalsPage()">\n        <ion-badge class="notifications-badge">{{ txpsN }}</ion-badge>\n      </button>\n      <button class="modal-close-button" (click)="settings()" ion-button>\n        <img src="assets/img/settings.svg" />\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content class="fullscreen-tab" [ngClass]="{blur: isBlur}" #scrollArea>\n  <ion-refresher (ionRefresh)="doRefresh($event)" pullMin="90" pullMax="180">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n\n  <div [ngClass]="{\n      \'content-animation\': slideDown,\n      \'initial-margin\': validDataFromClipboard\n    }">\n\n    <div class="card clipboard-card" *ngIf="validDataFromClipboard">\n      <ion-item-divider>\n        <div class="title" item-start>\n          <img src="assets/img/paste-clipboard.svg" alt="Clipboard" width="20" />\n          <span>{{ \'Copied\' | translate }} {{ validDataFromClipboard?.title }}</span>\n        </div>\n        <div item-end>\n          <button ion-button clear icon-only color="grey" (click)="hideClipboardCard()">\n            <ion-icon name="close"></ion-icon>\n          </button>\n        </div>\n      </ion-item-divider>\n      <page-clipboard-card [remainingTimeStr]="remainingTimeStr" [payProDetailsData]="payProDetailsData" [validDataFromClipboard]="validDataFromClipboard" (click)="processClipboardData(validDataFromClipboard.data)">\n      </page-clipboard-card>\n    </div>\n\n    <ion-card class="server-message" *ngIf="showServerMessage && serverMessages && serverMessages[0]">\n      <ion-card-header class="server-message-header" *ngIf="serverMessages[0].dismissible">\n        <ion-row>\n          <button ion-button clear icon-only color="grey" (click)="dismissServerMessage(serverMessages[0])">\n            <ion-icon name="close"></ion-icon>\n          </button>\n        </ion-row>\n      </ion-card-header>\n      <ion-card-content class="server-message-content">\n        <div class="server-message-icon" *ngIf="serverMessages[0].category" [ngClass]="{ \'no-header\': !serverMessages[0].dismissible }">\n          <img src="assets/img/icon-warning-circled.svg" *ngIf="serverMessages[0].category == \'critical\'" />\n          <img src="assets/img/icon-info-blue.svg" *ngIf="serverMessages[0].category == \'info\'" />\n        </div>\n        <div class="server-message-title" *ngIf="serverMessages[0].title" [ngClass]="{\n            title: !serverMessages[0].category,\n            \'title-info\': serverMessages[0].category == \'info\',\n            \'title-critical\': serverMessages[0].category == \'critical\'\n          }">\n          {{ serverMessages[0].title }}\n        </div>\n        <div class="server-message-body" *ngIf="serverMessages[0].body">\n          {{ serverMessages[0].body }}\n        </div>\n        <div class="server-message-button" *ngIf="serverMessages[0].link" (click)="openServerMessageLink(serverMessages[0].link)">\n          <span *ngIf="serverMessages[0].linkText">{{\n            serverMessages[0].linkText\n          }}</span>\n          <span translate *ngIf="!serverMessages[0].linkText">Learn more</span>\n        </div>\n      </ion-card-content>\n    </ion-card>\n\n    <page-feedback-card #showCard></page-feedback-card>\n    <page-survey-card #showSurvey></page-survey-card>\n    <page-eth-live-card #showEthLiveCard (addEthClicked)="addWallet(true)"></page-eth-live-card>\n\n    <div *ngIf="showPriceChart && wallets && wallets[0]">\n      <div class="section-header" translate>Price Chart</div>\n      <price-card #priceCard></price-card>\n    </div>\n\n    <create-new-wallet *ngIf="!wallets || !wallets[0]"></create-new-wallet>\n\n    <ion-card class="server-message" *ngIf="accessDenied">\n      <ion-card-content class="server-message-content">\n        <div class="server-message-icon">\n          <img src="assets/img/icon-warning-circled.svg" />\n        </div>\n        <div class="server-message-title title-critical" translate>\n          Access denied\n        </div>\n        <div class="server-message-body" translate>\n          Unfortunately, your country/region has banned the use or acceptance of cryptocurrencies as a valid form of payment and we are therefore unable to service you.\n        </div>\n        <div class="server-message-button" (click)="openCountryBannedLink()">\n          <span translate>Learn more</span>\n        </div>\n      </ion-card-content>\n    </ion-card>\n\n    <div *ngFor="let walletGroup of walletsGroups; let i = index" class="wallets-container">\n      <div class="section-header" *ngIf="walletGroup[0].canSign">\n        <span class="key-name" *ngIf="walletsGroups.length > 1">{{profileProvider.getWalletGroup(walletGroup[0].keyId).name}}</span>\n        <span *ngIf="walletsGroups.length == 1" translate>Wallets</span>\n        <div class="collapse" (click)="collapseGroup(walletGroup[0].keyId)">\n          <span *ngIf="!walletGroup[0].canAddNewAccount" class="legacy-tag" translate>Legacy</span>\n          <span class="collapse-btn" *ngIf="walletsGroups.length > 1">\n            <ion-icon *ngIf="!isCollapsed(walletGroup[0].keyId)" name="ios-arrow-down"></ion-icon>\n            <ion-icon *ngIf="isCollapsed(walletGroup[0].keyId)" name="ios-arrow-up"></ion-icon>\n          </span>\n        </div>\n      </div>\n      <ion-list class="sliding-container wallets" [ngClass]="{\'collapsed\': isCollapsed(walletGroup[0].keyId)}">\n        <div *ngFor="let wallet of walletGroup" class="wallet-wrapper">\n          <ion-item-sliding #slidingItem>\n            <button ion-item detail-none (click)="onWalletAction(wallet, \'view\', slidingItem)">\n              <wallet-item-content [wallet]="wallet"></wallet-item-content>\n            </button>\n            <ion-item-options side="left">\n              <button class="action action--send" ion-button (click)="onWalletAction(wallet, \'send\', slidingItem)">\n                <div class="action__icon"><img src="assets/img/send.svg" /></div>\n                <div class="action__text">Send</div>\n              </button>\n            </ion-item-options>\n            <ion-item-options side="right">\n              <button class="action action--receive" ion-button (click)="onWalletAction(wallet, \'receive\', slidingItem)">\n                <div class="action__icon"><img src="assets/img/receive.svg" /></div>\n                <div class="action__text">Receive</div>\n              </button>\n            </ion-item-options>\n          </ion-item-sliding>\n        </div>\n      </ion-list>\n      <label-tip type="warn" *ngIf="walletGroup && walletGroup[0] && walletGroup[0].needsBackup" margin-top>\n        <span label-tip-title translate>Needs Backup</span>\n        <div label-tip-body>\n          <span translate>Before retrieving your wallets addresses, it\'s recommended that you first write down your recovery phrase and store it securely so that your wallets can be recovered in the case your device was lost or stolen.</span>\n        </div>\n      </label-tip>\n    </div>\n\n    <div class="section-header" *ngIf="readOnlyWalletsGroup && readOnlyWalletsGroup.length > 0" translate>\n      Read Only Wallets\n    </div>\n\n    <div *ngFor="let readOnlyWallet of readOnlyWalletsGroup; let i = index" class="wallets-container">\n      <ion-list class="sliding-container wallets">\n        <div class="wallet-wrapper">\n          <ion-item-sliding #slidingItem>\n            <button ion-item detail-none (click)="onWalletAction(readOnlyWallet, \'view\', slidingItem)">\n              <wallet-item-content [wallet]="readOnlyWallet"></wallet-item-content>\n            </button>\n            <ion-item-options side="left">\n              <button class="action action--send" ion-button (click)="onWalletAction(readOnlyWallet, \'send\', slidingItem)">\n                <div class="action__icon"><img src="assets/img/send.svg" /></div>\n                <div class="action__text">Send</div>\n              </button>\n            </ion-item-options>\n            <ion-item-options side="right">\n              <button class="action action--receive" ion-button (click)="onWalletAction(readOnlyWallet, \'receive\', slidingItem)">\n                <div class="action__icon"><img src="assets/img/receive.svg" /></div>\n                <div class="action__text">Receive</div>\n              </button>\n            </ion-item-options>\n          </ion-item-sliding>\n        </div>\n      </ion-list>\n    </div>\n\n    <div class="section-header" *ngIf="\n      (showBitPayCard && ((bitpayCardItems && bitpayCardItems[0]) || showBitpayCardGetStarted) || showGiftCards) && wallets && wallets[0]\n    " translate>Cards</div>\n\n    <ion-list class="bitpay-card" *ngIf="\n        showBitPayCard &&\n        bitpayCardItems &&\n        bitpayCardItems[0] &&\n        wallets &&\n        wallets[0]\n      ">\n      <div *ngFor="let card of bitpayCardItems" class="card-item sliding-container">\n        <ion-item-sliding class="card-item-sliding">\n          <button ion-item (click)="goToCard(card.id)">\n            <img src="assets/img/app/logo-negative.svg" />\n            <ion-note class="ellipsis" item-end>\n              <div class="funds ellipsis">\n                <span *ngIf="card.balance">\n                  {{ card.currencySymbol + (card.balance | number: \'1.2-2\') }}\n                </span>\n                <span *ngIf="!card.balance">\n                  {{ \'Add funds to get started\' | translate }}\n                </span>\n              </div>\n              <div class="number ellipsis">\n                Card ({{ card.lastFourDigits }})\n              </div>\n            </ion-note>\n          </button>\n        </ion-item-sliding>\n      </div>\n    </ion-list>\n\n    <bitpay-card-home *ngIf="\n        showBitPayCard && showBitpayCardGetStarted && wallets && wallets[0]\n      "></bitpay-card-home>\n\n    <gift-cards *ngIf="showGiftCards && wallets && wallets[0]" [scrollArea]="scrollArea"></gift-cards>\n\n    <div *ngIf="\n        homeIntegrations && homeIntegrations.length > 0 && wallets && wallets[0]\n      ">\n      <div class="section-header" translate>Services</div>\n      <div *ngFor="let service of (homeIntegrations | orderBy: [\'title\'])" class="card-item sliding-container">\n        <ion-item-sliding class="card-item-sliding">\n          <button ion-item (click)="goTo(service.page, service.name)" [ngStyle]="{\'background\': service.background}">\n            <img src="{{service.logo}}" width="145" alt="{{ service.title || service.name }}" />\n          </button>\n        </ion-item-sliding>\n      </div>\n    </div>\n  </div>\n\n  <div *ngIf="isCordova && wallets && wallets[0]" class="margin-helper"></div>\n\n  <button *ngIf="wallets && wallets[0]" ion-button ion-fixed class="scan-button" (click)="scan()">\n    <ion-avatar item-start> <img src="assets/img/scan.svg" /> </ion-avatar>\n    <div translate>Scan</div>\n  </button>\n\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/home/home.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4_ionic_angular__["q" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_31__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_32__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_26__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["f" /* Events */],
        __WEBPACK_IMPORTED_MODULE_22__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_30__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_29__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_24__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_27__providers_paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_28__providers_persistence_persistence__["b" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_23__providers_feedback_feedback__["a" /* FeedbackProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_21__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_clipboard_clipboard__["a" /* ClipboardProvider */],
        __WEBPACK_IMPORTED_MODULE_25__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */]])
], HomePage);

//# sourceMappingURL=home.js.map

/***/ }),

/***/ 983:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinSelectorPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers__ = __webpack_require__(35);



// Providers

let CoinSelectorPage = class CoinSelectorPage {
    constructor(currencyProvider, logger, viewCtrl, navParams) {
        this.currencyProvider = currencyProvider;
        this.logger = logger;
        this.viewCtrl = viewCtrl;
        this.navParams = navParams;
        this.logger.debug('Coin selector initialized;');
        this.description = this.navParams.data.description;
        this.availableChains = this.currencyProvider.getAvailableChains();
    }
    getCoinName(coin) {
        return this.currencyProvider.getCoinName(coin);
    }
    selectedCoin(coin) {
        this.viewCtrl.dismiss({
            selectedCoin: coin
        });
    }
};
CoinSelectorPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-coin-selector',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/includes/coin-selector/coin-selector.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Coin Selector\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button class="modal-close-button" (click)="selectedCoin()" ion-button>\n        <ion-icon name="arrow-round-back"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="description" *ngIf="description">{{ description }}</div>\n  <ion-list class="settings-list bp-list">\n    <div *ngFor="let coin of availableChains">\n      <button class="list-button" ion-item (click)="selectedCoin(coin)">\n        <ion-icon item-start>\n          <img src="assets/img/currencies/{{coin}}.svg" />\n        </ion-icon>\n        <div class="item-title">{{ getCoinName(coin) }} ({{ coin.toUpperCase() }})</div>\n      </button>\n    </div>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/includes/coin-selector/coin-selector.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers__["r" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers__["N" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */]])
], CoinSelectorPage);

//# sourceMappingURL=coin-selector.js.map

/***/ }),

/***/ 984:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayCardTopUpPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__finish_finish__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__bitpay_card__ = __webpack_require__(327);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bitpay_card_bitpay_card__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_bitpay_bitpay__ = __webpack_require__(246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_fee_fee__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_paypro_paypro__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_wallet_wallet__ = __webpack_require__(32);






// Pages


// Provider

















const FEE_TOO_HIGH_LIMIT_PER = 15;
let BitPayCardTopUpPage = class BitPayCardTopUpPage {
    constructor(actionSheetProvider, bitPayCardProvider, bitPayProvider, bwcErrorProvider, bwcProvider, configProvider, currencyProvider, externalLinkProvider, incomingDataProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, popupProvider, profileProvider, txFormatProvider, walletProvider, translate, platformProvider, feeProvider, payproProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.bitPayProvider = bitPayProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.incomingDataProvider = incomingDataProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.platformProvider = platformProvider;
        this.feeProvider = feeProvider;
        this.payproProvider = payproProvider;
        this.configWallet = this.configProvider.get().wallet;
        this.isCordova = this.platformProvider.isCordova;
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.hideSlideButton = false;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: BitPayCardTopUpPage');
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewDidEnter() {
        this.logLegacyCardAddToCartEvent();
    }
    ionViewWillEnter() {
        if (this.navCtrl.getPrevious().name == 'SelectInvoicePage') {
            this.navCtrl.remove(this.navCtrl.getPrevious().index);
        }
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.cardId = this.navParams.data.id;
        this.useSendMax = this.navParams.data.useSendMax;
        this.currency = this.navParams.data.currency;
        this.amount = this.navParams.data.amount;
        let coin = __WEBPACK_IMPORTED_MODULE_15__providers_currency_currency__["a" /* Coin */][this.currency] ? __WEBPACK_IMPORTED_MODULE_15__providers_currency_currency__["a" /* Coin */][this.currency] : null;
        this.bitPayCardProvider.logEvent('legacycard_topup_amount', {
            usdAmount: this.amount,
            transactionCurrency: 'USD'
        });
        this.bitPayCardProvider
            .get({
            cardId: this.cardId,
            noBalance: true,
            noHistory: true
        })
            .then(card => {
            this.bitPayCardProvider.setCurrencySymbol(card[0]);
            this.lastFourDigits = card[0].lastFourDigits;
            this.currencySymbol = card[0].currencySymbol;
            this.currencyIsoCode = card[0].currency;
            this.wallets = this.profileProvider.getWallets({
                onlyComplete: true,
                network: this.bitPayProvider.getEnvironment().network,
                hasFunds: true,
                coin
            });
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.wallets)) {
                this.showErrorAndBack(null, this.translate.instant('No wallets available'));
                return;
            }
            this.showWallets(); // Show wallet selector
        });
    }
    updateRates(coin) {
        this.bitPayCardProvider.getRatesFromCoin(coin.toUpperCase(), this.currencyIsoCode, (err, r) => {
            if (err)
                this.logger.error(err);
            this.rate = r.rate;
        });
    }
    _resetValues() {
        this.totalAmountStr = this.amount = this.invoiceFee = this.networkFee = this.totalAmount = this.wallet = null;
        this.createdTx = null;
    }
    showErrorAndBack(title, msg) {
        this.hideSlideButton = false;
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.errors ? msg.errors[0].message : msg;
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.navCtrl.pop();
        });
    }
    showError(title, msg) {
        return new Promise(resolve => {
            this.hideSlideButton = false;
            if (this.isCordova)
                this.slideButton.isConfirmed(false);
            title = title || this.translate.instant('Error');
            this.logger.error(msg);
            msg = msg && msg.errors ? msg.errors[0].message : msg;
            this.popupProvider.ionicAlert(title, msg).then(() => {
                return resolve();
            });
        });
    }
    satToFiat(coin, sat) {
        return new Promise(resolve => {
            this.txFormatProvider
                .toFiat(coin, sat, this.currencyIsoCode)
                .then((value) => {
                return resolve(value);
            });
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (!wallet.canSign) {
                let err = this.translate.instant('No signing proposal: No private key');
                return reject(err);
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.logLegacyCardSetCheckoutOption(wallet);
                this.onGoingProcessProvider.clear();
                return resolve(txp);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.logger.warn('Paypro error: removing payment proposal');
                this.walletProvider.removeTx(wallet, txp).catch(() => {
                    this.logger.warn('Could not delete payment proposal');
                });
                return reject(err);
            });
        });
    }
    setTotalAmount(wallet, amountSat, invoiceFeeSat, networkFeeSat) {
        this.satToFiat(wallet.coin, amountSat).then((a) => {
            this.amount = Number(a);
            this.satToFiat(wallet.coin, invoiceFeeSat).then((i) => {
                this.invoiceFee = Number(i);
                this.satToFiat(wallet.coin, networkFeeSat).then((n) => {
                    this.networkFee = Number(n);
                    this.totalAmount = this.amount + this.invoiceFee + this.networkFee;
                });
            });
        });
    }
    isCryptoCurrencySupported(wallet, invoice) {
        let COIN = wallet.coin.toUpperCase();
        if (!invoice['supportedTransactionCurrencies'][COIN])
            return false;
        return invoice['supportedTransactionCurrencies'][COIN].enabled;
    }
    createInvoice(data) {
        return new Promise((resolve, reject) => {
            this.bitPayCardProvider.topUp(this.cardId, data, (err, invoiceId) => {
                if (err) {
                    return reject({
                        title: 'Could not create the invoice',
                        message: err
                    });
                }
                this.bitPayCardProvider.getInvoice(invoiceId, (err, inv) => {
                    if (err) {
                        return reject({
                            title: 'Could not get the invoice',
                            message: err
                        });
                    }
                    return resolve(inv);
                });
            });
        });
    }
    createTx(wallet, invoice, message) {
        let COIN = wallet.coin.toUpperCase();
        return new Promise((resolve, reject) => {
            const paymentCode = this.currencyProvider.getPaymentCode(wallet.coin);
            const protocolUrl = invoice.paymentCodes[COIN][paymentCode];
            const payProUrl = this.incomingDataProvider.getPayProUrl(protocolUrl);
            if (!payProUrl) {
                return reject({
                    title: this.translate.instant('Error in Payment Protocol'),
                    message: this.translate.instant('Invalid URL')
                });
            }
            this.payproProvider
                .getPayProDetails(payProUrl, wallet.coin)
                .then(details => {
                const { instructions } = details;
                let txp = {
                    coin: wallet.coin,
                    amount: __WEBPACK_IMPORTED_MODULE_4_lodash__["sumBy"](instructions, 'amount'),
                    toAddress: instructions[0].toAddress,
                    outputs: [],
                    message,
                    customData: {
                        service: 'debitcard'
                    },
                    payProUrl,
                    excludeUnconfirmedUtxos: this.configWallet.spendUnconfirmed
                        ? false
                        : true
                };
                for (const instruction of instructions) {
                    txp.outputs.push({
                        toAddress: instruction.toAddress,
                        amount: instruction.amount,
                        message: instruction.message,
                        data: instruction.data
                    });
                }
                if (wallet.credentials.token) {
                    txp.tokenAddress = wallet.credentials.token.address;
                }
                if (details.requiredFeeRate) {
                    const requiredFeeRate = !this.currencyProvider.isUtxoCoin(wallet.coin)
                        ? details.requiredFeeRate
                        : Math.ceil(details.requiredFeeRate * 1024);
                    txp.feePerKb = requiredFeeRate;
                    this.logger.debug('Using merchant fee rate (for debit card):' + txp.feePerKb);
                }
                else {
                    txp.feeLevel = this.configWallet.settings.feeLevel || 'normal';
                }
                txp['origToAddress'] = txp.toAddress;
                if (wallet.coin && wallet.coin == 'bch') {
                    txp.toAddress = this.bitcoreCash
                        .Address(txp.toAddress)
                        .toString(true);
                    txp.outputs[0].toAddress = txp.toAddress;
                }
                return this.walletProvider
                    .getAddress(this.wallet, false)
                    .then(address => {
                    txp.from = address;
                    this.walletProvider
                        .createTx(wallet, txp)
                        .then(ctxp => {
                        return resolve(ctxp);
                    })
                        .catch(err => {
                        return reject({
                            title: this.translate.instant('Could not create transaction'),
                            message: this.bwcErrorProvider.msg(err)
                        });
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getSendMaxInfo(wallet) {
        return new Promise((resolve, reject) => {
            this.feeProvider
                .getFeeRate(wallet.coin, wallet.credentials.network, this.feeProvider.getCurrentFeeLevel())
                .then(feePerKb => {
                this.walletProvider
                    .getSendMaxInfo(wallet, {
                    feePerKb,
                    excludeUnconfirmedUtxos: !this.configWallet.spendUnconfirmed,
                    returnInputs: true
                })
                    .then(resp => {
                    return resolve({
                        sendMax: true,
                        amount: resp.amount,
                        inputs: resp.inputs,
                        fee: resp.fee,
                        feePerKb
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    toFixedTrunc(value, n) {
        const v = value.toString().split('.');
        if (n <= 0)
            return v[0];
        let f = v[1] || '';
        if (f.length > n)
            return `${v[0]}.${f.substr(0, n)}`;
        while (f.length < n)
            f += '0';
        return `${v[0]}.${f}`;
    }
    calculateAmount(wallet) {
        let COIN = wallet.coin.toUpperCase();
        return new Promise((resolve, reject) => {
            // Global variables defined beforeEnter
            let a = this.amount;
            let c = this.currency;
            if (this.useSendMax) {
                this.getSendMaxInfo(wallet)
                    .then(maxValues => {
                    if (maxValues.amount == 0) {
                        return reject({
                            message: this.translate.instant('Insufficient funds for fee')
                        });
                    }
                    const { unitDecimals, unitToSatoshi } = this.currencyProvider.getPrecision(this.wallet.coin);
                    let maxAmount = Number((maxValues.amount / unitToSatoshi).toFixed(unitDecimals));
                    // Round to 6 digits
                    maxAmount = this.toFixedTrunc(maxAmount, 6);
                    this.createInvoice({
                        amount: maxAmount,
                        currency: wallet.coin.toUpperCase()
                    })
                        .then(inv => {
                        // Check if BTC or BCH is enabled in this account
                        if (!this.isCryptoCurrencySupported(wallet, inv)) {
                            return reject({
                                message: this.translate.instant('Top-up with this cryptocurrency is not enabled')
                            });
                        }
                        inv['minerFees'][COIN]['totalFee'] =
                            inv.minerFees[COIN].totalFee || 0;
                        let invoiceFeeSat = inv.minerFees[COIN].totalFee;
                        let maxAmountSat = Number((maxAmount * unitToSatoshi).toFixed(0));
                        let newAmountSat = maxAmountSat - invoiceFeeSat;
                        // Set expiration time for this invoice
                        if (inv.expirationTime)
                            this.paymentTimeControl(inv.expirationTime);
                        if (newAmountSat <= 0) {
                            return reject({
                                message: this.translate.instant('Insufficient funds for fee')
                            });
                        }
                        return resolve({ amount: newAmountSat, currency: 'sat' });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject({
                        title: null,
                        message: err
                    });
                });
            }
            else {
                return resolve({ amount: a, currency: c });
            }
        });
    }
    checkFeeHigh(amount, fee) {
        let per = (fee / (amount + fee)) * 100;
        if (per > FEE_TOO_HIGH_LIMIT_PER) {
            const minerFeeInfoSheet = this.actionSheetProvider.createInfoSheet('miner-fee');
            minerFeeInfoSheet.present();
        }
    }
    logLegacyCardTopUpEvent(wallet, isConfirm) {
        const legacyCardTopUpEventInfo = {
            usdAmount: this.amount,
            transactionCurrency: wallet.coin.toUpperCase()
        };
        !isConfirm
            ? this.bitPayCardProvider.logEvent('legacycard_topup_amount', legacyCardTopUpEventInfo)
            : this.bitPayCardProvider.logEvent('legacycard_topup_finish', legacyCardTopUpEventInfo);
    }
    logLegacyCardPurchaseEvent() {
        this.bitPayCardProvider.logEvent('purchase', {
            value: this.amount,
            items: [
                {
                    name: 'legacyCard',
                    category: 'debitCard',
                    quantity: 1,
                    price: this.amount
                }
            ]
        });
    }
    initializeTopUp(wallet, parsedAmount) {
        let COIN = wallet.coin.toUpperCase();
        this.amountUnitStr = parsedAmount.amountUnitStr;
        var dataSrc = {
            amount: parsedAmount.amount,
            currency: parsedAmount.currency
        };
        this.onGoingProcessProvider.set('loadingTxInfo');
        this.logLegacyCardTopUpEvent(wallet, false);
        this.createInvoice(dataSrc)
            .then(invoice => {
            // Check if BTC or BCH is enabled in this account
            if (!this.isCryptoCurrencySupported(wallet, invoice)) {
                let msg = this.translate.instant('Top-up with this cryptocurrency is not enabled');
                this.showErrorAndBack(null, msg);
                return;
            }
            // Sometimes API does not return this element;
            invoice['minerFees'][COIN]['totalFee'] =
                invoice.minerFees[COIN].totalFee || 0;
            let invoiceFeeSat = invoice.minerFees[COIN].totalFee;
            let message = this.amountUnitStr + ' to ' + this.lastFourDigits;
            // Set expiration time for this invoice
            if (invoice['expirationTime'])
                this.paymentTimeControl(invoice['expirationTime']);
            this.createTx(wallet, invoice, message)
                .then(ctxp => {
                this.onGoingProcessProvider.clear();
                // Save TX in memory
                this.createdTx = ctxp;
                this.totalAmountStr = this.txFormatProvider.formatAmountStr(wallet.coin, ctxp.amount);
                if (this.currencyProvider.isUtxoCoin(wallet.coin)) {
                    // Warn: fee too high
                    this.checkFeeHigh(Number(parsedAmount.amountSat), Number(invoiceFeeSat) + Number(ctxp.fee));
                }
                this.setTotalAmount(wallet, parsedAmount.amountSat, Number(invoiceFeeSat), ctxp.fee);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this._resetValues();
                this.showError(err.title, err.message);
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorAndBack(err.title, err.message);
        });
    }
    logLegacyCardAddToCartEvent() {
        this.bitPayCardProvider.logEvent('add_to_cart', {
            items: [
                {
                    name: 'legacyCard',
                    category: 'debitCard'
                }
            ]
        });
    }
    topUpConfirm() {
        if (!this.createdTx) {
            this.showError(null, this.translate.instant('Transaction has not been created'));
            return;
        }
        let title = this.translate.instant('Confirm');
        let message = 'Load ' + this.amountUnitStr;
        let okText = this.translate.instant('OK');
        let cancelText = this.translate.instant('Cancel');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.hideSlideButton = true;
            this.onGoingProcessProvider.set('topup');
            this.publishAndSign(this.wallet, this.createdTx)
                .then(() => {
                this.logLegacyCardTopUpEvent(this.wallet, true);
                this.logLegacyCardPurchaseEvent();
                this.onGoingProcessProvider.clear();
                this.openFinishModal();
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this._resetValues();
                this.showError(this.translate.instant('Could not send transaction'), this.bwcErrorProvider.msg(err));
            });
        });
    }
    paymentTimeControl(expires) {
        const expirationTime = Math.floor(new Date(expires).getTime() / 1000);
        this.paymentExpired = false;
        this.setExpirationTime(expirationTime);
        this.countDown = setInterval(() => {
            this.setExpirationTime(expirationTime);
        }, 1000);
    }
    setExpirationTime(expirationTime) {
        const now = Math.floor(Date.now() / 1000);
        if (now > expirationTime) {
            this.paymentExpired = true;
            this.remainingTimeStr = this.translate.instant('Expired');
            if (this.countDown) {
                clearInterval(this.countDown);
            }
            return;
        }
        const totalSecs = expirationTime - now;
        const m = Math.floor(totalSecs / 60);
        const s = totalSecs % 60;
        this.remainingTimeStr = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
    }
    logLegacyCardSetCheckoutOption(wallet) {
        this.bitPayCardProvider.logEvent('set_checkout_option', {
            checkout_option: wallet.coin,
            checkout_step: 1
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        if (this.countDown) {
            clearInterval(this.countDown);
        }
        // Update Rates
        this.updateRates(wallet.coin);
        this.onGoingProcessProvider.set('retrievingInputs');
        this.calculateAmount(wallet)
            .then(val => {
            let parsedAmount = this.txFormatProvider.parseAmount(wallet.coin, val.amount, val.currency);
            this.initializeTopUp(wallet, parsedAmount);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this._resetValues();
            this.showError(err.title, err.message).then(() => {
                this.showWallets();
            });
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        const params = {
            wallets: this.wallets,
            selectedWalletId: id,
            title: 'From'
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.isOpenSelector = false;
        });
    }
    openFinishModal() {
        const finishComment = this.wallet.credentials.m === 1
            ? this.translate.instant('Funds were added to debit card')
            : this.translate.instant('Transaction initiated');
        let finishText = '';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__bitpay_card__["a" /* BitPayCardPage */], { id: this.cardId }, { animate: false });
        }));
    }
    openExternalLink(urlKey) {
        let url;
        let title;
        switch (urlKey) {
            case 'networkCost':
                url =
                    'https://support.bitpay.com/hc/en-us/articles/115002990803-Why-Am-I-Being-Charged-an-Additional-Network-Cost-on-My-BitPay-Invoice-';
                title = this.translate.instant('Network Cost');
                break;
            case 'minerFee':
                url =
                    'https://support.bitpay.com/hc/en-us/articles/115003393863-What-are-bitcoin-miner-fees-Why-are-miner-fees-so-high-';
                title = this.translate.instant('Miner Fee');
                break;
        }
        let message = this.translate.instant('This information is available at the website.');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, true, title, message, okText, cancelText);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], BitPayCardTopUpPage.prototype, "slideButton", void 0);
BitPayCardTopUpPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-bitpay-card-topup',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/bitpay-card/bitpay-card-topup/bitpay-card-topup.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Add funds\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n    <ion-item>\n      <div class="bitpay-title">\n        <img src="assets/img/bitpay-card/bitpay-card-visa.svg">\n        <span>BitPay Visa&reg; Card ({{lastFourDigits}})</span>\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountUnitStr}}</div>\n        <div class="alternative" *ngIf="wallet">\n          <span *ngIf="rate">\n            @ {{rate | number:\'1.2-2\'}} {{currencyIsoCode}} per {{wallet.coin.toUpperCase()}}\n          </span>\n          <span *ngIf="!rate">...</span>\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item-group class="info">\n      <button class="container-from" ion-item detail-none (click)="showWallets()">\n        <span translate>From</span>\n        <div class="wallet" *ngIf="wallet">\n          <ion-icon *ngIf="wallet && wallet.coin" item-start>\n            <img [ngClass]="{ testnet: wallet.network === \'testnet\' }" src="assets/img/currencies/{{wallet.coin}}.svg" class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n        <div class="wallet" *ngIf="!wallet">\n          <ion-icon item-start>\n            <img class="icon-wallet disabled" src="assets/img/icon-wallet.svg" />\n          </ion-icon>\n          <div translate>Select a wallet</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n\n      <div *ngIf="totalAmountStr">\n        <ion-item-divider>\n          Details\n        </ion-item-divider>\n        <ion-item>\n          <span translate>Expires</span>\n          <ion-note *ngIf="!paymentExpired" item-end><span [innerHTML]="remainingTimeStr"></span></ion-note>\n          <ion-note *ngIf="paymentExpired" [ngStyle]="{\'color\': \'red\'}" item-end>{{\'Expired\' | translate}}</ion-note>\n        </ion-item>\n        <ion-item>\n          <span translate>Funds to be added</span>\n          <ion-note item-end>\n            <span *ngIf="amount">{{amount | number:\'1.2-2\'}} {{currencyIsoCode}}</span>\n            <span *ngIf="!amount">...</span>\n          </ion-note>\n        </ion-item>\n        <ion-item *ngIf="invoiceFee">\n          <span class="item-info">{{\'Network cost\' | translate}}\n            <ion-icon class="item-img" (click)="openExternalLink(\'networkCost\')">\n              <img src="assets/img/settings-icons/icon-help-support.svg" width="22">\n            </ion-icon>\n          </span>\n          <ion-note item-end>\n            <span>{{invoiceFee | number:\'1.2-2\'}} {{currencyIsoCode}}</span>\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span class="item-info">{{\'Miner fee\' | translate}}\n            <ion-icon class="item-img" (click)="openExternalLink(\'minerFee\')">\n              <img src="assets/img/settings-icons/icon-help-support.svg" width="22">\n            </ion-icon>\n          </span>\n          <ion-note item-end>\n            <span>{{networkFee | number:\'1.2-2\'}} {{currencyIsoCode}}</span>\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span translate>Total</span>\n          <ion-note item-end>\n            <span *ngIf="totalAmountStr">{{totalAmountStr}} ~ </span>\n            <span *ngIf="totalAmount">{{totalAmount | number:\'1.2-2\'}} {{currencyIsoCode}}</span>\n          </ion-note>\n        </ion-item>\n      </div>\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!(wallet && totalAmountStr) || paymentExpired" buttonText="{{\'Slide to confirm\' | translate}}" (slideDone)="topUpConfirm()" [ngClass]="{\'slide-confirm-fast slide-confirm-down\': hideSlideButton, \'slide-confirm-slow\': !hideSlideButton}"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="topUpConfirm()" [disabled]="!(wallet && totalAmountStr) ||paymentExpired">\n      {{\'Add funds\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/bitpay-card/bitpay-card-topup/bitpay-card-topup.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_bitpay_bitpay__["a" /* BitPayProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers__["H" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_18__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_22__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_23__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_24__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_20__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_paypro_paypro__["a" /* PayproProvider */]])
], BitPayCardTopUpPage);

//# sourceMappingURL=bitpay-card-topup.js.map

/***/ }),

/***/ 985:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BuyCoinbasePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_coinbase_coinbase__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__finish_finish__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__coinbase__ = __webpack_require__(248);





// providers









// pages


let BuyCoinbasePage = class BuyCoinbasePage {
    constructor(actionSheetProvider, coinbaseProvider, logger, popupProvider, navCtrl, externalLinkProvider, onGoingProcessProvider, navParams, walletProvider, txFormatProvider, profileProvider, modalCtrl, platformProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.coinbaseProvider = coinbaseProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.externalLinkProvider = externalLinkProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.navParams = navParams;
        this.walletProvider = walletProvider;
        this.txFormatProvider = txFormatProvider;
        this.profileProvider = profileProvider;
        this.modalCtrl = modalCtrl;
        this.platformProvider = platformProvider;
        this.isFiat = true;
        this.coin = this.navParams.data.coin; // BTC
        this.amount = this.navParams.data.amount; // USD
        this.currency = this.navParams.data.currency; // USD
        this.network = this.coinbaseProvider.getNetwork();
        this.isCordova = this.platformProvider.isCordova;
        this.hideSlideButton = false;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: BuyCoinbasePage');
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            coin: this.coin
        });
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.wallets)) {
            this.showErrorAndBack('No wallets available');
            return;
        }
        this.onWalletSelect(this.wallets[0]); // Default first wallet
    }
    showErrorAndBack(err) {
        this.hideSlideButton = false;
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err).then(() => {
            this.navCtrl.pop();
        });
    }
    showError(err) {
        this.hideSlideButton = false;
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err);
    }
    processPaymentInfo() {
        this.onGoingProcessProvider.set('connectingCoinbase');
        this.coinbaseProvider.init((err, res) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(err);
                return;
            }
            let accessToken = res.accessToken;
            this.coinbaseProvider.buyPrice(accessToken, this.coinbaseProvider.getAvailableCurrency(), (err, b) => {
                if (err)
                    this.logger.error(err);
                this.buyPrice = b.data || null;
            });
            this.paymentMethods = [];
            this.selectedPaymentMethodId = null;
            this.coinbaseProvider.getPaymentMethods(accessToken, (err, p) => {
                if (err) {
                    this.onGoingProcessProvider.clear();
                    this.showErrorAndBack(err);
                    return;
                }
                let hasPrimary;
                let pm;
                for (let i = 0; i < p.data.length; i++) {
                    pm = p.data[i];
                    // Only USD for US bank accounts (or fiat account in USD)
                    if (pm.currency == 'USD' &&
                        (pm.type == 'fiat_account' || pm.type == 'ach_bank_account')) {
                        if (pm.allow_buy) {
                            this.paymentMethods.push(pm);
                        }
                        if (pm.allow_buy && pm.primary_buy) {
                            hasPrimary = true;
                            this.selectedPaymentMethodId = pm.id;
                        }
                    }
                }
                if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.paymentMethods)) {
                    this.onGoingProcessProvider.clear();
                    let url = 'https://support.coinbase.com/customer/portal/articles/1148716-payment-methods-for-us-customers';
                    let msg = 'No payment method available to buy';
                    let okText = 'More info';
                    let cancelText = 'Go Back';
                    this.popupProvider
                        .ionicConfirm(null, msg, okText, cancelText)
                        .then(res => {
                        if (res)
                            this.externalLinkProvider.open(url);
                        this.navCtrl.pop();
                    });
                    return;
                }
                if (!hasPrimary)
                    this.selectedPaymentMethodId = this.paymentMethods[0].id;
                this.buyRequest();
            });
        });
    }
    buyRequest() {
        this.coinbaseProvider.init((err, res) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(err);
                return;
            }
            let accessToken = res.accessToken;
            let accountId = res.accountId;
            let dataSrc = {
                amount: this.amount,
                currency: this.currency,
                payment_method: this.selectedPaymentMethodId,
                quote: true
            };
            this.coinbaseProvider.buyRequest(accessToken, accountId, dataSrc, (err, data) => {
                this.onGoingProcessProvider.clear();
                if (err) {
                    this.showErrorAndBack(err);
                    return;
                }
                this.buyRequestInfo = data.data;
            });
        });
    }
    buyConfirm() {
        let message = 'Buy bitcoin for ' + this.amountUnitStr;
        let okText = 'Confirm';
        let cancelText = 'Cancel';
        this.popupProvider
            .ionicConfirm(null, message, okText, cancelText)
            .then((ok) => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.hideSlideButton = true;
            this.onGoingProcessProvider.set('buyingBitcoin');
            this.coinbaseProvider.init((err, res) => {
                if (err) {
                    this.onGoingProcessProvider.clear();
                    this.showError(this.coinbaseProvider.getErrorsAsString(err));
                    return;
                }
                let accessToken = res.accessToken;
                let accountId = res.accountId;
                let dataSrc = {
                    amount: this.amount,
                    currency: this.currency,
                    payment_method: this.selectedPaymentMethodId,
                    commit: true
                };
                this.coinbaseProvider.buyRequest(accessToken, accountId, dataSrc, (err, b) => {
                    if (err) {
                        this.onGoingProcessProvider.clear();
                        this.showError(this.coinbaseProvider.getErrorsAsString(err));
                        return;
                    }
                    setTimeout(() => {
                        let tx = b.data ? b.data.transaction : null;
                        if (tx && tx.id) {
                            this.processBuyTx(tx, accessToken, accountId);
                        }
                        else {
                            this._processBuyOrder(b, accessToken, accountId);
                        }
                    }, 10000);
                });
            });
        });
    }
    processBuyTx(tx, accessToken, accountId) {
        if (!tx) {
            this.onGoingProcessProvider.clear();
            this.showError('Transaction not found');
            return;
        }
        this.coinbaseProvider.getTransaction(accessToken, accountId, tx.id, (err, updatedTx) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showError(this.coinbaseProvider.getErrorsAsString(err));
                return;
            }
            this.walletProvider
                .getAddress(this.wallet, false)
                .then((walletAddr) => {
                updatedTx.data['toAddr'] = walletAddr;
                updatedTx.data['status'] = 'pending'; // Forcing "pending" status to process later
                this.logger.debug('Saving transaction to process later...');
                this.coinbaseProvider.savePendingTransaction(updatedTx.data, {}, err => {
                    this.onGoingProcessProvider.clear();
                    if (err)
                        this.logger.warn(err);
                    this.openFinishModal();
                });
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.showError(err);
            });
        });
    }
    _processBuyOrder(b, accessToken, accountId) {
        this.coinbaseProvider.getBuyOrder(accessToken, accountId, b.data.id, (err, buyResp) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showError(this.coinbaseProvider.getErrorsAsString(err));
                return;
            }
            let tx = buyResp.data ? buyResp.data.transaction : null;
            if (tx && tx.id) {
                this.processBuyTx(tx, accessToken, accountId);
            }
            else {
                setTimeout(() => {
                    this._processBuyOrder(b, accessToken, accountId);
                }, 10000);
            }
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        const params = {
            wallets: this.wallets,
            selectedWalletId: id,
            title: 'Receive in'
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.isOpenSelector = false;
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        let parsedAmount = this.txFormatProvider.parseAmount(this.coin, this.amount, this.currency);
        // ** Buy always in BTC **
        // It 's needed for calculate the fee to send
        // purchased bitcoin from Coinbase to Copay in a
        // single transaction
        this.amount = (parsedAmount.amountSat / 100000000).toFixed(8);
        this.currency = 'BTC';
        this.amountUnitStr = parsedAmount.amountUnitStr;
        this.onGoingProcessProvider.set('calculatingFee');
        this.coinbaseProvider.checkEnoughFundsForFee(this.amount, err => {
            this.onGoingProcessProvider.clear();
            if (err) {
                this.showErrorAndBack(err);
                return;
            }
            this.processPaymentInfo();
        });
    }
    openFinishModal() {
        let finishText = 'Bought';
        let finishComment = 'Bitcoin purchase completed. Coinbase has queued the transfer to your selected wallet';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_14__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_15__coinbase__["a" /* CoinbasePage */], { coin: 'btc' }, { animate: false });
        }));
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], BuyCoinbasePage.prototype, "slideButton", void 0);
BuyCoinbasePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-buy-coinbase',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/coinbase/buy-coinbase/buy-coinbase.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Coinbase</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content [ngClass]="{\'no-margin-bottom\': hideSlideButton}" no-bounce>\n  <ion-list *ngIf="buyRequestInfo">\n    <ion-item>\n      <div class="buying-label">\n        <img class="buying-img" src="assets/img/buy-bitcoin.svg">\n        <span>Buying</span>\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountUnitStr}}</div>\n        <div class="alternative" *ngIf="buyPrice">\n          <span ng-show="isFiat">{{buyRequestInfo.amount.amount}} {{buyRequestInfo.amount.currency}}</span> @ ${{buyPrice.amount}} per BTC\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item-group class="info">\n      <ion-item>\n        <ion-label stacked>Payment Method</ion-label>\n        <ion-select [(ngModel)]="selectedPaymentMethodId" (ionChange)="buyRequest()">\n          <ion-option *ngFor="let item of paymentMethods" [value]="item.id">{{item.name}}</ion-option>\n        </ion-select>\n      </ion-item>\n      <button ion-item detail-none (click)="showWallets()" class="wallets-list">\n        <div>Receive in</div>\n        <div class="wallet">\n          <ion-icon *ngIf="wallet && wallet.coin" item-start>\n            <img [ngClass]="{ testnet: network === \'testnet\' }" src="assets/img/currencies/{{wallet.coin}}.svg" class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n      <ion-item-divider>\n        Transaction details\n      </ion-item-divider>\n      <ion-item>\n        <span>Amount</span>\n        <ion-note item-end>\n          {{buyRequestInfo.subtotal.amount}} {{buyRequestInfo.subtotal.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item *ngIf="buyRequestInfo.fee">\n        <span>Fee</span>\n        <ion-note item-end>\n          {{buyRequestInfo.fee.amount}} {{buyRequestInfo.fee.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item *ngFor="let fee of buyRequestInfo.fees">\n        <span class="capitalized">{{fee.type}} fee</span>\n        <ion-note item-end>\n          {{fee.amount.amount}} {{fee.amount.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Total to pay</span>\n        <ion-note item-end>\n          {{buyRequestInfo.total.amount}} {{buyRequestInfo.total.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item-divider></ion-item-divider>\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!wallet || !buyRequestInfo || !selectedPaymentMethodId" buttonText="Slide to confirm" (slideDone)="buyConfirm()" [ngClass]="{\'slide-confirm-fast slide-confirm-down\': hideSlideButton, \'slide-confirm-slow\': !hideSlideButton}"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="buyConfirm()" [disabled]="!wallet || !buyRequestInfo || !selectedPaymentMethodId">Confirm purchase</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/coinbase/buy-coinbase/buy-coinbase.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__["a" /* PlatformProvider */]])
], BuyCoinbasePage);

//# sourceMappingURL=buy-coinbase.js.map

/***/ }),

/***/ 986:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseTxDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_coinbase_coinbase__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_popup_popup__ = __webpack_require__(18);



// providers


let CoinbaseTxDetailsPage = class CoinbaseTxDetailsPage {
    constructor(viewCtrl, coinbaseProvider, popupProvider, navParams) {
        this.viewCtrl = viewCtrl;
        this.coinbaseProvider = coinbaseProvider;
        this.popupProvider = popupProvider;
        this.navParams = navParams;
        this.tx = this.navParams.data.tx;
    }
    remove() {
        this.coinbaseProvider.setCredentials();
        this.updateRequired = false;
        var message = 'Are you sure you want to remove this transaction?';
        this.popupProvider
            .ionicConfirm(null, message, null, null)
            .then((ok) => {
            if (!ok) {
                return;
            }
            this.coinbaseProvider.savePendingTransaction(this.tx, {
                remove: true
            }, () => {
                this.updateRequired = true;
                this.close();
            });
        });
    }
    close() {
        this.viewCtrl.dismiss({ updateRequired: this.updateRequired });
    }
};
CoinbaseTxDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-coinbase-tx-details',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/coinbase/coinbase-tx-details/coinbase-tx-details.html"*/'<ion-header>\n  <ion-toolbar>\n    <ion-title>\n      Details\n    </ion-title>\n    <ion-buttons left>\n      <button (click)="close()" ion-button>\n        Close\n      </button>\n    </ion-buttons>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content>\n\n  <ion-card>\n    <ion-card-content text-center>\n      <div>\n        <img src="assets/img/bought.svg" alt="bought" *ngIf="(tx.type == \'buy\' || (tx.type == \'send\' && tx.to)) && tx.status == \'completed\'">\n        <img src="assets/img/bought-pending.svg" alt="bought" *ngIf="(tx.type == \'buy\' || (tx.type == \'send\' && tx.to)) && tx.status != \'completed\'">\n        <img src="assets/img/sold.svg" alt="sold" *ngIf="tx.type == \'sell\' && tx.status == \'completed\'">\n        <img src="assets/img/sold-pending.svg" alt="sold" *ngIf="(tx.type == \'sell\' || (tx.type == \'send\' && tx.from)) && tx.status != \'completed\'">\n      </div>\n      <div class="title" padding>\n        <div *ngIf="tx.status == \'completed\'">\n          <span *ngIf="tx.type == \'buy\' || tx.type == \'send\'">Bought</span>\n          <span *ngIf="tx.type == \'sell\'">Sold</span>\n        </div>\n        <div *ngIf="tx.type == \'send\' && (tx.to || tx.from) && tx.status != \'completed\'">\n          <span *ngIf="tx.to">Receiving purchased bitcoin</span>\n          <span *ngIf="tx.from">Sending bitcoin to sell</span>\n        </div>\n        <div *ngIf="(tx.type == \'sell\' || tx.type == \'buy\') && tx.status != \'completed\'">\n          <span *ngIf="tx.type == \'buy\'">Buying bitcoin</span>\n          <span *ngIf="tx.type == \'sell\'">Selling bitcoin</span>\n        </div>\n      </div>\n      <div class="price">\n        <span *ngIf="tx.type == \'sell\' || (tx.type == \'send\' && tx.from)">-</span>{{tx.amount.amount.replace(\'-\',\'\')}} {{tx.amount.currency}}\n      </div>\n      <div class="alternative-price">\n        <span *ngIf="tx.type == \'sell\' || (tx.type == \'send\' && tx.from)">-</span>{{tx.native_amount.amount.replace(\'-\',\'\')}} {{tx.native_amount.currency}}\n      </div>\n    </ion-card-content>\n  </ion-card>\n  <ion-list>\n\n    <ion-item *ngFor="let err of tx.error.errors">\n      <ion-label>\n        <span>{{err.message}}</span>\n      </ion-label>\n    </ion-item>\n\n    <ion-item *ngIf="tx.details && tx.status != \'pending\'">\n      <ion-label>\n        <span>{{tx.details.title}}</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.details.subtitle}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      <ion-label>\n        <span>Status</span>\n      </ion-label>\n      <ion-note item-end>\n        <span class="balanced" *ngIf="tx.status == \'completed\'">Completed</span>\n        <span class="dark" *ngIf="tx.status == \'pending\'">Pending</span>\n        <span class="assertive" *ngIf="tx.status == \'error\'">Error</span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.created_at">\n      <ion-label>\n        <span>Date</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.created_at | amCalendar}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.price_sensitivity">\n      <ion-label>\n        <span>Price Sensitivity</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.price_sensitivity.name}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.sell_price_amount">\n      <ion-label>\n        <span>Sell Price</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.sell_price_amount}} {{tx.sell_price_currency}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.description">\n      <ion-label>\n        <span *ngIf="tx.from && tx.type == \'send\'">Sent bitcoin from</span>\n        <span *ngIf="tx.to && tx.type == \'send\'">Receive bitcoin in</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.description}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item-divider *ngIf="tx.status == \'error\'"></ion-item-divider>\n\n    <ion-item *ngIf="tx.status == \'error\'">\n      <ion-label>\n        <span (click)="remove()">Remove transaction</span>\n      </ion-label>\n    </ion-item>\n\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/coinbase/coinbase-tx-details/coinbase-tx-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */]])
], CoinbaseTxDetailsPage);

//# sourceMappingURL=coinbase-tx-details.js.map

/***/ }),

/***/ 987:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SellCoinbasePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__finish_finish__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__coinbase__ = __webpack_require__(248);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_coinbase_coinbase__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_wallet_wallet__ = __webpack_require__(32);





// pages


// providers












let SellCoinbasePage = class SellCoinbasePage {
    constructor(actionSheetProvider, appProvider, bwcErrorProvider, coinbaseProvider, configProvider, logger, popupProvider, navCtrl, navParams, externalLinkProvider, onGoingProcessProvider, walletProvider, txFormatProvider, profileProvider, modalCtrl, platformProvider) {
        this.actionSheetProvider = actionSheetProvider;
        this.appProvider = appProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.coinbaseProvider = coinbaseProvider;
        this.configProvider = configProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.externalLinkProvider = externalLinkProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.walletProvider = walletProvider;
        this.txFormatProvider = txFormatProvider;
        this.profileProvider = profileProvider;
        this.modalCtrl = modalCtrl;
        this.platformProvider = platformProvider;
        this.checkTransaction = __WEBPACK_IMPORTED_MODULE_3_lodash__["throttle"]((count, txp) => {
            this.logger.warn('Check if transaction has been received by Coinbase. Try ' +
                count +
                '/5');
            // TX amount in BTC
            let satToBtc = 1 / 100000000;
            let amountBTC = (txp.amount * satToBtc).toFixed(8);
            this.coinbaseProvider.init((err, res) => {
                if (err) {
                    this.logger.error(err);
                    this.checkTransaction(count, txp);
                    return;
                }
                let accessToken = res.accessToken;
                let accountId = res.accountId;
                let sellPrice = null;
                this.coinbaseProvider.sellPrice(accessToken, this.coinbaseProvider.getAvailableCurrency(), (err, sell) => {
                    if (err) {
                        this.logger.error(this.coinbaseProvider.getErrorsAsString(err));
                        this.checkTransaction(count, txp);
                        return;
                    }
                    sellPrice = sell.data;
                    this.coinbaseProvider.getTransactions(accessToken, accountId, (err, ctxs) => {
                        if (err) {
                            this.logger.error(this.coinbaseProvider.getErrorsAsString(err));
                            this.checkTransaction(count, txp);
                            return;
                        }
                        let coinbaseTransactions = ctxs.data;
                        let txFound = false;
                        let ctx;
                        for (let i = 0; i < coinbaseTransactions.length; i++) {
                            ctx = coinbaseTransactions[i];
                            if (ctx.type == 'send' &&
                                ctx.from &&
                                ctx.amount.amount == amountBTC) {
                                this.logger.debug('Transaction found!', ctx);
                                txFound = true;
                                this.logger.debug('Saving transaction to process later...');
                                ctx.payment_method = this.selectedPaymentMethodId;
                                ctx.status = 'pending'; // Forcing "pending" status to process later
                                ctx.price_sensitivity = this.selectedPriceSensitivity;
                                ctx.sell_price_amount = sellPrice ? sellPrice.amount : '';
                                ctx.sell_price_currency = sellPrice
                                    ? sellPrice.currency
                                    : 'USD';
                                ctx.description =
                                    this.appProvider.info.nameCase +
                                        ' Wallet: ' +
                                        this.wallet.name;
                                this.coinbaseProvider.savePendingTransaction(ctx, null, err => {
                                    this.onGoingProcessProvider.clear();
                                    this.openFinishModal();
                                    if (err)
                                        this.logger.error(this.coinbaseProvider.getErrorsAsString(err));
                                });
                                return;
                            }
                        }
                        if (!txFound) {
                            // Transaction sent, but could not be verified by Coinbase.com
                            this.logger.warn('Transaction not found in Coinbase. Will try 5 times...');
                            if (count < 5) {
                                this.checkTransaction(count + 1, txp);
                            }
                            else {
                                this.onGoingProcessProvider.clear();
                                this.showError('No transaction found');
                                return;
                            }
                        }
                    });
                });
            });
        }, 8000, {
            leading: true
        });
        this.isFiat = true;
        this.coin = this.navParams.data.coin; // BTC
        this.amount = this.navParams.data.amount; // USD
        this.currency = this.navParams.data.currency; // USD
        this.priceSensitivity = this.coinbaseProvider.priceSensitivity;
        this.selectedPriceSensitivity = this.coinbaseProvider.selectedPriceSensitivity;
        this.network = this.coinbaseProvider.getNetwork();
        this.isCordova = this.platformProvider.isCordova;
        this.hideSlideButton = false;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SellCoinbasePage');
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.wallets = this.profileProvider.getWallets({
            m: 1,
            onlyComplete: true,
            network: this.network,
            hasFunds: true,
            coin: this.coin
        });
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.wallets)) {
            this.showErrorAndBack('No wallet available to operate with Coinbase');
            return;
        }
        this.onWalletSelect(this.wallets[0]); // Default first wallet
    }
    showErrorAndBack(err) {
        this.hideSlideButton = false;
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err).then(() => {
            this.navCtrl.pop();
        });
    }
    showError(err) {
        this.hideSlideButton = false;
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err);
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (!wallet.canSign) {
                let err = 'No signing proposal: No private key';
                return reject(err);
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.onGoingProcessProvider.clear();
                return resolve(txp);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                return reject(err);
            });
        });
    }
    processPaymentInfo() {
        this.onGoingProcessProvider.set('connectingCoinbase');
        this.coinbaseProvider.init((err, res) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(this.coinbaseProvider.getErrorsAsString(err));
                return;
            }
            let accessToken = res.accessToken;
            this.coinbaseProvider.sellPrice(accessToken, this.coinbaseProvider.getAvailableCurrency(), (_, s) => {
                this.sellPrice = s.data || null;
            });
            this.paymentMethods = [];
            this.selectedPaymentMethodId = null;
            this.coinbaseProvider.getPaymentMethods(accessToken, (err, p) => {
                if (err) {
                    this.onGoingProcessProvider.clear();
                    this.showErrorAndBack(this.coinbaseProvider.getErrorsAsString(err));
                    return;
                }
                let hasPrimary;
                let pm;
                for (let i = 0; i < p.data.length; i++) {
                    pm = p.data[i];
                    // Only USD for US bank accounts (or fiat account in USD)
                    if (pm.currency == 'USD' &&
                        (pm.type == 'fiat_account' || pm.type == 'ach_bank_account')) {
                        if (pm.allow_sell) {
                            this.paymentMethods.push(pm);
                        }
                        if (pm.allow_sell && pm.primary_sell) {
                            hasPrimary = true;
                            this.selectedPaymentMethodId = pm.id;
                        }
                    }
                }
                if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.paymentMethods)) {
                    this.onGoingProcessProvider.clear();
                    let url = 'https://support.coinbase.com/customer/portal/articles/1148716-payment-methods-for-us-customers';
                    let msg = 'No payment method available to buy';
                    let okText = 'More info';
                    let cancelText = 'Go Back';
                    this.popupProvider
                        .ionicConfirm(null, msg, okText, cancelText)
                        .then(res => {
                        if (res)
                            this.externalLinkProvider.open(url);
                        this.navCtrl.pop();
                    });
                    return;
                }
                if (!hasPrimary)
                    this.selectedPaymentMethodId = this.paymentMethods[0].id;
                this.sellRequest();
            });
        });
    }
    sellRequest() {
        this.coinbaseProvider.init((err, res) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(this.coinbaseProvider.getErrorsAsString(err));
                return;
            }
            let accessToken = res.accessToken;
            let accountId = res.accountId;
            let dataSrc = {
                amount: this.amount,
                currency: this.currency,
                payment_method: this.selectedPaymentMethodId,
                quote: true
            };
            this.coinbaseProvider.sellRequest(accessToken, accountId, dataSrc, (err, data) => {
                this.onGoingProcessProvider.clear();
                if (err) {
                    this.showErrorAndBack(this.coinbaseProvider.getErrorsAsString(err));
                    return;
                }
                this.sellRequestInfo = data.data;
            });
        });
    }
    sellConfirm() {
        let config = this.configProvider.get();
        let configWallet = config.wallet;
        let walletSettings = configWallet.settings;
        let message = 'Selling bitcoin for ' + this.amount + ' ' + this.currency;
        let okText = 'Confirm';
        let cancelText = 'Cancel';
        this.popupProvider
            .ionicConfirm(null, message, okText, cancelText)
            .then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.hideSlideButton = true;
            this.onGoingProcessProvider.set('sellingBitcoin');
            this.coinbaseProvider.init((err, res) => {
                if (err) {
                    this.onGoingProcessProvider.clear();
                    this.showError(this.coinbaseProvider.getErrorsAsString(err));
                    return;
                }
                let accessToken = res.accessToken;
                let accountId = res.accountId;
                let dataSrc = {
                    name: 'Received from ' + this.appProvider.info.nameCase
                };
                this.coinbaseProvider.createAddress(accessToken, accountId, dataSrc, (err, data) => {
                    if (err) {
                        this.onGoingProcessProvider.clear();
                        this.showError(this.coinbaseProvider.getErrorsAsString(err));
                        return;
                    }
                    let outputs = [];
                    let toAddress = data.data.address;
                    let amountSat = parseInt((this.sellRequestInfo.amount.amount * 100000000).toFixed(0), 10);
                    let comment = 'Sell bitcoin (Coinbase)';
                    outputs.push({
                        toAddress,
                        amount: amountSat,
                        message: comment
                    });
                    let txp = {
                        toAddress,
                        amount: amountSat,
                        outputs,
                        message: comment,
                        payProUrl: null,
                        excludeUnconfirmedUtxos: configWallet.spendUnconfirmed
                            ? false
                            : true,
                        feeLevel: walletSettings.feeLevel || 'normal'
                    };
                    this.walletProvider
                        .createTx(this.wallet, txp)
                        .then(ctxp => {
                        this.logger.debug('Transaction created.');
                        this.publishAndSign(this.wallet, ctxp)
                            .then(txSent => {
                            this.logger.debug('Transaction broadcasted. Wait for Coinbase confirmation...');
                            this.checkTransaction(1, txSent);
                        })
                            .catch(err => {
                            this.onGoingProcessProvider.clear();
                            this.showError(this.bwcErrorProvider.msg(err));
                            return;
                        });
                    })
                        .catch(err => {
                        this.onGoingProcessProvider.clear();
                        this.showError(err);
                        return;
                    });
                });
            });
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        const params = {
            wallets: this.wallets,
            selectedWalletId: id,
            title: 'Sell from'
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.isOpenSelector = false;
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        let parsedAmount = this.txFormatProvider.parseAmount(this.coin, this.amount, this.currency);
        this.amount = parsedAmount.amount;
        this.currency = parsedAmount.currency;
        this.amountUnitStr = parsedAmount.amountUnitStr;
        this.processPaymentInfo();
    }
    openFinishModal() {
        let finishText = 'Funds sent to Coinbase Account';
        let finishComment = 'The transaction is not yet confirmed, and will show as "Pending" in your Activity. The bitcoin sale will be completed automatically once it is confirmed by Coinbase';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_5__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__coinbase__["a" /* CoinbasePage */], { coin: 'btc' }, { animate: false });
        }));
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], SellCoinbasePage.prototype, "slideButton", void 0);
SellCoinbasePage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-sell-coinbase',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/coinbase/sell-coinbase/sell-coinbase.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Coinbase</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content [ngClass]="{\'no-margin-bottom\': hideSlideButton}" no-bounce>\n  <ion-list *ngIf="sellRequestInfo">\n    <ion-item>\n      <div class="selling-label">\n        <img class="selling-img" src="assets/img/sell-bitcoin.svg">\n        <span>Selling</span>\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountUnitStr}}</div>\n        <div class="alternative">\n          <span *ngIf="isFiat">{{sellRequestInfo.subtotal.amount}} {{sellRequestInfo.subtotal.currency}}</span> @ ${{sellPrice.amount}} per BTC\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item-group class="info">\n      <button ion-item detail-none (click)="showWallets()" class="wallets-list">\n        <div>From</div>\n        <div class="wallet">\n          <ion-icon *ngIf="wallet && wallet.coin" item-start>\n            <img [ngClass]="{ testnet: network === \'testnet\' }" src="assets/img/currencies/{{wallet.coin}}.svg" class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n\n      <ion-item>\n        <ion-label stacked>Deposit into</ion-label>\n        <ion-select [(ngModel)]="selectedPaymentMethodId" (ionChange)="sellRequest()">\n          <ion-option *ngFor="let item of paymentMethods" [value]="item.id">{{item.name}}</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <ion-item padding-bottom>\n        <ion-label stacked>At what percentage lower price would you accept to sell?</ion-label>\n        <ion-select [(ngModel)]="selectedPriceSensitivity">\n          <ion-option *ngFor="let item of priceSensitivity" [value]="item">{{item.name}}</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <label-tip type="info" header="no-header" *ngIf="selectedPriceSensitivity">\n        <div label-tip-body>\n          Coinbase has not yet implemented an immediate method to sell bitcoin from a wallet. To make this sale, funds will be sent to your Coinbase account, and sold when Coinbase accepts the transaction (usually one hour).\n          <br>\n          <div *ngIf="sellRequestInfo">\n            Estimated sale value:\n            <strong>\n              {{sellRequestInfo.total.amount | currency : \'\' : 2}} {{sellRequestInfo.total.currency}}\n            </strong>\n          </div>\n          <div *ngIf="sellRequestInfo">\n            Still sell if price fall until:\n            <strong>\n              {{(sellRequestInfo.total.amount - (selectedPriceSensitivity.value / 100) * sellRequestInfo.total.amount) | currency : \'\' : 2}} {{sellRequestInfo.total.currency}}\n            </strong>\n          </div>\n        </div>\n      </label-tip>\n\n      <ion-item-divider>\n        Transaction details\n      </ion-item-divider>\n      <ion-item>\n        Amount\n        <ion-note item-end>\n          {{sellRequestInfo.subtotal.amount}} {{sellRequestInfo.subtotal.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item *ngIf="sellRequestInfo.fee">\n        Fee\n        <ion-note item-end>\n          {{sellRequestInfo.fee.amount}} {{sellRequestInfo.fee.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item *ngFor="let fee of sellRequestInfo.fees">\n        <span>\n          {{fee.type}} fee\n        </span>\n        <ion-note item-end>\n          <span *ngIf="fee.amount.amount != \'0.00\'">-</span> {{fee.amount.amount}} {{fee.amount.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        Total to receive\n        <ion-note item-end>\n          {{sellRequestInfo.total.amount}} {{sellRequestInfo.total.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item-divider></ion-item-divider>\n\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!selectedPaymentMethodId || !sellRequestInfo || !wallet" buttonText="Slide to confirm" (slideDone)="sellConfirm()" [ngClass]="{\'slide-confirm-fast slide-confirm-down\': hideSlideButton, \'slide-confirm-slow\': !hideSlideButton}"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="sellConfirm()" [disabled]="!selectedPaymentMethodId || !sellRequestInfo || !wallet">Confirm sale</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/coinbase/sell-coinbase/sell-coinbase.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_15__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_14__providers_platform_platform__["a" /* PlatformProvider */]])
], SellCoinbasePage);

//# sourceMappingURL=sell-coinbase.js.map

/***/ }),

/***/ 988:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChooseFeeLevelPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_fee_fee__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(18);






// Providers



let ChooseFeeLevelPage = class ChooseFeeLevelPage {
    constructor(currencyProvider, viewCtrl, logger, popupProvider, feeProvider, translate) {
        this.currencyProvider = currencyProvider;
        this.viewCtrl = viewCtrl;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.feeProvider = feeProvider;
        this.translate = translate;
        this.FEE_MULTIPLIER = 10;
        this.FEE_MIN = 0;
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        // From parent controller
        this.network = this.viewCtrl.data.network;
        this.coin = this.viewCtrl.data.coin;
        this.feeLevel = this.viewCtrl.data.feeLevel;
        this.setFeeUnits();
        // IF usingCustomFee
        this.customFeePerKB = this.viewCtrl.data.customFeePerKB
            ? this.viewCtrl.data.customFeePerKB
            : null;
        this.feePerSatByte = this.viewCtrl.data.feePerSatByte
            ? this.viewCtrl.data.feePerSatByte
            : null;
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.feeLevel))
            this.showErrorAndClose(null, this.translate.instant('Fee level is not defined'));
        this.selectedFee = this.feeLevel;
        this.feeOpts = Object.keys(this.feeProvider.getFeeOpts());
        this.loadingFee = true;
        this.feeProvider
            .getFeeLevels(this.coin)
            .then(levels => {
            this.loadingFee = false;
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](levels)) {
                this.showErrorAndClose(null, this.translate.instant('Could not get fee levels'));
                return;
            }
            this.feeLevels = levels;
            this.updateFeeRate();
        })
            .catch(err => {
            this.loadingFee = false;
            this.showErrorAndClose(null, err);
            return;
        });
    }
    showErrorAndClose(title, msg) {
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.viewCtrl.dismiss();
        });
    }
    setFeeUnits() {
        const { feeUnit, feeUnitAmount, blockTime } = this.currencyProvider.getFeeUnits(this.coin);
        this.feeUnit = feeUnit;
        this.feeUnitAmount = feeUnitAmount;
        this.blockTime = blockTime;
    }
    updateFeeRate() {
        let value = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.feeLevels.levels[this.network], feeLevel => {
            return feeLevel.level == this.feeLevel;
        });
        // If no custom fee
        if (value) {
            this.customFeePerKB = null;
            this.feePerSatByte = (value.feePerKb / this.feeUnitAmount).toFixed();
            let avgConfirmationTime = value.nbBlocks * this.blockTime;
            this.avgConfirmationTime = avgConfirmationTime;
        }
        else {
            this.avgConfirmationTime = null;
            this.customSatPerByte = this.customFeePerKB
                ? Number(this.customFeePerKB) / this.feeUnitAmount
                : Number(this.feePerSatByte);
            this.customFeePerKB = (+this.feePerSatByte * this.feeUnitAmount).toFixed();
        }
        // Warnings
        this.setFeesRecommended();
        this.checkFees(this.feePerSatByte);
    }
    setFeesRecommended() {
        this.maxFeeRecommended = this.getMaxRecommended();
        this.minFeeRecommended = this.getMinRecommended();
        this.minFeeAllowed = this.FEE_MIN;
        this.maxFeeAllowed = this.maxFeeRecommended * this.FEE_MULTIPLIER;
        this.maxFee =
            this.maxFeeRecommended > this.maxFeeAllowed
                ? this.maxFeeRecommended
                : this.maxFeeAllowed;
        this.minFee =
            this.minFeeRecommended < this.minFeeAllowed
                ? this.minFeeRecommended
                : this.minFeeAllowed;
    }
    getMinRecommended() {
        let value = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.feeLevels.levels[this.network], feeLevel => {
            return feeLevel.level == 'superEconomy';
        });
        return parseInt((value.feePerKb / this.feeUnitAmount).toFixed(), 10);
    }
    getMaxRecommended() {
        let value = __WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.feeLevels.levels[this.network], feeLevel => {
            return feeLevel.level == 'urgent';
        });
        return parseInt((value.feePerKb / this.feeUnitAmount).toFixed(), 10);
    }
    checkFees(feePerSatByte) {
        let fee = Number(feePerSatByte);
        this.showError = fee <= this.minFeeAllowed ? true : false;
        this.showMinWarning =
            fee > this.minFeeAllowed && fee < this.minFeeRecommended ? true : false;
        this.showMaxWarning =
            fee < this.maxFeeAllowed && fee > this.maxFeeRecommended ? true : false;
    }
    ok() {
        this.customFeePerKB = this.customFeePerKB
            ? (this.customSatPerByte * this.feeUnitAmount).toFixed()
            : null;
        this.viewCtrl.dismiss({
            newFeeLevel: this.feeLevel,
            customFeePerKB: this.customFeePerKB
        });
    }
    cancel() {
        this.viewCtrl.dismiss();
    }
    changeSelectedFee(newFeeLevelValue) {
        if (this.feeLevel != newFeeLevelValue) {
            this.logger.debug('New fee level: ' + newFeeLevelValue);
            this.feeLevel = newFeeLevelValue;
            this.updateFeeRate();
        }
    }
};
ChooseFeeLevelPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-choose-fee-level',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/send/choose-fee-level/choose-fee-level.html"*/'<ion-header>\n  <ion-navbar hideBackButton="true">\n    <ion-title>{{\'Fee level\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button class="modal-close-button" (click)="cancel()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="testnet-warning" *ngIf="network!=\'livenet\'">\n    Testnet\n  </div>\n  <ion-list [hidden]="!feeLevel">\n    <ion-item class="fee-level">\n      <ion-label>{{\'Fee level\' | translate}}</ion-label>\n      <ion-select okText="{{okText}}" cancelText="{{cancelText}}" [(ngModel)]="selectedFee" (ionChange)="changeSelectedFee(selectedFee)">\n        <ion-option *ngFor="let fee of feeOpts" [value]="fee">{{ feeProvider.getFeeOpts()[fee] | translate }}</ion-option>\n      </ion-select>\n    </ion-item>\n  </ion-list>\n  <div [hidden]="!feeLevel">\n    <ion-list class="fee-info" *ngIf="!customFeePerKB">\n      <ion-item>\n        <div translate>\n          Average confirmation time\n        </div>\n        <ion-note item-end>\n          <span *ngIf="loadingFee">...</span>\n          <span *ngIf="avgConfirmationTime">\n            {{ avgConfirmationTime | amDuration: \'minute\' }}\n          </span>\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <div translate>\n          Current fee rate for this policy\n        </div>\n        <ion-note item-end>\n          <span *ngIf="loadingFee">...</span>\n          <span *ngIf="feePerSatByte && !loadingFee">\n            {{feePerSatByte}} {{ feeUnit }}\n          </span>\n        </ion-note>\n      </ion-item>\n    </ion-list>\n\n    <ion-list class="fee-custom" *ngIf="customFeePerKB">\n      <ion-item>\n        <ion-label color="primary" floating>{{\'Enter custom fee in {feeUnit}\' | translate: { feeUnit: feeUnit } }}</ion-label>\n        <ion-input type="number" min="minFee" max="maxFee" (ionChange)="checkFees(customSatPerByte)" [(ngModel)]="customSatPerByte" required></ion-input>\n      </ion-item>\n      <ion-item class="fee-error" *ngIf="showError">\n        <span translate>Transactions without fee are not supported.</span>\n      </ion-item>\n\n      <ion-item class="fee-error" *ngIf="showMinWarning || showMaxWarning" text-wrap>\n        <span *ngIf="showMinWarning" translate>Your fee is lower than recommended.</span>\n        <span *ngIf="showMaxWarning" translate>You should not set a fee higher than {{maxFeeRecommended}} {{feeUnit}}.</span>\n      </ion-item>\n    </ion-list>\n\n    <button [disabled]="customSatPerByte >= maxFeeAllowed || showError" (click)="ok()" class="button-standard" ion-button>\n      {{\'Apply changes\' | translate}}\n    </button>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/send/choose-fee-level/choose-fee-level.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], ChooseFeeLevelPage);

//# sourceMappingURL=choose-fee-level.js.map

/***/ }),

/***/ 989:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PrintableCardComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__pipes_format_currency__ = __webpack_require__(990);



let PrintableCardComponent = class PrintableCardComponent {
    constructor(formatCurrencyPipe) {
        this.formatCurrencyPipe = formatCurrencyPipe;
    }
    ngAfterViewInit() {
        this.initializeCanvas();
        this.writeText();
    }
    getPrintableImage() {
        this.drawCardImage();
        return this.ctx.canvas.toDataURL();
    }
    initializeCanvas() {
        this.ctx = this.canvas.nativeElement.getContext('2d');
        this.ctx.textAlign = 'center';
    }
    writeText() {
        const ctx = this.ctx;
        const x = this.ctx.canvas.width / 2;
        // Amount
        ctx.font = '30px Roboto';
        ctx.fillStyle = 'black';
        const amount = this.formatCurrencyPipe.transform(this.card.amount, this.card.currency);
        ctx.fillText(amount + '', x, yPos(0));
        const BARCODE_HEIGHT = 45;
        const barcodeHeight = this.card.barcodeImage ? BARCODE_HEIGHT : 0;
        // Labels
        ctx.font = '12px Roboto';
        ctx.fillStyle = 'gray';
        ctx.fillText('Claim Code', x, yPos(200));
        this.card.pin &&
            ctx.fillText('Pin', x, yPos(320 - BARCODE_HEIGHT + barcodeHeight));
        // Card Number & Pin
        ctx.font = '14px Roboto';
        ctx.fillStyle = 'black';
        ctx.fillText(this.card.claimCode, x, yPos(278 - BARCODE_HEIGHT + barcodeHeight));
        this.card.pin &&
            ctx.fillText(this.card.pin, x, yPos(348 - BARCODE_HEIGHT + barcodeHeight));
        // Terms
        const maxWidth = 320;
        const lineHeight = 11;
        const x2 = this.ctx.canvas.width / 2;
        const y = 400;
        ctx.font = '8px Roboto';
        ctx.fillStyle = '#a6a6a6';
        wrapText(ctx, this.cardConfig.terms, x2, yPos(y - BARCODE_HEIGHT + barcodeHeight), maxWidth, lineHeight);
    }
    drawBarcode() {
        const img = this.barcode.nativeElement;
        const ctx = this.ctx;
        const scale = 1;
        const image = img;
        var x1 = (ctx.canvas.width - image.width * scale) / 2;
        ctx.drawImage(image, x1, yPos(210), image.width * scale, image.height * scale);
    }
    drawCardImage() {
        const ctx = this.ctx;
        const image = this.cardImage.nativeElement;
        const scale = 0.55;
        const x = (ctx.canvas.width - image.width * scale) / 2;
        ctx.drawImage(image, x, yPos(35), image.width * scale, image.height * scale);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], PrintableCardComponent.prototype, "cardConfig", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"])(),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], PrintableCardComponent.prototype, "card", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('canvas'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"])
], PrintableCardComponent.prototype, "canvas", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('barcode'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"])
], PrintableCardComponent.prototype, "barcode", void 0);
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('cardImage'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"])
], PrintableCardComponent.prototype, "cardImage", void 0);
PrintableCardComponent = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'printable-card',
        template: `
    <canvas #canvas width="595" height="842"></canvas>
    <img
      #barcode
      *ngIf="card.barcodeImage"
      [src]="card.barcodeImage"
      (load)="drawBarcode()"
    />
    <img
      #cardImage
      crossorigin="Anonymous"
      [src]="cardConfig.cardImage"
      (load)="drawCardImage()"
    />
  `
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__pipes_format_currency__["a" /* FormatCurrencyPipe */]])
], PrintableCardComponent);

function yPos(y) {
    const topPadding = 150;
    return topPadding + y;
}
function wrapText(context, text, x, y, maxWidth, lineHeight) {
    var words = text.split(' ');
    var line = '';
    for (var n = 0; n < words.length; n++) {
        var testLine = line + words[n] + ' ';
        var metrics = context.measureText(testLine);
        var testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
            context.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        }
        else {
            line = testLine;
        }
    }
    context.fillText(line, x, y);
}
//# sourceMappingURL=printable-card.js.map

/***/ }),

/***/ 990:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FormatCurrencyPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);



let FormatCurrencyPipe = class FormatCurrencyPipe {
    constructor(decimalPipe) {
        this.decimalPipe = decimalPipe;
    }
    transform(amount, currencyCode, customPrecision) {
        const precision = customPrecision === 'minimal'
            ? getMinimalPrecision(amount, currencyCode)
            : typeof customPrecision === 'number'
                ? customPrecision
                : getPrecision(currencyCode);
        const numericValue = this.decimalPipe.transform(amount, getPrecisionString(precision));
        const symbolMap = {
            BRL: 'R$',
            EUR: '',
            GBP: '',
            INR: '',
            JPY: '',
            PHP: '',
            USD: '$'
        };
        const symbol = symbolMap[currencyCode.toUpperCase()];
        const finalValue = symbol
            ? `${symbol}${numericValue}`
            : `${numericValue} ${currencyCode}`;
        return finalValue;
    }
};
FormatCurrencyPipe = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["Pipe"])({
        name: 'formatCurrency'
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common__["d" /* DecimalPipe */]])
], FormatCurrencyPipe);

function getPrecision(currencyCode) {
    return currencyCode.toUpperCase() === 'JPY' ? 0 : 2;
}
function getMinimalPrecision(amount, currencyCode) {
    return Number.isInteger(amount) ? 0 : getPrecision(currencyCode);
}
function getPrecisionString(precision) {
    return `1.${precision}-${precision}`;
}
//# sourceMappingURL=format-currency.js.map

/***/ }),

/***/ 991:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftConfirmPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__finish_finish__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__shapeshift__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_fee_fee__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_on_going_process_on_going_process__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_replace_parameters_replace_parameters__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_shapeshift_shapeshift__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_wallet_wallet__ = __webpack_require__(32);







// Pages


// Providers














let ShapeshiftConfirmPage = class ShapeshiftConfirmPage {
    constructor(bwcProvider, bwcErrorProvider, configProvider, currencyProvider, replaceParametersProvider, externalLinkProvider, onGoingProcessProvider, logger, navCtrl, navParams, platformProvider, popupProvider, profileProvider, shapeshiftProvider, txFormatProvider, walletProvider, modalCtrl, translate, feeProvider) {
        this.bwcProvider = bwcProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.shapeshiftProvider = shapeshiftProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.modalCtrl = modalCtrl;
        this.translate = translate;
        this.feeProvider = feeProvider;
        this.configWallet = this.configProvider.get().wallet;
        this.currencyIsoCode = 'USD'; // Only USD
        this.isCordova = this.platformProvider.isCordova;
        this.bitcore = this.bwcProvider.getBitcore();
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.useSendMax = this.navParams.data.useSendMax ? true : false;
        this.fromWalletId = this.navParams.data.id;
        this.toWalletId = this.navParams.data.toWalletId;
        this.network = this.shapeshiftProvider.getNetwork();
        this.fromWallet = this.profileProvider.getWallet(this.fromWalletId);
        this.toWallet = this.profileProvider.getWallet(this.toWalletId);
        this.unitToSatoshi = this.currencyProvider.getPrecision(this.fromWallet.coin).unitToSatoshi;
    }
    ionViewDidEnter() {
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.fromWallet) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.toWallet)) {
            this.showErrorAndBack(null, this.translate.instant('No wallet found'));
            return;
        }
        this.shapeshiftProvider.getMarketInfo(this.getCoinPair(), (error, lim) => {
            if (error)
                return this.showErrorAndBack(null, error);
            this.rate = Number(lim.rate);
            /*
             * Coin Pair
             *
             * BTC -> BCH
             *   min (BTC)
             *   max (BTC)
             *   rate (BCH) per 1 BTC
             *   fee (BCH)
             *
             * BCH -> BTC
             *   min (BCH)
             *   max (BCH)
             *   rate (BTC) per 1 BCH
             *   fee (BTC)
             */
            const depositMin = Number(lim.minimum);
            const depositMax = Number(lim.maxLimit);
            this.withdrawalFee = Number(lim.minerFee);
            if (this.useSendMax) {
                this.onGoingProcessProvider.set('calculatingSendMax');
                this.setMaxInfo(depositMax, depositMin)
                    .then(amountSat => {
                    this.onGoingProcessProvider.clear();
                    this.depositAmount = Number((amountSat / this.unitToSatoshi).toFixed(8));
                    this.createShift();
                })
                    .catch(err => {
                    this.onGoingProcessProvider.clear();
                    this.logger.error(err);
                    this.showErrorAndBack(null, err);
                });
            }
            else {
                this.depositAmount = Number(this.navParams.data.amount);
                if (!this.isValid(this.depositAmount, depositMin, depositMax))
                    return;
                // Calculate fee for withdraw (convert depositAmount to same unit as withdrawalFee)
                const withdrawalAmount = Number((this.depositAmount * this.rate).toFixed(8));
                if (!this.hasEnoughFundsForWithdraw(withdrawalAmount, this.withdrawalFee))
                    return;
                this.createShift();
            }
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ShapeshiftConfirmPage');
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.navCtrl.swipeBackEnabled = false;
    }
    isValid(amount, min, max) {
        if (amount > max) {
            let message = this.replaceParametersProvider.replace(this.translate.instant('Maximum amount allowed is {{max}}'), { max });
            this.showErrorAndBack(null, message);
            return false;
        }
        else if (amount < min) {
            let message = this.replaceParametersProvider.replace(this.translate.instant('Minimum amount required is {{min}}'), { min });
            this.showErrorAndBack(null, message);
            return false;
        }
        return true;
    }
    hasEnoughFundsForWithdraw(amount, fee) {
        if (amount <= fee) {
            let message = this.replaceParametersProvider.replace(this.translate.instant('Not enough funds for fee {{shiftFee}}'), { fee });
            this.showErrorAndBack(null, message);
            return false;
        }
        return true;
    }
    setMaxInfo(max, min) {
        return new Promise((resolve, reject) => {
            this.getSendMaxInfo()
                .then(sendMaxInfo => {
                if (sendMaxInfo) {
                    this.logger.debug('Send max info', sendMaxInfo);
                    if (sendMaxInfo.amount == 0) {
                        let msg = this.translate.instant('Not enough funds for fee');
                        return reject(msg);
                    }
                    this.sendMaxInfo = sendMaxInfo;
                    let maxSat = parseInt((max * this.unitToSatoshi).toFixed(0), 10);
                    let minSat = parseInt((min * this.unitToSatoshi).toFixed(0), 10);
                    if (sendMaxInfo.amount > maxSat) {
                        this.popupProvider
                            .ionicAlert(this.translate.instant('ShapeShift max limit reached'), 'Maximum amount allowed is ' + max)
                            .then(() => {
                            this.useSendMax = false;
                            return resolve(maxSat);
                        });
                    }
                    else if (sendMaxInfo.amount < minSat) {
                        let err = this.replaceParametersProvider.replace(this.translate.instant('ShapeShift requires a minimum value of {{min}}'), { min });
                        return reject(err);
                    }
                    else {
                        this.showSendMaxWarning().then(() => {
                            return resolve(sendMaxInfo.amount);
                        });
                    }
                }
            })
                .catch(err => {
                this.logger.error('ShapeShift: could not get SendMax info', err);
                let msg = this.translate.instant('Error getting SendMax information');
                return reject(msg);
            });
        });
    }
    getSendMaxInfo() {
        return new Promise((resolve, reject) => {
            this.feeProvider
                .getFeeRate(this.fromWallet.coin, this.network, this.configWallet.settings.feeLevel || 'normal')
                .then(feeRate => {
                this.onGoingProcessProvider.set('retrievingInputs');
                this.walletProvider
                    .getSendMaxInfo(this.fromWallet, {
                    feePerKb: feeRate,
                    excludeUnconfirmedUtxos: !this.configWallet.spendUnconfirmed,
                    returnInputs: true
                })
                    .then(res => {
                    this.onGoingProcessProvider.clear();
                    return resolve(res);
                })
                    .catch(err => {
                    this.onGoingProcessProvider.clear();
                    return reject(err);
                });
            });
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    showErrorAndBack(title, msg) {
        this.hideSlideButton = false;
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.errors ? msg.errors[0].message : msg;
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.navCtrl.pop();
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (!wallet.canSign) {
                let err = this.translate.instant('No signing proposal: No private key');
                return reject(err);
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.onGoingProcessProvider.clear();
                return resolve(txp);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                return reject(err);
            });
        });
    }
    satToFiat(coin, sat, isoCode) {
        return new Promise(resolve => {
            this.txFormatProvider.toFiat(coin, sat, isoCode).then(value => {
                return resolve(value);
            });
        });
    }
    setFiatTotalAmount(amountSat, feeSat, withdrawalSat) {
        this.satToFiat(this.toWallet.coin, withdrawalSat, this.currencyIsoCode).then(w => {
            this.fiatWithdrawal = Number(w);
            this.satToFiat(this.fromWallet.coin, amountSat, this.currencyIsoCode).then(a => {
                this.fiatAmount = Number(a);
                this.satToFiat(this.fromWallet.coin, feeSat, this.currencyIsoCode).then(i => {
                    this.fiatFee = Number(i);
                    this.fiatTotalAmount = this.fiatAmount + this.fiatFee;
                });
            });
        });
    }
    saveShapeshiftData() {
        let address = this.shapeInfo.deposit;
        let withdrawal = this.shapeInfo.withdrawal;
        let now = __WEBPACK_IMPORTED_MODULE_5_moment__().unix() * 1000;
        this.shapeshiftProvider.getStatus(address, this.accessToken, (_, st) => {
            let newData = {
                address,
                withdrawal,
                date: now,
                amount: this.amountStr,
                rate: this.rate +
                    ' ' +
                    this.toWallet.coin.toUpperCase() +
                    ' per ' +
                    this.fromWallet.coin.toUpperCase(),
                title: this.fromWallet.coin.toUpperCase() +
                    ' to ' +
                    this.toWallet.coin.toUpperCase(),
                // From ShapeShift
                status: st.status,
                transaction: st.transaction || null,
                incomingCoin: st.incomingCoin || null,
                incomingType: st.incomingType || null,
                outgoingCoin: st.outgoingCoin || null,
                outgoingType: st.outgoingType || null // Coin type of withdrawal
            };
            this.shapeshiftProvider.saveShapeshift(newData, null, () => {
                this.logger.debug('Saved shift with status: ' + newData.status);
                this.openFinishModal();
            });
        });
    }
    createTx(wallet, toAddress, depositSat) {
        return new Promise((resolve, reject) => {
            this.message =
                this.fromWallet.coin.toUpperCase() +
                    ' to ' +
                    this.toWallet.coin.toUpperCase();
            let outputs = [];
            outputs.push({
                toAddress,
                amount: depositSat,
                message: this.message
            });
            let txp = {
                toAddress,
                amount: depositSat,
                outputs,
                message: this.message,
                excludeUnconfirmedUtxos: this.configWallet.spendUnconfirmed
                    ? false
                    : true,
                customData: {
                    shapeShift: toAddress,
                    service: 'shapeshift'
                }
            };
            if (this.sendMaxInfo) {
                txp.inputs = this.sendMaxInfo.inputs;
                txp.fee = this.sendMaxInfo.fee;
            }
            else {
                txp.feeLevel = this.configWallet.settings.feeLevel || 'normal';
            }
            this.walletProvider
                .createTx(wallet, txp)
                .then(ctxp => {
                return resolve(ctxp);
            })
                .catch(err => {
                this.hideSlideButton = false;
                return reject({
                    title: this.translate.instant('Could not create transaction'),
                    message: this.bwcErrorProvider.msg(err)
                });
            });
        });
    }
    showSendMaxWarning() {
        return new Promise(resolve => {
            let fee = this.sendMaxInfo.fee / this.unitToSatoshi;
            let msg = this.replaceParametersProvider.replace(this.translate.instant('{{fee}} {{coin}} will be deducted for bitcoin networking fees.'), { fee, coin: this.fromWallet.coin.toUpperCase() });
            let warningMsg = this.verifyExcludedUtxos();
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](warningMsg))
                msg += '\n' + warningMsg;
            this.popupProvider.ionicAlert(null, msg).then(() => {
                resolve();
            });
        });
    }
    verifyExcludedUtxos() {
        let warningMsg = [];
        if (this.sendMaxInfo.utxosBelowFee > 0) {
            let amountBelowFeeStr = this.sendMaxInfo.amountBelowFee / this.unitToSatoshi;
            let message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{fee}} {{coin}} were excluded. These funds come from UTXOs smaller than the network fee provided.'), { fee: amountBelowFeeStr, coin: this.fromWallet.coin.toUpperCase() });
            warningMsg.push(message);
        }
        if (this.sendMaxInfo.utxosAboveMaxSize > 0) {
            let amountAboveMaxSizeStr = this.sendMaxInfo.amountAboveMaxSize / this.unitToSatoshi;
            let message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{fee}} {{coin}} were excluded. The maximum size allowed for a transaction was exceeded.'), { fee: amountAboveMaxSizeStr, coin: this.fromWallet.coin.toUpperCase() });
            warningMsg.push(message);
        }
        return warningMsg.join('\n');
    }
    getLegacyAddressFormat(addr, coin) {
        if (coin == 'btc')
            return addr;
        let a = this.bitcoreCash.Address(addr).toObject();
        return this.bitcore.Address.fromObject(a).toString();
    }
    getNewAddressFormat(addr, coin) {
        if (coin == 'btc')
            return addr;
        let a = this.bitcore.Address(addr).toObject();
        return this.bitcoreCash.Address.fromObject(a).toString(true);
    }
    getCoinPair() {
        return this.fromWallet.coin + '_' + this.toWallet.coin;
    }
    createShift() {
        this.onGoingProcessProvider.set('connectingShapeshift');
        this.shapeshiftProvider.init((err, res) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(null, err.error.error_description);
                return;
            }
            this.accessToken = res.accessToken;
            this.walletProvider
                .getAddress(this.toWallet, false)
                .then((withdrawalAddress) => {
                withdrawalAddress = this.getLegacyAddressFormat(withdrawalAddress, this.toWallet.coin);
                this.walletProvider
                    .getAddress(this.fromWallet, false)
                    .then((returnAddress) => {
                    returnAddress = this.getLegacyAddressFormat(returnAddress, this.fromWallet.coin);
                    let data = {
                        withdrawal: withdrawalAddress,
                        pair: this.getCoinPair(),
                        returnAddress,
                        token: this.accessToken,
                        depositAmount: this.depositAmount
                    };
                    this.shapeshiftProvider.sendamount(data, (err, shapeData) => {
                        if (err || shapeData.error) {
                            this.onGoingProcessProvider.clear();
                            this.showErrorAndBack(null, err || shapeData.error);
                            return;
                        }
                        this.paymentTimeControl(shapeData.expiration);
                        let toAddress = this.getNewAddressFormat(shapeData.deposit, this.fromWallet.coin);
                        // To Sat
                        const depositSat = Number((this.depositAmount * this.unitToSatoshi).toFixed(0));
                        const withdrawalAmountSat = Number((shapeData.withdrawalAmount * this.unitToSatoshi).toFixed(0));
                        this.createTx(this.fromWallet, toAddress, depositSat)
                            .then(ctxp => {
                            this.onGoingProcessProvider.clear();
                            // Save in memory
                            this.createdTx = ctxp;
                            this.shapeInfo = shapeData;
                            // Fee rate
                            let per = (ctxp.fee / (ctxp.amount + ctxp.fee)) * 100;
                            this.feeRatePerStr = per.toFixed(2) + '%';
                            // Amount + Unit
                            this.amountStr = this.txFormatProvider.formatAmountStr(this.fromWallet.coin, ctxp.amount);
                            this.withdrawalStr = this.txFormatProvider.formatAmountStr(this.toWallet.coin, withdrawalAmountSat);
                            this.feeStr = this.txFormatProvider.formatAmountStr(this.fromWallet.coin, ctxp.fee);
                            this.totalAmountStr = this.txFormatProvider.formatAmountStr(this.fromWallet.coin, ctxp.amount + ctxp.fee);
                            // Convert to fiat
                            this.setFiatTotalAmount(ctxp.amount, ctxp.fee, withdrawalAmountSat);
                        })
                            .catch(err => {
                            this.onGoingProcessProvider.clear();
                            this.showErrorAndBack(err.title, err.message);
                            return;
                        });
                    });
                })
                    .catch(() => {
                    this.onGoingProcessProvider.clear();
                    this.showErrorAndBack(null, 'Could not get address');
                    return;
                });
            })
                .catch(() => {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(null, 'Could not get address');
                return;
            });
        });
    }
    confirmTx() {
        if (!this.createdTx) {
            this.showErrorAndBack(null, this.translate.instant('Transaction has not been created'));
            return;
        }
        this.hideSlideButton = true;
        let fromCoin = this.fromWallet.coin.toUpperCase();
        let toCoin = this.toWallet.coin.toUpperCase();
        let title = this.replaceParametersProvider.replace(this.translate.instant('Confirm to shift {{fromCoin}} to {{toCoin}}'), { fromCoin, toCoin });
        let okText = this.translate.instant('OK');
        let cancelText = this.translate.instant('Cancel');
        this.popupProvider.ionicConfirm(title, '', okText, cancelText).then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                this.hideSlideButton = false;
                return;
            }
            this.publishAndSign(this.fromWallet, this.createdTx)
                .then(txSent => {
                this.txSent = txSent;
                this.saveShapeshiftData();
            })
                .catch(err => {
                this.logger.error(this.bwcErrorProvider.msg(err));
                this.showErrorAndBack(null, this.translate.instant('Could not send transaction'));
                return;
            });
        });
    }
    openFinishModal() {
        let finishText = 'Transaction Sent';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_7__finish_finish__["a" /* FinishModalPage */], { finishText }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__shapeshift__["a" /* ShapeshiftPage */], null, { animate: false });
        }));
    }
    cancel() {
        this.navCtrl.popToRoot({ animate: false });
    }
    paymentTimeControl(expires) {
        const expirationTime = Math.floor(new Date(expires).getTime());
        this.paymentExpired = false;
        this.setExpirationTime(expirationTime);
        const countDown = setInterval(() => {
            this.setExpirationTime(expirationTime, countDown);
        }, 1000);
    }
    setExpirationTime(expirationTime, countDown) {
        const now = Math.floor(Date.now() / 1000);
        if (now > expirationTime) {
            this.paymentExpired = true;
            this.remainingTimeStr = this.translate.instant('Expired');
            if (countDown) {
                /* later */
                clearInterval(countDown);
            }
            return;
        }
        const totalSecs = expirationTime - now;
        const m = Math.floor(totalSecs / 60);
        const s = totalSecs % 60;
        this.remainingTimeStr = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
    }
};
__WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["ViewChild"])('slideButton'),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:type", Object)
], ShapeshiftConfirmPage.prototype, "slideButton", void 0);
ShapeshiftConfirmPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-shapeshift-confirm',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/shapeshift/shapeshift-confirm/shapeshift-confirm.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Confirm\'|translate}}</ion-title>\n    <ion-buttons right>\n      <button (click)="cancel()" ion-button>\n        Cancel\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-list>\n    <ion-item class="header-label">\n      <div class="sending-label">\n        {{fromWallet.coin | uppercase}} to {{toWallet.coin | uppercase}}\n      </div>\n      <div class="amount-label">\n        <img class="icon-service" src="assets/img/shapeshift/icon-shapeshift.svg" alt="shapeshift" width="40">\n        <div class="amount">\n          {{amountStr ? amountStr : \'...\'}}\n        </div>\n        <div class="alternative" *ngIf="fiatAmount">{{fiatAmount | number:\'1.2-2\'}} {{currencyIsoCode}}</div>\n        <div class="alternative" *ngIf="!fiatAmount">...</div>\n      </div>\n    </ion-item>\n\n    <div class="info">\n      <div class="title">\n        <span translate>From</span>\n      </div>\n      <ion-item class="wallet-selector">\n        <img *ngIf="fromWallet && fromWallet.coin" src="assets/img/currencies/{{fromWallet.coin}}.svg" class="icon-wallet">\n        <div class="wallet-balance">\n          <span>\n            {{fromWallet ? fromWallet.name : \'...\'}}\n          </span>\n        </div>\n      </ion-item>\n\n      <div class="title">\n        <span translate>To</span>\n      </div>\n      <ion-item class="wallet-selector">\n        <img *ngIf="toWallet && toWallet.coin" src="assets/img/currencies/{{toWallet.coin}}.svg" class="icon-wallet">\n        <div class="wallet-balance">\n          <span>\n            {{toWallet ? toWallet.name : \'...\'}}\n          </span>\n        </div>\n      </ion-item>\n    </div>\n\n    <div padding></div>\n\n    <ion-item *ngIf="fiatTotalAmount">\n      <span translate>Expires</span>:\n      <ion-note *ngIf="!paymentExpired" item-end>{{remainingTimeStr}}</ion-note>\n      <ion-note *ngIf="paymentExpired" [ngStyle]="{\'color\': \'red\'}" item-end>{{\'Expired\' | translate}}</ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="feeRatePerStr">\n      {{\'Fee\'|translate}}\n      <ion-note item-end>\n        <span>\n          {{feeStr}} (\n          <span *ngIf="fiatFee && fiatFee > 0">{{fiatFee | number:\'1.2-2\'}} {{currencyIsoCode}}, </span>{{feeRatePerStr}} )\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="fiatTotalAmount">\n      {{\'Total\'|translate}}\n      <ion-note item-end>\n        <span>\n          {{totalAmountStr}} ( {{fiatTotalAmount | number:\'1.2-2\'}} {{currencyIsoCode}} )\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item-divider class="item-description" *ngIf="withdrawalStr" no-lines>\n      <span translate>\n        A total of {{amountStr}} ({{fiatAmount | number:\'1.2-2\'}} {{currencyIsoCode}}) will be exchanged for {{withdrawalStr}} ({{fiatWithdrawal | number:\'1.2-2\'}} {{currencyIsoCode}}). ShapeShift fee: {{withdrawalFee}} {{toWallet.coin | uppercase}}\n      </span>\n    </ion-item-divider>\n  </ion-list>\n\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!fromWallet || !totalAmountStr || !toWallet" buttonText="{{\'Slide to confirm\' | translate}}" (slideDone)="confirmTx()" [ngClass]="{\'slide-confirm-fast slide-confirm-down\': hideSlideButton, \'slide-confirm-slow\': !hideSlideButton}"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="confirmTx()" [disabled]="!fromWallet || !totalAmountStr || !toWallet || paymentExpired">\n      {{\'Click to confirm\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/shapeshift/shapeshift-confirm/shapeshift-confirm.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_22__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_14__providers_fee_fee__["a" /* FeeProvider */]])
], ShapeshiftConfirmPage);

//# sourceMappingURL=shapeshift-confirm.js.map

/***/ }),

/***/ 992:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_shapeshift_shapeshift__ = __webpack_require__(174);




// Providers




let ShapeshiftDetailsPage = class ShapeshiftDetailsPage {
    constructor(configProvider, currencyProvider, externalLinkProvider, navParams, shapeshiftProvider, viewCtrl, logger) {
        this.configProvider = configProvider;
        this.currencyProvider = currencyProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.navParams = navParams;
        this.shapeshiftProvider = shapeshiftProvider;
        this.viewCtrl = viewCtrl;
        this.logger = logger;
        this.defaults = this.configProvider.getDefaults();
        this.ssData = this.navParams.data.ssData;
        const amountData = this.ssData.amount.split(' ');
        this.amount = amountData[0];
        this.amountUnit = amountData[1];
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ShapeshiftDetailsPage');
    }
    remove() {
        this.shapeshiftProvider.saveShapeshift(this.ssData, {
            remove: true
        }, () => {
            this.close();
        });
    }
    close() {
        this.viewCtrl.dismiss();
    }
    openTransaction(id) {
        var url;
        const chains = this.currencyProvider.getAvailableChains();
        for (const chain of chains) {
            if (this.ssData.outgoingType == chain) {
                url =
                    'https://' +
                        this.defaults.blockExplorerUrl[chain] +
                        'mainnet/tx/' +
                        id;
            }
        }
        if (url) {
            this.externalLinkProvider.open(url);
        }
        else {
            return;
        }
    }
};
ShapeshiftDetailsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-shapeshift-details',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/shapeshift/shapeshift-details/shapeshift-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>\n      {{\'Details\' | translate}}\n    </ion-title>\n    <ion-buttons left>\n      <button class="modal-close-button" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="header-modal">\n    <div class="title-modal">\n      {{ssData.title}}\n    </div>\n\n    <div class="subtitle-modal">\n      <img class="icon-service" src="assets/img/shapeshift/icon-shapeshift.svg" alt="ShapeShift" width="40">\n      {{amount}}\n      <span class="amount-unit">{{amountUnit}}</span>\n    </div>\n  </div>\n\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <ion-item>\n      {{\'Status\' | translate}}\n      <ion-note item-end>\n        <span class="assertive" *ngIf="ssData.status == \'failed\'" translate>Failed</span>\n        <span class="balanced" *ngIf="ssData.status == \'complete\'" translate>Completed</span>\n        <span class="dark" *ngIf="ssData.status == \'received\'" translate>Pending</span>\n        <span class="text-gray" *ngIf="ssData.status == \'no_deposits\'" translate>Pending</span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Rate\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!ssData.rate">...</span>\n        <span *ngIf="ssData.rate">\n          {{ ssData.rate }}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Created\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!ssData.date">...</span>\n        <span *ngIf="ssData.date">\n          {{ ssData.date | amDateFormat:\'MMM D, YYYY\'}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item-divider>{{\'Deposit\' | translate}}</ion-item-divider>\n\n    <ion-item>\n      {{\'Address\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!ssData.address">...</span>\n          <span *ngIf="ssData.address" copy-to-clipboard="{{ssData.address}}">\n            {{ ssData.address }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="ssData.incomingCoin">\n      {{\'Amount\' | translate}}\n      <ion-note item-end>\n        {{ssData.incomingCoin}} {{ssData.incomingType}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item-divider>{{\'Withdraw\' | translate}}</ion-item-divider>\n\n    <ion-item>\n      {{\'Address\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!ssData.withdrawal">...</span>\n          <span *ngIf="ssData.withdrawal" copy-to-clipboard="{{ssData.withdrawal}}">\n            {{ ssData.withdrawal }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="ssData.outgoingCoin">\n      {{\'Amount\' | translate}}\n      <ion-note item-end>\n        {{ssData.outgoingCoin}} {{ssData.outgoingType}}\n      </ion-note>\n    </ion-item>\n\n    <div text-center padding-top *ngIf="ssData.transaction">\n      <button ion-button clear (click)="openTransaction(ssData.transaction)">\n        {{\'See transaction\' | translate}}\n      </button>\n    </div>\n    <ion-item-divider></ion-item-divider>\n    <button class="assertive" ion-item detail-none text-center (click)="remove()">\n      {{\'Remove\' | translate}}\n    </button>\n\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/shapeshift/shapeshift-details/shapeshift-details.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["t" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], ShapeshiftDetailsPage);

//# sourceMappingURL=shapeshift-details.js.map

/***/ }),

/***/ 993:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftShiftPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__send_amount_amount__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_shapeshift_shapeshift__ = __webpack_require__(174);






// Pages

// Providers





let ShapeshiftShiftPage = class ShapeshiftShiftPage {
    constructor(actionSheetProvider, externalLinkProvider, logger, navCtrl, popupProvider, profileProvider, shapeshiftProvider, translate) {
        this.actionSheetProvider = actionSheetProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.shapeshiftProvider = shapeshiftProvider;
        this.translate = translate;
        this.walletsBtc = [];
        this.walletsBch = [];
        this.toWallets = [];
        this.fromWallets = [];
        this.fromWalletSelectorTitle = 'From';
        this.toWalletSelectorTitle = 'To';
        this.termsAccepted = false;
        this.network = this.shapeshiftProvider.getNetwork();
        this.walletsBtc = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            coin: 'btc'
        });
        this.walletsBch = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            coin: 'bch'
        });
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.walletsBtc) || __WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.walletsBch)) {
            this.showErrorAndBack(null, this.translate.instant('No wallets available to use ShapeShift'));
            return;
        }
        this.fromWallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            hasFunds: true
        });
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.fromWallets)) {
            this.showErrorAndBack(null, this.translate.instant('No wallets with funds'));
            return;
        }
        this.onFromWalletSelect(this.fromWallets[0]);
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: ShapeshiftShiftPage');
    }
    ionViewDidEnter() {
        this.termsAccepted = false;
    }
    openTerms() {
        let url = 'https://info.shapeshift.io/sites/default/files/ShapeShift_Terms_Conditions%20v1.1.pdf';
        this.externalLinkProvider.open(url);
    }
    showErrorAndBack(title, msg) {
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.errors ? msg.errors[0].message : msg;
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.navCtrl.pop();
        });
    }
    showToWallets() {
        this.toWallets =
            this.fromWallet.coin == 'btc' ? this.walletsBch : this.walletsBtc;
        this.toWallets = this.toWallets.filter(w => !w.needsBackup);
        if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](this.toWallets)) {
            let msg = this.translate.instant('Destination wallet needs to be backed up');
            this.showErrorAndBack(null, msg);
            return;
        }
        this.onToWalletSelect(this.toWallets[0]);
        let msg = this.translate.instant('ShapeShift is not available at this moment. Please, try again later.');
        let pair = this.fromWallet.coin + '_' + this.toWallet.coin;
        this.shapeshiftProvider.getMarketInfo(pair, (error, limit) => {
            if (error)
                return this.showErrorAndBack(null, msg);
            this.limit = limit;
            if (this.limit['rate'] == 0)
                return this.showErrorAndBack(null, msg);
        });
    }
    onFromWalletSelect(wallet) {
        this.fromWallet = wallet;
        this.showToWallets();
    }
    onToWalletSelect(wallet) {
        this.toWallet = wallet;
    }
    setAmount() {
        if (!this.termsAccepted) {
            return;
        }
        if (this.toWallet.needsBackup) {
            let title = this.translate.instant('Needs backup');
            let msg = this.translate.instant('The destination wallet is not backed up. Please, complete the backup process before continue.');
            this.popupProvider.ionicAlert(title, msg);
            return;
        }
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__send_amount_amount__["a" /* AmountPage */], {
            nextPage: 'ShapeshiftConfirmPage',
            fixedUnit: true,
            coin: this.fromWallet.coin,
            id: this.fromWallet.id,
            toWalletId: this.toWallet.id
        });
    }
    showWallets(selector) {
        let walletsForActionSheet = [];
        let selectedWalletId;
        let title = selector == 'from'
            ? this.fromWalletSelectorTitle
            : this.toWalletSelectorTitle;
        if (selector == 'from') {
            walletsForActionSheet = this.fromWallets;
            selectedWalletId = this.fromWallet.id;
        }
        else if (selector == 'to') {
            walletsForActionSheet = this.toWallets;
            selectedWalletId = this.toWallet.id;
        }
        const params = {
            wallets: walletsForActionSheet,
            selectedWalletId,
            title
        };
        const walletSelector = this.actionSheetProvider.createWalletSelector(params);
        walletSelector.present();
        walletSelector.onDidDismiss(wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet, selector);
        });
    }
    onWalletSelect(wallet, selector) {
        if (selector == 'from') {
            this.onFromWalletSelect(wallet);
        }
        else if (selector == 'to') {
            this.onToWalletSelect(wallet);
        }
    }
};
ShapeshiftShiftPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-shapeshift-shift',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/shapeshift/shapeshift-shift/shapeshift-shift.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Shift</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list *ngIf="fromWallets.length > 0 && toWallets.length > 0">\n    <div *ngIf="fromWallets.length > 0">\n      <div class="title">\n        <span translate>From</span>\n      </div>\n      <button ion-item detail-none (click)="showWallets(\'from\')">\n        <wallet-item-content [wallet]="fromWallet"></wallet-item-content>\n      </button>\n    </div>\n    <div *ngIf="toWallets.length > 0">\n      <div class="title">\n        <span translate>To</span>\n      </div>\n      <button ion-item detail-none (click)="showWallets(\'to\')">\n        <wallet-item-content [wallet]="toWallet"></wallet-item-content>\n      </button>\n    </div>\n\n    <div padding></div>\n\n    <ion-item>\n      {{\'Rate\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!limit">...</span>\n        <span *ngIf="limit">\n          {{limit.rate}} {{toWallet.coin | uppercase}} per {{fromWallet.coin | uppercase}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Deposit Min\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!limit">...</span>\n        <span *ngIf="limit">\n          {{limit.minimum}} {{fromWallet.coin | uppercase}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Deposit Max\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!limit">...</span>\n        <span *ngIf="limit">\n          {{limit.limit}} {{fromWallet.coin | uppercase}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Miner fee\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!limit">...</span>\n        <span *ngIf="limit">\n          {{limit.minerFee}} {{toWallet.coin | uppercase}}\n        </span>\n      </ion-note>\n    </ion-item>\n  </ion-list>\n\n  <div *ngIf="fromWallets.length > 0 && toWallets.length > 0" class="agree-to-terms">\n    <ion-item>\n      <ion-checkbox class="check" [(ngModel)]="termsAccepted"></ion-checkbox>\n    </ion-item>\n    <div class="terms">\n      <p>\n        <span translate>I agree to the Terms and certify that I am the beneficial owner of the input assets and the destination address.</span>\n        <a (click)="openTerms()" translate>Click to open Terms</a>.\n      </p>\n    </div>\n  </div>\n\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar *ngIf="fromWallets.length > 0 && toWallets.length > 0">\n    <button ion-button full class="button-footer" no-low-fee type="button" [disabled]="!fromWallet || !toWallet || !termsAccepted" (click)="setAmount()">\n      {{\'Continue\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/shapeshift/shapeshift-shift/shapeshift-shift.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], ShapeshiftShiftPage);

//# sourceMappingURL=shapeshift-shift.js.map

/***/ }),

/***/ 994:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CustomAmountPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_tx_format_tx_format__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_wallet_wallet__ = __webpack_require__(32);




// Native

// providers






let CustomAmountPage = class CustomAmountPage {
    constructor(currencyProvider, navParams, profileProvider, platformProvider, walletProvider, logger, socialSharing, txFormatProvider, actionSheetProvider, navCtrl) {
        this.currencyProvider = currencyProvider;
        this.navParams = navParams;
        this.profileProvider = profileProvider;
        this.platformProvider = platformProvider;
        this.walletProvider = walletProvider;
        this.logger = logger;
        this.socialSharing = socialSharing;
        this.txFormatProvider = txFormatProvider;
        this.actionSheetProvider = actionSheetProvider;
        this.navCtrl = navCtrl;
        const walletId = this.navParams.data.id;
        this.showShareButton = this.platformProvider.isCordova;
        this.wallet = this.profileProvider.getWallet(walletId);
        this.walletProvider.getAddress(this.wallet, false).then(addr => {
            this.address = this.walletProvider.getAddressView(this.wallet.coin, this.wallet.network, addr);
            const parsedAmount = this.txFormatProvider.parseAmount(this.wallet.coin, this.navParams.data.amount, this.navParams.data.currency);
            // Amount in USD or BTC
            const _amount = parsedAmount.amount;
            const _currency = parsedAmount.currency;
            this.amountUnitStr = parsedAmount.amountUnitStr;
            if (!__WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__["a" /* Coin */][_currency]) {
                // Convert to BTC or BCH
                const amountUnit = this.txFormatProvider.satToUnit(parsedAmount.amountSat, this.wallet.coin);
                var btcParsedAmount = this.txFormatProvider.parseAmount(this.wallet.coin, amountUnit, this.wallet.coin.toUpperCase());
                this.amountCoin = btcParsedAmount.amount;
                this.altAmountStr = btcParsedAmount.amountUnitStr;
            }
            else {
                this.amountCoin = _amount; // BTC or BCH
                this.altAmountStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, parsedAmount.amountSat);
            }
            let protoAddr;
            if (this.wallet.coin != 'bch') {
                protoAddr = this.walletProvider.getProtoAddress(this.wallet.coin, this.wallet.network, this.address);
            }
            if (this.currencyProvider.isUtxoCoin(this.wallet.coin)) {
                this.qrAddress =
                    (protoAddr ? protoAddr : this.address) + '?amount=' + this.amountCoin;
            }
            else {
                this.qrAddress =
                    (protoAddr ? protoAddr : this.address) +
                        '?value=' +
                        parsedAmount.amountSat;
            }
        });
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: CustomAmountPage');
    }
    shareAddress() {
        this.socialSharing.share(this.qrAddress);
    }
    showFullInfo() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('custom-amount', {
            qrAddress: this.qrAddress
        });
        infoSheet.present();
    }
    showPaymentRequestInfo() {
        const infoSheet = this.actionSheetProvider.createInfoSheet('payment-request', {
            amount: this.amountUnitStr,
            name: this.wallet.name
        });
        infoSheet.present();
    }
    close() {
        this.navCtrl.popToRoot();
    }
};
CustomAmountPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-custom-amount',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/receive/custom-amount/custom-amount.html"*/'<ion-header class="wallet-details-header">\n  <ion-navbar [hideBackButton]="true" class="app-color">\n    <ion-buttons left>\n      <button class="modal-close-button" (click)="close()" ion-button>\n        <ion-icon ios="md-close" md="md-close"></ion-icon>\n      </button>\n    </ion-buttons>\n    <ion-title>{{ wallet.name }}</ion-title>\n    <ion-buttons right>\n      <button *ngIf="showShareButton" ion-button icon-only (click)="shareAddress()">\n        <ion-icon ios="ios-share-outline" md="md-share"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="wrapper">\n    <div *ngIf="wallet" class="receive-content">\n      <div class="title-container">\n        <span class="title">{{\'Payment Request\' | translate}}</span>\n        <ion-icon (click)="showPaymentRequestInfo()">\n          <img src="assets/img/icon-info-blue.svg">\n        </ion-icon>\n      </div>\n      <div class="address-container">\n        <div class="text-address ellipsis">\n          <div class="address-text ellipsis">\n            <span>{{ address }}</span>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class="qr-container">\n      <div class="lines-background"></div>\n      <div class="card qr-card">\n        <img class="copy-icon" copy-to-clipboard="{{ qrAddress }}" src="assets/img/paste-clipboard.svg" width="18" />\n        <div>\n          <div class="qr-card-amount">\n            <span>{{amountUnitStr}}</span>\n            <br>\n            <small>({{altAmountStr}})</small>\n          </div>\n          <ngx-qrcode (click)="showFullInfo()" *ngIf="address" hide-toast="true" copy-to-clipboard="{{ qrAddress }}" qrc-value="{{qrAddress}}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n        </div>\n      </div>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/receive/custom-amount/custom-amount.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_currency_currency__["b" /* CurrencyProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_9__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_action_sheet_action_sheet__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */]])
], CustomAmountPage);

//# sourceMappingURL=custom-amount.js.map

/***/ }),

/***/ 995:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_analytics_analytics__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_app_app__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_bitpay_card_bitpay_card__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_home_integrations_home_integrations__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_language_language__ = __webpack_require__(244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_profile_profile__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_touchid_touchid__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__add_add__ = __webpack_require__(324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__integrations_bitpay_card_bitpay_settings_bitpay_settings__ = __webpack_require__(996);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__integrations_coinbase_coinbase_settings_coinbase_settings__ = __webpack_require__(997);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__integrations_gift_cards_gift_cards_settings_gift_cards_settings__ = __webpack_require__(998);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__integrations_shapeshift_shapeshift_settings_shapeshift_settings__ = __webpack_require__(1000);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__pin_pin_modal_pin_modal__ = __webpack_require__(332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__about_about__ = __webpack_require__(1001);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__addressbook_addressbook__ = __webpack_require__(1003);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__advanced_advanced__ = __webpack_require__(1005);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__alt_currency_alt_currency__ = __webpack_require__(1008);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__fee_policy_fee_policy__ = __webpack_require__(1009);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__language_language__ = __webpack_require__(1010);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__lock_lock__ = __webpack_require__(1011);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__notifications_notifications__ = __webpack_require__(1012);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__share_share__ = __webpack_require__(1013);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__wallet_group_settings_wallet_group_settings__ = __webpack_require__(1014);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__wallet_settings_wallet_settings__ = __webpack_require__(471);






// providers










// pages


















let SettingsPage = class SettingsPage {
    constructor(navCtrl, app, language, externalLinkProvider, profileProvider, configProvider, logger, homeIntegrationsProvider, bitPayCardProvider, platformProvider, translate, modalCtrl, touchid, externalLinkProvder, analyticsProvider) {
        this.navCtrl = navCtrl;
        this.app = app;
        this.language = language;
        this.externalLinkProvider = externalLinkProvider;
        this.profileProvider = profileProvider;
        this.configProvider = configProvider;
        this.logger = logger;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.touchid = touchid;
        this.externalLinkProvder = externalLinkProvder;
        this.analyticsProvider = analyticsProvider;
        this.integrationServices = [];
        this.bitpayCardItems = [];
        this.showBitPayCard = false;
        this.appName = this.app.info.nameCase;
        this.isCordova = this.platformProvider.isCordova;
    }
    ionViewDidLoad() {
        this.logger.info('Loaded: SettingsPage');
    }
    ionViewWillEnter() {
        this.currentLanguageName = this.language.getName(this.language.getCurrent());
        const opts = {
            showHidden: true
        };
        const wallets = this.profileProvider.getWallets(opts);
        this.walletsGroups = __WEBPACK_IMPORTED_MODULE_5_lodash__["values"](__WEBPACK_IMPORTED_MODULE_5_lodash__["groupBy"](wallets, 'keyId'));
        this.config = this.configProvider.get();
        this.selectedAlternative = {
            name: this.config.wallet.settings.alternativeName,
            isoCode: this.config.wallet.settings.alternativeIsoCode
        };
        this.lockMethod =
            this.config && this.config.lock && this.config.lock.method
                ? this.config.lock.method.toLowerCase()
                : null;
    }
    ionViewDidEnter() {
        // Show integrations
        const integrations = this.homeIntegrationsProvider.get();
        // Hide BitPay if linked
        setTimeout(() => {
            this.integrationServices = __WEBPACK_IMPORTED_MODULE_5_lodash__["remove"](__WEBPACK_IMPORTED_MODULE_5_lodash__["clone"](integrations), x => {
                if (x.name == 'debitcard' && x.linked)
                    return false;
                else
                    return x;
            });
        }, 200);
        // Only BitPay Wallet
        this.bitPayCardProvider.get({ noHistory: true }).then(cards => {
            this.showBitPayCard = !!this.app.info._enabledExtensions.debitcard;
            this.bitpayCardItems = cards;
        });
    }
    openAltCurrencyPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_26__alt_currency_alt_currency__["a" /* AltCurrencyPage */]);
    }
    openLanguagePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_28__language_language__["a" /* LanguagePage */]);
    }
    openAdvancedPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_25__advanced_advanced__["a" /* AdvancedPage */]);
    }
    openAboutPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_23__about_about__["a" /* AboutPage */]);
    }
    openLockPage() {
        const config = this.configProvider.get();
        const lockMethod = config && config.lock && config.lock.method
            ? config.lock.method.toLowerCase()
            : null;
        if (!lockMethod || lockMethod == 'disabled')
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_29__lock_lock__["a" /* LockPage */]);
        if (lockMethod == 'pin')
            this.openPinModal('lockSetUp');
        if (lockMethod == 'fingerprint')
            this.checkFingerprint();
    }
    openMerchantDirectorySite() {
        this.externalLinkProvder.open(`https://bitpay.com/directory/?hideGiftCards=true`);
    }
    openAddressBookPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_24__addressbook_addressbook__["a" /* AddressbookPage */]);
    }
    openNotificationsPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_30__notifications_notifications__["a" /* NotificationsPage */]);
    }
    openFeePolicyPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_27__fee_policy_fee_policy__["a" /* FeePolicyPage */]);
    }
    openWalletSettingsPage(walletId) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_33__wallet_settings_wallet_settings__["a" /* WalletSettingsPage */], { walletId });
    }
    openSharePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_31__share_share__["a" /* SharePage */]);
    }
    openSettingIntegration(name) {
        switch (name) {
            case 'coinbase':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_19__integrations_coinbase_coinbase_settings_coinbase_settings__["a" /* CoinbaseSettingsPage */]);
                break;
            case 'debitcard':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__integrations_bitpay_card_bitpay_settings_bitpay_settings__["a" /* BitPaySettingsPage */]);
                break;
            case 'shapeshift':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_21__integrations_shapeshift_shapeshift_settings_shapeshift_settings__["a" /* ShapeshiftSettingsPage */]);
                break;
            case 'giftcards':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_20__integrations_gift_cards_gift_cards_settings_gift_cards_settings__["a" /* GiftCardsSettingsPage */]);
                break;
        }
    }
    openCardSettings(id) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__integrations_bitpay_card_bitpay_settings_bitpay_settings__["a" /* BitPaySettingsPage */], { id });
    }
    openGiftCardsSettings() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_20__integrations_gift_cards_gift_cards_settings_gift_cards_settings__["a" /* GiftCardsSettingsPage */]);
    }
    openHelpExternalLink() {
        this.analyticsProvider.logEvent('help', {});
        const url = this.appName == 'Copay'
            ? 'https://github.com/bitpay/copay/issues'
            : 'https://help.bitpay.com/bitpay-app';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Help and support information is available at the website.');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    addBitpayCard() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__["a" /* BitPayCardIntroPage */]);
    }
    openPinModal(action) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_22__pin_pin_modal_pin_modal__["a" /* PinModalPage */], { action }, { cssClass: 'fullscreen-modal' });
        modal.present();
        modal.onDidDismiss(cancelClicked => {
            if (!cancelClicked)
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_29__lock_lock__["a" /* LockPage */]);
        });
    }
    checkFingerprint() {
        this.touchid.check().then(() => {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_29__lock_lock__["a" /* LockPage */]);
        });
    }
    openSupportEncryptPassword() {
        const url = 'https://support.bitpay.com/hc/en-us/articles/360000244506-What-Does-a-Spending-Password-Do-';
        const optIn = true;
        const title = null;
        const message = this.translate.instant('Read more in our support page');
        const okText = this.translate.instant('Open');
        const cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openWalletGroupSettings(keyId) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_32__wallet_group_settings_wallet_group_settings__["a" /* WalletGroupSettingsPage */], { keyId });
    }
    goToAddView() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__add_add__["a" /* AddPage */], {
            isZeroState: true
        });
    }
};
SettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-settings',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/settings/settings.html"*/'<ion-header class="wide-header">\n  <ion-navbar [navbar-bg]="headerColor">\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        {{\'Settings\' | translate}}\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea [fixed-scroll-bg-color]="headerColor" [ion-content-background-color]="headerColor">\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar [navbar-bg]="headerColor" class="wide-header__title">\n        <expandable-header-primary>\n          {{\'Settings\' | translate}}\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <div *ngIf="appName === \'BitPay\'" class="no-padding hairline" no-padding detail-none>\n      <div class="merchant-directory-container">\n        <div class="merchant-directory-body">\n          <h4>Learn where you can spend your crypto today.</h4>\n          <div (click)="openMerchantDirectorySite()" class="merchant-directory-link" href="">View Directory</div>\n        </div>\n        <div class="gumball">\n          <img src="assets/img/gumball-3.svg" class="gumball-image" width="150" height="150" />\n        </div>\n      </div>\n    </div>\n    <div class="hairline"></div>\n    <ion-list class="settings-list bp-list">\n      <button ion-item (click)="openAddressBookPage()">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-address-book.svg" width="22">\n        </ion-icon>\n        <span translate>Address book</span>\n      </button>\n\n      <button ion-item (click)="openHelpExternalLink()">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-help-support.svg" width="22">\n        </ion-icon>\n        <span translate>Help &amp; support</span>\n      </button>\n\n      <button ion-item *ngIf="isCordova" (click)="openSharePage()">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-heart.svg" width="22">\n        </ion-icon>\n        <span translate>Share</span> {{ appName }}\n      </button>\n\n      <ion-item-divider *ngIf="walletsGroups && walletsGroups[0]">\n        {{\'Keys\' | translate}}\n      </ion-item-divider>\n\n      <button ion-item *ngFor="let walletsGroup of walletsGroups; let i = index" (click)="openWalletGroupSettings(walletsGroup[0].keyId)">\n        <ion-icon *ngIf="walletsGroup[0].canSign" class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-key.svg" width="22">\n        </ion-icon>\n        <ion-icon *ngIf="!walletsGroup[0].canSign" item-start>\n          <img src="assets/img/settings-icons/icon-read-only.svg" width="26">\n        </ion-icon>\n        <ion-label>\n          <div *ngIf="walletsGroup[0].canSign">{{profileProvider.getWalletGroup(walletsGroup[0].keyId).name}}</div>\n          <div *ngIf="!walletsGroup[0].canSign" translate>Read Only Wallets</div>\n        </ion-label>\n        <ion-note item-end>\n          {{walletsGroup.length}} Wallet<span *ngIf="walletsGroup.length > 1">s</span>\n        </ion-note>\n      </button>\n      <button ion-item detail-none class="create-button" *ngIf="walletsGroups && walletsGroups[0]" (click)="goToAddView()" translate>\n        Create or Import a Key\n      </button>\n\n      <ion-item-divider>{{\'Preferences\' | translate}}</ion-item-divider>\n\n      <button ion-item (click)="openNotificationsPage()">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-notifications.svg" width="22">\n        </ion-icon>\n        <span translate>Notifications</span>\n      </button>\n\n      <button ion-item (click)="openLanguagePage()">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-language.svg" width="22">\n        </ion-icon>\n        <ion-label>\n          <span translate>Language</span>\n        </ion-label>\n        <ion-note *ngIf="currentLanguageName" item-end>\n          {{ currentLanguageName }}\n        </ion-note>\n      </button>\n\n      <button ion-item (click)="openAltCurrencyPage()">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-currency.svg" width="22">\n        </ion-icon>\n        <ion-label>\n          {{\'Alternative currency\' | translate}}\n        </ion-label>\n        <ion-note *ngIf="selectedAlternative" item-end>\n          {{ selectedAlternative.name }}\n        </ion-note>\n      </button>\n\n      <button ion-item (click)="openFeePolicyPage()">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-network.svg" width="22">\n        </ion-icon>\n        <ion-label>\n          {{\'Bitcoin network fee policy\' | translate}}\n        </ion-label>\n      </button>\n\n      <button ion-item *ngIf="isCordova" (click)="openLockPage()">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-lock.svg" width="22">\n        </ion-icon>\n        <ion-label>\n          {{\'Lock\' | translate}}\n        </ion-label>\n        <ion-note *ngIf="lockMethod === \'disabled\'" item-end>\n          {{\'Disabled\' | translate}}\n        </ion-note>\n        <ion-note *ngIf="lockMethod === \'pin\'" item-end>\n          {{\'PIN\' | translate}}\n        </ion-note>\n        <ion-note *ngIf="lockMethod === \'fingerprint\'" item-end>\n          {{\'Biometric\' | translate}}\n        </ion-note>\n      </button>\n\n      <div *ngIf="showBitPayCard && bitpayCardItems && bitpayCardItems[0]">\n        <ion-item-divider>\n          BitPay Visa\n          <sup>&reg;</sup> Card\n        </ion-item-divider>\n        <ion-list>\n          <button ion-item *ngFor="let card of bitpayCardItems" (click)="openCardSettings(card.id)">\n            <ion-icon class="item-img" item-start>\n              <img src="assets/img/icon-card.svg" class="icon-card" />\n            </ion-icon>\n            <div class="item-title">BitPay Visa&reg; Card ({{card.lastFourDigits}})</div>\n            <div class="item-subtitle">{{card.balance ? (card.balance | currency:card.currencySymbol:2) : \'Add funds to\n                get started\'|translate}} {{card.updatedOn\n                ? (\' &middot; \' + (card.updatedOn * 1000 | amTimeAgo)) : \'\'}}</div>\n          </button>\n          <button ion-item detail-none class="create-button" (click)="addBitpayCard()" translate>\n            Add Card\n          </button>\n        </ion-list>\n      </div>\n\n\n      <ion-item-divider *ngIf="integrationServices && integrationServices[0]">\n        {{\'Integrations\' | translate}}\n      </ion-item-divider>\n\n      <button ion-item *ngFor="let integration of integrationServices | orderBy : [\'title\']" (click)="openSettingIntegration(integration.name)">\n        <ion-icon class="item-img" item-start>\n          <img src="{{integration.icon}}" class="icon-settings" />\n        </ion-icon>\n        <span>{{integration.title}}</span>\n        <ion-note item-end *ngIf="integration.linked">\n          <span *ngIf="integration.linked" translate>Linked</span>\n          <span *ngIf="!integration.linked">\n            {{integration.show ? (\'On\'|translate) : (\'Off\'|translate)}}\n          </span>\n        </ion-note>\n      </button>\n\n      <ion-item-divider>{{\'More\' | translate}}</ion-item-divider>\n\n      <button ion-item (click)="openAdvancedPage()">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-advanced.svg" width="22">\n        </ion-icon>\n        <span translate>Advanced</span>\n      </button>\n\n      <button ion-item (click)="openAboutPage()">\n        <ion-icon class="item-img settings-icon" item-start>\n          <img src="assets/img/settings-icons/icon-info.svg" width="22">\n        </ion-icon>\n        <span translate>About</span> {{appName}}\n      </button>\n    </ion-list>\n  </div>\n</ion-content>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/settings/settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_15__providers_touchid_touchid__["a" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_analytics_analytics__["a" /* AnalyticsProvider */]])
], SettingsPage);

//# sourceMappingURL=settings.js.map

/***/ }),

/***/ 996:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPaySettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bitpay_account_bitpay_account__ = __webpack_require__(463);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bitpay_card_bitpay_card__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_home_integrations_home_integrations__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(18);




// Providers





let BitPaySettingsPage = class BitPaySettingsPage {
    constructor(navParams, navCtrl, bitpayAccountProvider, bitPayCardProvider, popupProvider, configProvider, homeIntegrationsProvider) {
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.bitpayAccountProvider = bitpayAccountProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.popupProvider = popupProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.serviceName = 'debitcard';
        this.service = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showAtHome = !!this.service[0].show;
    }
    ionViewWillEnter() {
        let cardId = this.navParams.data.id;
        if (cardId) {
            this.bitPayCardProvider.getCards(cards => {
                this.bitpayCard = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](cards, { id: cardId });
            });
        }
        else {
            this.service = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.homeIntegrationsProvider.get(), {
                name: this.serviceName
            });
            this.showAtHome = !!this.service[0].show;
        }
    }
    integrationChange() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showAtHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showAtHome);
        this.configProvider.set(opts);
    }
    unlinkCard(card) {
        let title = 'Unlink BitPay Card?';
        let msg = 'Are you sure you would like to remove your BitPay Card (' +
            card.lastFourDigits +
            ') from this device?';
        this.popupProvider.ionicConfirm(title, msg).then(res => {
            if (res) {
                this.bitPayCardProvider.remove(card.id, err => {
                    if (err) {
                        this.popupProvider.ionicAlert('Error', 'Could not remove the card');
                        return;
                    }
                    this.navCtrl.pop();
                });
            }
        });
    }
    unlinkAccount(card) {
        let title = 'Unlink BitPay Account?';
        let msg = 'Are you sure you would like to remove your BitPay Account (' +
            card.email +
            ') and all associated cards from this device?';
        this.popupProvider.ionicConfirm(title, msg).then(res => {
            if (res) {
                this.bitpayAccountProvider.removeAccount(card.email, () => {
                    this.navCtrl.pop();
                });
            }
        });
    }
};
BitPaySettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-bitpay-settings',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/bitpay-card/bitpay-settings/bitpay-settings.html"*/'<wide-header-page title="{{\'Card Settings\'|translate}}">\n  <div page-content>\n    <ion-list class="bp-list" [ngClass]="{\'top-padding\': !bitpayCard}">\n      <ion-item *ngIf="!bitpayCard">\n        <ion-label>{{\'Show in Home\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="showAtHome" (ionChange)="integrationChange()"></ion-toggle>\n      </ion-item>\n\n\n      <div *ngIf="bitpayCard">\n        <ion-item>\n          <ion-icon item-start>\n            <img width="60" src="assets/img/bitpay-card/bitpay-card-visa.svg" />\n          </ion-icon>\n          <h2>BitPay Visa&reg; Card</h2>\n          <p>{{bitpayCard.email}}</p>\n        </ion-item>\n        <ion-item>\n          Last four digits\n          <ion-note item-end>\n            {{bitpayCard.lastFourDigits}}\n          </ion-note>\n        </ion-item>\n\n        <button ion-item class="with-label no-border" (click)="unlinkCard(bitpayCard)">\n          <ion-label>{{\'Unlink card\' | translate}}</ion-label>\n        </button>\n        <label-tip type="warn" header="no-header">\n          <div label-tip-body>\n            <div translate>Unlink the card will remove it from this device.</div>\n          </div>\n        </label-tip>\n\n        <button ion-item class="with-label no-border" (click)="unlinkAccount(bitpayCard)">\n          <ion-label>{{\'Unlink account\' | translate}}</ion-label>\n        </button>\n        <label-tip type="warn" header="no-header">\n          <div label-tip-body>\n            <div translate>Unlink the account will remove it and all associated cards from this device.</div>\n          </div>\n        </label-tip>\n      </div>\n\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/bitpay-card/bitpay-settings/bitpay-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bitpay_account_bitpay_account__["a" /* BitPayAccountProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */]])
], BitPaySettingsPage);

//# sourceMappingURL=bitpay-settings.js.map

/***/ }),

/***/ 997:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_coinbase_coinbase__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_home_integrations_home_integrations__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(18);




// Providers





let CoinbaseSettingsPage = class CoinbaseSettingsPage {
    constructor(navCtrl, popupProvider, logger, coinbaseProvider, configProvider, homeIntegrationsProvider) {
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.coinbaseProvider = coinbaseProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.serviceName = 'coinbase';
        this.service = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showInHome = !!this.service[0].show;
    }
    ionViewDidLoad() {
        this.loading = true;
        this.coinbaseProvider.init((err, data) => {
            if (err || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](data)) {
                this.loading = false;
                if (err) {
                    this.logger.error(err);
                    let errorId = err.errors ? err.errors[0].id : null;
                    err = err.errors ? err.errors[0].message : err;
                    this.popupProvider
                        .ionicAlert('Error connecting to Coinbase', err)
                        .then(() => {
                        if (errorId == 'revoked_token') {
                            this.coinbaseProvider.logout();
                            this.navCtrl.popToRoot({ animate: false });
                        }
                    });
                }
                return;
            }
            let accessToken = data.accessToken;
            let accountId = data.accountId;
            this.coinbaseProvider.getAccount(accessToken, accountId, (err, account) => {
                this.loading = false;
                if (err)
                    this.logger.error(err);
                this.coinbaseAccount = account.data[0];
            });
            this.coinbaseProvider.getCurrentUser(accessToken, (err, user) => {
                if (err)
                    this.logger.error(err);
                this.coinbaseUser = user.data;
            });
        });
    }
    showInHomeSwitch() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showInHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showInHome);
        this.configProvider.set(opts);
    }
    revokeToken() {
        this.popupProvider
            .ionicConfirm('Coinbase', 'Are you sure you would like to log out of your Coinbase account?')
            .then(res => {
            if (res) {
                this.coinbaseProvider.logout();
                this.showInHome = false;
                this.showInHomeSwitch();
                this.navCtrl.popToRoot();
            }
        });
    }
};
CoinbaseSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-coinbase-settings',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/coinbase/coinbase-settings/coinbase-settings.html"*/'<ion-header class="wide-header">\n  <ion-navbar>\n    <ion-title>\n      <div [reveal-at-scroll-pos]="expandableHeader.headerHeight" [scrollArea]="scrollArea">\n        <img src="assets/img/coinbase/coinbase-logo.png" width="70">\n      </div>\n    </ion-title>\n    <ng-content select="[right]"></ng-content>\n  </ion-navbar>\n</ion-header>\n\n<ion-content #scrollArea>\n  <div class="wrapper">\n    <expandable-header [scrollArea]="scrollArea" [fadeFactor]="5" [disableFade]="true" #expandableHeader>\n      <ion-toolbar class="wide-header__title">\n        <expandable-header-primary>\n          <img margin-left src="assets/img/coinbase/coinbase-logo.png" width="150">\n        </expandable-header-primary>\n      </ion-toolbar>\n    </expandable-header>\n\n    <ion-list class="bp-list">\n      <ion-item>\n        <ion-label>{{\'Show in Home\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="showInHome" (ionChange)="showInHomeSwitch()"></ion-toggle>\n      </ion-item>\n    </ion-list>\n\n    <ion-spinner *ngIf="loading"></ion-spinner>\n\n    <ion-list *ngIf="coinbaseAccount && coinbaseAccount.balance">\n      <ion-item-divider>Account</ion-item-divider>\n      <ion-item>\n        <span>ID</span>\n        <ion-note item-end>\n          {{coinbaseAccount.id}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Name</span>\n        <ion-note item-end>\n          {{coinbaseAccount.name}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Balance</span>\n        <ion-note item-end>\n          {{coinbaseAccount.balance.amount}} {{coinbaseAccount.balance.currency}}\n        </ion-note>\n      </ion-item>\n    </ion-list>\n\n    <ion-list *ngIf="coinbaseUser">\n      <ion-item-divider>User Information</ion-item-divider>\n      <ion-item>\n        <span>ID</span>\n        <ion-note item-end>\n          {{coinbaseUser.id}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Email</span>\n        <ion-note item-end>\n          {{coinbaseUser.email}}\n        </ion-note>\n      </ion-item>\n    </ion-list>\n\n    <div padding-bottom padding-top>\n      <button *ngIf="coinbaseAccount" ion-button class="button-standard" color="danger" (click)="revokeToken()">\n        {{\'Log out\' | translate}}\n      </button>\n    </div>\n\n  </div>\n</ion-content>\n'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/coinbase/coinbase-settings/coinbase-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */]])
], CoinbaseSettingsPage);

//# sourceMappingURL=coinbase-settings.js.map

/***/ }),

/***/ 998:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GiftCardsSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gift_card_settings_gift_card_settings__ = __webpack_require__(999);






let GiftCardsSettingsPage = class GiftCardsSettingsPage {
    constructor(configProvider, giftCardProvider, homeIntegrationsProvider, nav) {
        this.configProvider = configProvider;
        this.giftCardProvider = giftCardProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.nav = nav;
    }
    ngOnInit() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.showAtHome = this.homeIntegrationsProvider.shouldShowInHome('giftcards');
            const purchasedCards = yield this.giftCardProvider.getPurchasedBrands();
            this.purchasedBrands = __WEBPACK_IMPORTED_MODULE_3_lodash__["uniqBy"](purchasedCards, ([cards]) => cards.displayName);
        });
    }
    goToCardSettings(cardName) {
        this.nav.push(__WEBPACK_IMPORTED_MODULE_5__gift_card_settings_gift_card_settings__["a" /* GiftCardSettingsPage */], { cardName });
    }
    integrationChange() {
        this.homeIntegrationsProvider.updateConfig('giftcards', this.showAtHome);
        this.configProvider.set({
            showIntegration: { giftcards: this.showAtHome }
        });
    }
};
GiftCardsSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'gift-cards-settings-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/gift-cards-settings/gift-cards-settings.html"*/'<wide-header-page title="Gift Card Settings">\n  <div page-content>\n    <ion-list class="bp-list top-padding">\n      <ion-item>\n        <ion-label>{{\'Show in Home\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="showAtHome" (ionChange)="integrationChange()"></ion-toggle>\n      </ion-item>\n      <ion-item-divider *ngIf="purchasedBrands?.length">{{\'Purchased Brands\' | translate}}</ion-item-divider>\n      <card-list-item *ngFor="let brandCards of purchasedBrands" [card]="brandCards[0]" type="settings"\n        (click)="goToCardSettings(brandCards[0].name)"></card-list-item>\n      <ion-item-divider></ion-item-divider>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/gift-cards-settings/gift-cards-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers__["q" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["E" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers__["F" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* NavController */]])
], GiftCardsSettingsPage);

//# sourceMappingURL=gift-cards-settings.js.map

/***/ }),

/***/ 999:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GiftCardSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__purchased_cards_purchased_cards__ = __webpack_require__(329);







let GiftCardSettingsPage = class GiftCardSettingsPage extends __WEBPACK_IMPORTED_MODULE_6__purchased_cards_purchased_cards__["b" /* PurchasedCardsPage */] {
    constructor(actionSheetProvider, giftCardProvider, logger, navCtrl, navParams, popupProvider, translate) {
        super(actionSheetProvider, giftCardProvider, logger, navCtrl, navParams);
        this.popupProvider = popupProvider;
        this.translate = translate;
    }
    ionViewDidLoad() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.initialize();
        });
    }
    getCards() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            yield this.giftCardProvider
                .getAllCardsOfBrand(this.cardConfig.displayName)
                .then(cards => this.setGiftCards(cards))
                .catch(err => this.logger.error(err));
            this.giftCardProvider.updatePendingGiftCards(this.currentGiftCards);
        });
    }
    initialize() {
        return __WEBPACK_IMPORTED_MODULE_0_tslib__["b" /* __awaiter */](this, void 0, void 0, function* () {
            this.email = yield this.giftCardProvider.getUserEmail();
        });
    }
    setEmail() {
        let title = this.translate.instant('Enter email address');
        let message = this.translate.instant('Where would you like to receive your Amazon gift card purchase receipts?');
        let opts = { type: 'email', defaultText: this.email || '' };
        this.popupProvider.ionicPrompt(title, message, opts).then(email => {
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isNull"](email))
                return;
            if (this.email == email)
                return;
            if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](email) && !this.giftCardProvider.emailIsValid(email)) {
                let t = this.translate.instant('Invalid Email');
                let ok = this.translate.instant('Try again');
                this.popupProvider.ionicAlert(t, null, ok).then(_ => {
                    this.setEmail();
                });
                return;
            }
            this.email = email;
            this.giftCardProvider.storeEmail(this.email);
        });
    }
    removePageFromHistory() {
        // Override extended behavior and don't remove page from history.
    }
};
GiftCardSettingsPage = __WEBPACK_IMPORTED_MODULE_0_tslib__["c" /* __decorate */]([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'gift-card-settings-page',template:/*ion-inline-start:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/gift-card-settings/gift-card-settings.html"*/'<wide-header-page title="{{cardConfig?.displayName}}">\n  <div page-content>\n\n    <ion-list class="bp-list" [ngClass]="{\'top-padding\': cardConfig?.displayName === \'Amazon\'}">\n      <button (click)="setEmail()" ion-item *ngIf="cardConfig?.displayName === \'Amazon\'">\n        <ion-label>{{ \'Receipt Email\' | translate }}</ion-label>\n        <ion-note item-end>\n          {{ email || (\'Not set\' | translate) }}\n        </ion-note>\n      </button>\n      <ion-item-divider *ngIf="currentGiftCards && currentGiftCards.length">{{\'Current Cards\' | translate}}\n      </ion-item-divider>\n      <card-list-item *ngFor="let card of currentGiftCards" [card]="card" type="purchased"\n        (click)="goToCardDetails(card)"></card-list-item>\n      <ion-item-divider *ngIf="archivedGiftCards && archivedGiftCards.length">{{\'Archived Cards\' | translate}}\n      </ion-item-divider>\n      <card-list-item *ngFor="let card of archivedGiftCards" [card]="card" type="purchased"\n        (click)="goToCardDetails(card)"></card-list-item>\n      <ion-item-divider></ion-item-divider>\n    </ion-list>\n  </div>\n</wide-header-page>'/*ion-inline-end:"/Users/justin/bitpay/copay/src/pages/integrations/gift-cards/gift-card-settings/gift-card-settings.html"*/
    }),
    __WEBPACK_IMPORTED_MODULE_0_tslib__["f" /* __metadata */]("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers__["a" /* ActionSheetProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["E" /* GiftCardProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["N" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["o" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers__["S" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["f" /* TranslateService */]])
], GiftCardSettingsPage);

//# sourceMappingURL=gift-card-settings.js.map

/***/ })

},[1042]);
//# sourceMappingURL=main.js.map